This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-29T09:37:36.597Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
.replit
attached_assets/caption_scraper.py
attached_assets/Pasted-Create-a-complete-Vite-React-TypeScript-Python-FastAPI-Tailwind-CSS-application-structured-as-follo-1748392447738.txt
attached_assets/transcript_processor.py
attached_assets/youtube_handler.py
client/advanced-test.html
client/index.html
client/src/App.tsx
client/src/components/admin/system-stats.tsx
client/src/components/admin/user-management.tsx
client/src/components/episodes/batch-process-dialog.tsx
client/src/components/episodes/episode-card.tsx
client/src/components/episodes/extraction-method-selector.tsx
client/src/components/episodes/highlighted-transcript.tsx
client/src/components/episodes/processing-status.tsx
client/src/components/episodes/simple-processing-indicator.tsx
client/src/components/episodes/transcript-viewer.tsx
client/src/components/layout/header.tsx
client/src/components/layout/main-layout.tsx
client/src/components/layout/sidebar.tsx
client/src/components/search/search-results.tsx
client/src/components/search/transcript-modal.tsx
client/src/components/ui/accordion.tsx
client/src/components/ui/alert-dialog.tsx
client/src/components/ui/alert.tsx
client/src/components/ui/aspect-ratio.tsx
client/src/components/ui/avatar.tsx
client/src/components/ui/badge.tsx
client/src/components/ui/breadcrumb.tsx
client/src/components/ui/button.tsx
client/src/components/ui/calendar.tsx
client/src/components/ui/card.tsx
client/src/components/ui/carousel.tsx
client/src/components/ui/chart.tsx
client/src/components/ui/checkbox.tsx
client/src/components/ui/collapsible.tsx
client/src/components/ui/command.tsx
client/src/components/ui/context-menu.tsx
client/src/components/ui/dialog.tsx
client/src/components/ui/drawer.tsx
client/src/components/ui/dropdown-menu.tsx
client/src/components/ui/form.tsx
client/src/components/ui/hover-card.tsx
client/src/components/ui/input-otp.tsx
client/src/components/ui/input.tsx
client/src/components/ui/label.tsx
client/src/components/ui/menubar.tsx
client/src/components/ui/navigation-menu.tsx
client/src/components/ui/notification-bell.tsx
client/src/components/ui/pagination.tsx
client/src/components/ui/popover.tsx
client/src/components/ui/progress.tsx
client/src/components/ui/radio-group.tsx
client/src/components/ui/resizable.tsx
client/src/components/ui/scroll-area.tsx
client/src/components/ui/select.tsx
client/src/components/ui/separator.tsx
client/src/components/ui/sheet.tsx
client/src/components/ui/sidebar.tsx
client/src/components/ui/skeleton.tsx
client/src/components/ui/slider.tsx
client/src/components/ui/stats-card-grid.tsx
client/src/components/ui/switch.tsx
client/src/components/ui/table.tsx
client/src/components/ui/tabs.tsx
client/src/components/ui/textarea.tsx
client/src/components/ui/toast.tsx
client/src/components/ui/toaster.tsx
client/src/components/ui/toggle-group.tsx
client/src/components/ui/toggle.tsx
client/src/components/ui/tooltip.tsx
client/src/hooks/use-admin-auth.ts
client/src/hooks/use-app-updates.ts
client/src/hooks/use-auth.ts
client/src/hooks/use-episode-notifications.ts
client/src/hooks/use-episodes.ts
client/src/hooks/use-mobile.tsx
client/src/hooks/use-search.ts
client/src/hooks/use-toast.ts
client/src/hooks/useSystemStats.ts
client/src/index.css
client/src/lib/api.ts
client/src/lib/keyword-analyzer.ts
client/src/lib/notification-context.tsx
client/src/lib/queryClient.ts
client/src/lib/utils.ts
client/src/main.tsx
client/src/pages/add-episode.tsx
client/src/pages/admin-login.tsx
client/src/pages/admin.tsx
client/src/pages/dashboard.tsx
client/src/pages/episodes.tsx
client/src/pages/not-found.tsx
client/src/pages/search.tsx
client/src/test-highlight.ts
client/src/types/index.ts
client/test-highlight.html
components.json
drizzle.config.ts
migrations/0000_harsh_doomsday.sql
migrations/0001_lazy_rockslide.sql
migrations/0002_admin_users.sql
migrations/meta/_journal.json
migrations/meta/0000_snapshot.json
migrations/meta/0001_snapshot.json
package.json
postcss.config.js
pyproject.toml
README.md
server/caption_scraper.py
server/complete_caption_scraper.py
server/db.ts
server/index.ts
server/keyword-analyzer.ts
server/migrate.ts
server/puppeteer_caption_scraper.js
server/routes.ts
server/storage.ts
server/test-storage.ts
server/ts-advanced-scraper.ts
server/ts-caption-scraper.ts
server/vite.ts
server/youtube_handler.py
shared/schema.ts
tailwind.config.ts
tsconfig.json
uv.lock
vite.config.ts

================================================================
Files
================================================================

================
File: .gitignore
================
node_modules
dist
.DS_Store
server/public
vite.config.ts.*
*.tar.gz
.env

================
File: .replit
================
modules = ["nodejs-20", "web", "postgresql-16", "python-3.11"]
run = "npm run dev"
hidden = [".config", ".git", "generated-icon.png", "node_modules", "dist"]

[nix]
channel = "stable-24_05"

[deployment]
deploymentTarget = "autoscale"
build = ["npm", "run", "build"]
run = ["npm", "run", "start"]

[[ports]]
localPort = 5000
externalPort = 80

[workflows]
runButton = "Project"

[[workflows.workflow]]
name = "Project"
mode = "parallel"
author = "agent"

[[workflows.workflow.tasks]]
task = "workflow.run"
args = "Start application"

[[workflows.workflow]]
name = "Start application"
author = "agent"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "npm run dev"
waitForPort = 5000

================
File: attached_assets/caption_scraper.py
================
import re
import requests
import json
from urllib.parse import unquote
from typing import Optional, Dict

class CaptionScraper:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        })

    def extract_captions_from_page(self, video_id: str) -> Optional[Dict]:
        """
        Extract captions directly from YouTube using multiple strategies
        """
        try:
            # Strategy 1: Try direct timedtext API
            caption_text = self._try_direct_timedtext_api(video_id)
            
            if not caption_text:
                # Strategy 2: Try transcript page scraping
                caption_text = self._try_transcript_page_scraping(video_id)
            
            if not caption_text or len(caption_text.strip()) < 50:
                return None
            
            # Get basic metadata
            title, upload_date, channel = self._get_basic_metadata(video_id)
            
            return {
                'transcript': caption_text,
                'title': title or f'Video {video_id}',
                'date': upload_date or '2024-01-01',
                'channel': channel or 'Unknown Channel',
                'video_id': video_id,
                'extraction_method': 'web_scraping'
            }
            
        except Exception as e:
            print(f"Error scraping captions for {video_id}: {e}")
            return None

    def _try_direct_timedtext_api(self, video_id: str) -> Optional[str]:
        """Try using youtube-transcript-api with authentication"""
        try:
            from youtube_transcript_api import YouTubeTranscriptApi
            import os
            
            # Check if we have YouTube cookies for authentication
            cookies_file = os.environ.get('YOUTUBE_COOKIES')
            
            if cookies_file:
                # Use cookies for authentication to bypass IP blocking
                transcript_list = YouTubeTranscriptApi.get_transcript(
                    video_id, 
                    languages=['en', 'en-US'],
                    cookies=cookies_file
                )
            else:
                # Try without authentication first
                transcript_list = YouTubeTranscriptApi.get_transcript(video_id, languages=['en', 'en-US'])
            
            if transcript_list:
                # Combine all text segments
                full_text = ' '.join([item['text'] for item in transcript_list])
                return self._clean_text(full_text)
                
        except ImportError:
            print("youtube-transcript-api not available")
        except Exception as e:
            if "IP" in str(e) or "blocked" in str(e).lower():
                print(f"YouTube is blocking requests from this server. Authentication needed: {e}")
                return "AUTH_REQUIRED"
            else:
                print(f"YouTube Transcript API failed: {e}")
            
        return None

    def _try_transcript_page_scraping(self, video_id: str) -> Optional[str]:
        """Try scraping the main video page for embedded captions"""
        try:
            url = f"https://www.youtube.com/watch?v={video_id}"
            response = self.session.get(url, timeout=15)
            
            if response.status_code != 200:
                return None
            
            html_content = response.text
            return self._extract_caption_data(html_content)
            
        except Exception as e:
            print(f"Page scraping failed: {e}")
            return None

    def _get_basic_metadata(self, video_id: str) -> tuple:
        """Get basic video metadata"""
        try:
            url = f"https://www.youtube.com/watch?v={video_id}"
            response = self.session.get(url, timeout=10)
            
            if response.status_code == 200:
                html = response.text
                title = self._extract_title(html)
                date = self._extract_upload_date(html)
                channel = self._extract_channel(html)
                return title, date, channel
        except:
            pass
        
        return None, None, None

    def _extract_title(self, html: str) -> Optional[str]:
        """Extract video title from HTML"""
        patterns = [
            r'"title"\s*:\s*"([^"]+)"',
            r'<title>([^<]+)</title>',
            r'property="og:title"\s+content="([^"]+)"'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, html)
            if match:
                title = match.group(1)
                if ' - YouTube' in title:
                    title = title.replace(' - YouTube', '')
                return self._clean_text(title)
        return None

    def _extract_upload_date(self, html: str) -> Optional[str]:
        """Extract upload date from HTML"""
        patterns = [
            r'"uploadDate"\s*:\s*"([^"]+)"',
            r'"datePublished"\s*:\s*"([^"]+)"'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, html)
            if match:
                date_str = match.group(1)
                try:
                    from datetime import datetime
                    # Parse ISO format date
                    date_obj = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
                    return date_obj.strftime('%Y-%m-%d')
                except:
                    continue
        return None

    def _extract_channel(self, html: str) -> Optional[str]:
        """Extract channel name from HTML"""
        patterns = [
            r'"author"\s*:\s*"([^"]+)"',
            r'"ownerChannelName"\s*:\s*"([^"]+)"',
            r'property="og:video:tag"\s+content="([^"]+)"'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, html)
            if match:
                return self._clean_text(match.group(1))
        return None

    def _extract_caption_data(self, html: str) -> Optional[str]:
        """Extract caption/subtitle data from HTML"""
        try:
            # Look for the player config that contains caption track URLs
            player_config_pattern = r'ytInitialPlayerResponse\s*=\s*({.+?});'
            match = re.search(player_config_pattern, html)
            
            if match:
                try:
                    config_json = match.group(1)
                    import json
                    player_data = json.loads(config_json)
                    
                    # Navigate to captions data
                    captions = player_data.get('captions', {})
                    caption_tracks = captions.get('playerCaptionsTracklistRenderer', {}).get('captionTracks', [])
                    
                    # Find English captions (prefer manual over auto-generated)
                    english_track = None
                    for track in caption_tracks:
                        if track.get('languageCode', '').startswith('en'):
                            if track.get('kind') != 'asr':  # Manual captions
                                english_track = track
                                break
                            elif english_track is None:  # Auto-generated as fallback
                                english_track = track
                    
                    if english_track and 'baseUrl' in english_track:
                        caption_url = english_track['baseUrl']
                        caption_text = self._download_caption_file(caption_url)
                        if caption_text and len(caption_text.strip()) > 100:
                            return caption_text
                
                except json.JSONDecodeError:
                    print("Failed to parse player config JSON")
            
            # Fallback: Look for caption tracks in a simpler pattern
            caption_url_pattern = r'"baseUrl":"([^"]*transcript[^"]*)"'
            url_matches = re.findall(caption_url_pattern, html)
            
            for url in url_matches:
                if 'lang=en' in url or '&tlang=en' in url:
                    clean_url = url.replace('\\u0026', '&').replace('\\/', '/').replace('\\/','/')
                    caption_text = self._download_caption_file(clean_url)
                    if caption_text and len(caption_text.strip()) > 100:
                        return caption_text
            
            # Another fallback: look for any transcript-like URLs
            transcript_patterns = [
                r'"baseUrl":"([^"]*timedtext[^"]*lang=en[^"]*)"',
                r'"baseUrl":"([^"]*caption[^"]*)"'
            ]
            
            for pattern in transcript_patterns:
                url_matches = re.findall(pattern, html)
                for url in url_matches:
                    clean_url = url.replace('\\u0026', '&').replace('\\/', '/').replace('\\/','/')
                    caption_text = self._download_caption_file(clean_url)
                    if caption_text and len(caption_text.strip()) > 100:
                        return caption_text
            
            return None
            
        except Exception as e:
            print(f"Error extracting caption data: {e}")
            return None

    def _download_caption_file(self, url: str) -> Optional[str]:
        """Download and parse caption file from URL"""
        try:
            # Decode URL if needed
            if '\\u' in url:
                url = url.encode().decode('unicode_escape')
            
            response = self.session.get(url, timeout=10)
            if response.status_code == 200:
                content = response.text
                
                # Parse different caption formats
                if '<text' in content:  # XML format
                    return self._parse_xml_captions(content)
                elif '"text"' in content:  # JSON format
                    return self._parse_json_captions(content)
                else:  # Plain text
                    return self._clean_text(content)
            
        except Exception as e:
            print(f"Error downloading caption file: {e}")
        
        return None

    def _parse_xml_captions(self, xml_content: str) -> str:
        """Parse XML caption format (YouTube's timedtext format)"""
        # Extract text from <text> tags, handling both simple and complex formats
        text_patterns = [
            r'<text[^>]*>([^<]+)</text>',
            r'<text[^>]*><!\[CDATA\[([^\]]+)\]\]></text>',
            r'<text[^>]*>([^<]*(?:<[^/][^>]*>[^<]*</[^>]*>[^<]*)*)</text>'
        ]
        
        all_text = []
        for pattern in text_patterns:
            matches = re.findall(pattern, xml_content, re.DOTALL)
            for match in matches:
                cleaned = self._clean_text(match)
                if cleaned and len(cleaned) > 2:
                    all_text.append(cleaned)
        
        if all_text:
            return ' '.join(all_text)
        
        # Fallback: extract any text content
        simple_text = re.sub(r'<[^>]+>', ' ', xml_content)
        return self._clean_text(simple_text)

    def _parse_json_captions(self, json_content: str) -> str:
        """Parse JSON caption format"""
        try:
            import json
            data = json.loads(json_content)
            
            # Handle YouTube's JSON3 format
            if 'events' in data:
                text_parts = []
                for event in data['events']:
                    if 'segs' in event:
                        for seg in event['segs']:
                            if 'utf8' in seg:
                                text_parts.append(seg['utf8'])
                    elif 'dDurationMs' in event and 'segs' not in event:
                        # Sometimes text is directly in the event
                        if 'utf8' in event:
                            text_parts.append(event['utf8'])
                
                if text_parts:
                    return ' '.join([self._clean_text(text) for text in text_parts])
            
            # Handle other JSON formats
            if 'body' in data:
                text_parts = []
                for item in data.get('body', []):
                    if isinstance(item, dict) and 'content' in item:
                        text_parts.append(item['content'])
                if text_parts:
                    return ' '.join([self._clean_text(text) for text in text_parts])
                    
        except json.JSONDecodeError:
            pass
        
        # Fallback: regex extraction for any JSON-like text
        text_patterns = [
            r'"text"\s*:\s*"([^"]+)"',
            r'"utf8"\s*:\s*"([^"]+)"',
            r'"content"\s*:\s*"([^"]+)"'
        ]
        
        all_matches = []
        for pattern in text_patterns:
            matches = re.findall(pattern, json_content)
            all_matches.extend([self._clean_text(text) for text in matches])
        
        return ' '.join(all_matches)

    def _parse_vtt_captions(self, vtt_content: str) -> str:
        """Parse WebVTT caption format"""
        lines = vtt_content.split('\n')
        text_lines = []
        
        for line in lines:
            line = line.strip()
            # Skip VTT headers, timestamps, and empty lines
            if (not line or 
                line.startswith('WEBVTT') or 
                '-->' in line or 
                line.isdigit() or
                line.startswith('NOTE')):
                continue
            
            # Clean the text line
            cleaned = self._clean_text(line)
            if cleaned and len(cleaned) > 1:
                text_lines.append(cleaned)
        
        return ' '.join(text_lines)

    def _clean_text(self, text: str) -> str:
        """Clean and normalize text"""
        if not text:
            return ""
        
        # Decode HTML entities and Unicode escapes
        text = text.replace('\\n', ' ').replace('\\r', ' ')
        text = text.replace('\\"', '"').replace("\\'", "'")
        
        # Remove HTML tags
        text = re.sub(r'<[^>]+>', '', text)
        
        # Clean up whitespace
        text = re.sub(r'\s+', ' ', text)
        
        return text.strip()

================
File: attached_assets/Pasted-Create-a-complete-Vite-React-TypeScript-Python-FastAPI-Tailwind-CSS-application-structured-as-follo-1748392447738.txt
================
Create a complete Vite/React/TypeScript/Python/FastAPI/Tailwind CSS application, structured as follows, emphasizing a modern, sleek aesthetic with smooth animations and a hip, contemporary feel:

**EXTREME EMPHASIS:** The AI coder **MUST, WITHOUT EXCEPTION, CODE THE FULL BACKEND SERVER WITH ALL ROUTES**. The YouTube transcript extraction functionality **MUST INCLUDE ALL THE FOLLOWING OPTIONS, FULLY IMPLEMENTED:**

### Transcript Extraction Methods

* **ðŸ“ Caption-Based**

  * Fast API extraction
  * May be blocked

* **ðŸŒ Web Scraping**

  * Bypasses all blocks
  * Always works
  * Most reliable

* **ðŸŽ¤ Audio-Based**

  * Speech recognition
  * No captions needed
  * Takes 2-5 minutes

**Frontend must allow users to clearly select extraction method:**

* Caption-Based (Fast)
* Web Scraping (Bypasses Blocks)
* Audio-Based (No Captions Needed)

---

### 1. Project Architecture

The application must have a clear **client-server architecture**:

* **Frontend:** Built with **Vite**, **React**, **TypeScript**, and **Tailwind CSS**.
* **Backend:** Built using **FastAPI** with Python, providing a RESTful API.

### 2. Directory Structure

```
/ (Root)
â”œâ”€â”€ .gitignore
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â”œâ”€â”€ tailwind.config.js
â”‚   â”œâ”€â”€ postcss.config.js
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ components/
â”‚       â”œâ”€â”€ pages/ (AddEpisode, Browse, Search, Admin)
â”‚       â”œâ”€â”€ api/
â”‚       â”œâ”€â”€ hooks/
â”‚       â”œâ”€â”€ store/ (or context/)
â”‚       â”œâ”€â”€ styles/
â”‚       â”œâ”€â”€ types/
â”‚       â”œâ”€â”€ App.tsx
â”‚       â””â”€â”€ main.tsx
â””â”€â”€ backend/
    â”œâ”€â”€ main.py
    â”œâ”€â”€ .env
    â”œâ”€â”€ core/ (database.py, youtube_handler.py, transcript_processor.py, caption_scraper.py)
    â”œâ”€â”€ routers/ (episodes.py, search.py, admin.py)
    â”œâ”€â”€ models/
    â””â”€â”€ dependencies.py
```

### 3. Frontend Requirements (React/TypeScript/Tailwind CSS)

* **Components**: Design modern, visually appealing, reusable components with sleek styling, subtle shadows, rounded corners, and interactive hover effects.
* **Routing**: Implement smooth page transitions and animations using libraries like `Framer Motion` or `react-spring`.
* **API Interaction**: Use `fetch` or `axios`, optionally combined with React Query for efficient and dynamic data fetching.
* **State Management**: Utilize React hooks, Context API, or Redux Toolkit for robust and responsive state handling.
* **Transcript Highlighting**: Implement sophisticated search highlighting logic in TypeScript with smooth animations and intuitive visual cues using Tailwind.
* **Form Handling**: Provide dynamic form experiences with validation animations and interactive feedback.

### 4. Backend Requirements (Python/FastAPI)

* **Endpoints**:

  * `POST /api/episodes`: Process single episodes.
  * `POST /api/batch-process`: Batch episode processing.
  * `GET /api/episodes`: Fetch all episodes.
  * `GET /api/episodes/{video_id}`: Fetch single episode.
  * `DELETE /api/episodes/{id}`: Delete episode.
  * `POST /api/search`: Perform searches.
  * `PUT /api/episodes/{id}/transcript`: Update transcripts.
  * `POST /api/enrich`: Generate summaries/topics.
  * `GET /api/stats`: Database statistics.
  * `GET /api/export/{format}`: Export data.
  * `POST /api/auth/login`: Admin login.
  * `POST /api/admin/users`: Manage admin users.
  * `POST /api/admin/change_password`: Password management.
* **Authentication**: Implement secure, user-friendly token-based authentication.
* **Long Processes**: Use polling or Server-Sent Events (SSE) for providing dynamic, real-time status updates.
* **Data Validation**: Use Pydantic for seamless data serialization/validation.
* **Error Handling**: Offer clear, friendly error messages with HTTP status codes.

### 5. Styling and UI (Tailwind CSS)

* Utilize Tailwind utility classes extensively for quick, consistent, and responsive design.
* Incorporate modern UI trends like glassmorphism, micro-animations, and interactive feedback to elevate the user experience.
* Customize Tailwind configuration to establish a cohesive, appealing theme throughout.

Ensure the application replicates the functionality and UX of the current Streamlit app while significantly enhancing the UI/UX with contemporary design principles, animations, and interactivity.

================
File: attached_assets/transcript_processor.py
================
import os
import re
from typing import Optional, Dict, Union, List
from openai import OpenAI

class TranscriptProcessor:
    def __init__(self, api_key=None):
        """Initialize transcript processor with OpenAI client"""
        # Use provided API key or fall back to environment variable
        if api_key:
            self.client = OpenAI(api_key=api_key)
        else:
            api_key = os.getenv("OPENAI_API_KEY")
            if not api_key:
                print("Warning: No OpenAI API key provided or found in environment variables.")
                print("AI-powered features will not work correctly.")
            self.client = OpenAI(api_key=api_key)
    
    def enhance_transcript(self, raw_transcript: str) -> str:
        """
        Enhance raw transcript using OpenAI API
        Clean up grammar, punctuation, and improve readability
        """
        if not raw_transcript or not raw_transcript.strip():
            raise ValueError("Raw transcript is empty or invalid")
        
        # Split long transcripts into chunks to avoid token limits
        chunks = self._split_transcript(raw_transcript)
        enhanced_chunks = []
        
        for chunk in chunks:
            try:
                enhanced_chunk = self._process_chunk(chunk)
                enhanced_chunks.append(enhanced_chunk)
            except Exception as e:
                # If processing fails, use the original chunk
                print(f"Warning: Failed to enhance chunk: {str(e)}")
                enhanced_chunks.append(chunk)
        
        return "\n\n".join(enhanced_chunks)
    
    def _split_transcript(self, transcript: str, max_chunk_size: int = 3000) -> list:
        """Split transcript into manageable chunks for API processing"""
        # Clean up the transcript first
        transcript = self._basic_cleanup(transcript)
        
        # Split by sentences if possible, otherwise by words
        sentences = re.split(r'(?<=[.!?])\s+', transcript)
        
        chunks = []
        current_chunk = ""
        
        for sentence in sentences:
            if len(current_chunk) + len(sentence) + 1 <= max_chunk_size:
                current_chunk += sentence + " "
            else:
                if current_chunk.strip():
                    chunks.append(current_chunk.strip())
                current_chunk = sentence + " "
        
        if current_chunk.strip():
            chunks.append(current_chunk.strip())
        
        return chunks if chunks else [transcript]
    
    def _basic_cleanup(self, text: str) -> str:
        """Basic cleanup of transcript text"""
        # Remove excessive whitespace
        text = re.sub(r'\s+', ' ', text)
        
        # Remove timestamp markers if present
        text = re.sub(r'\[\d+:\d+:\d+\]', '', text)
        text = re.sub(r'\d+:\d+', '', text)
        
        # Clean up common transcript artifacts
        text = re.sub(r'\[Music\]', '', text, flags=re.IGNORECASE)
        text = re.sub(r'\[Applause\]', '', text, flags=re.IGNORECASE)
        text = re.sub(r'\[Laughter\]', '', text, flags=re.IGNORECASE)
        text = re.sub(r'\[Inaudible\]', '', text, flags=re.IGNORECASE)
        
        return text.strip()
    
    def _process_chunk(self, chunk: str) -> str:
        """Process a single chunk using OpenAI API"""
        prompt = """You are an expert transcript editor. Please clean up the following podcast transcript by:

1. Correcting spelling, grammar, and punctuation errors
2. Adding proper paragraph breaks for readability
3. Maintaining the speaker's natural speaking style and voice
4. Preserving all original content and meaning
5. Removing any obvious transcription artifacts or repeated words
6. Ensuring proper capitalization

Important: Do not add, remove, or change the actual content or meaning. Only improve the technical quality of the text.

Transcript to clean:"""

        try:
            # the newest OpenAI model is "gpt-4o" which was released May 13, 2024.
            # do not change this unless explicitly requested by the user
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "system",
                        "content": "You are a professional transcript editor specializing in podcast content. Your job is to clean up transcripts while preserving the original meaning and speaker's voice."
                    },
                    {
                        "role": "user",
                        "content": f"{prompt}\n\n{chunk}"
                    }
                ],
                temperature=0.1,  # Low temperature for consistent editing
                max_tokens=4000
            )
            
            enhanced_text = response.choices[0].message.content.strip()
            
            # Basic validation - ensure we got meaningful output
            if len(enhanced_text) < len(chunk) * 0.5:
                raise ValueError("Enhanced text is suspiciously short")
            
            return enhanced_text
            
        except Exception as e:
            raise Exception(f"OpenAI API error: {str(e)}")
    
    def extract_key_topics(self, transcript: str) -> Dict:
        """Extract key topics and themes from the transcript"""
        if not transcript or len(transcript.strip()) < 100:
            return {
                "topics": [],
                "key_points": [],
                "summary": "Transcript too short to summarize"
            }
        
        prompt = """Analyze the following podcast transcript and extract the main topics, themes, and key points discussed. 
        
Return your analysis as a JSON object with this structure:
{
    "topics": ["topic1", "topic2", "topic3"],
    "key_points": ["point1", "point2", "point3"],
    "summary": "Brief summary of the episode"
}

Focus on substantial topics and avoid minor tangents."""

        try:
            # the newest OpenAI model is "gpt-4o" which was released May 13, 2024.
            # do not change this unless explicitly requested by the user
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "system",
                        "content": "You are an expert at analyzing podcast content and extracting key themes and topics."
                    },
                    {
                        "role": "user", 
                        "content": f"{prompt}\n\nTranscript:\n{transcript[:4000]}"  # Limit input length
                    }
                ],
                response_format={"type": "json_object"},
                temperature=0.3
            )
            
            import json
            try:
                result = json.loads(response.choices[0].message.content)
                # Validate the result has the expected structure
                if not isinstance(result, dict):
                    raise ValueError("Result is not a dictionary")
                
                # Ensure all expected keys exist
                result.setdefault("topics", [])
                result.setdefault("key_points", [])
                result.setdefault("summary", "No summary generated")
                
                return result
            except json.JSONDecodeError as e:
                print(f"Warning: Failed to parse JSON response: {str(e)}")
                return {
                    "topics": [],
                    "key_points": [],
                    "summary": "Failed to parse topic extraction results"
                }
            
        except Exception as e:
            print(f"Warning: Failed to extract topics: {str(e)}")
            return {
                "topics": [],
                "key_points": [],
                "summary": "Topic extraction failed"
            }
    
    def generate_summary(self, transcript: str, max_length: int = 500) -> str:
        """Generate a concise summary of the transcript"""
        if not transcript or len(transcript.strip()) < 100:
            return "Transcript too short to summarize"
        
        prompt = f"""Please provide a concise summary of this podcast transcript in approximately {max_length} characters. 
        Focus on the main points, key discussions, and any notable insights shared.
        
        Transcript:"""
        
        try:
            # the newest OpenAI model is "gpt-4o" which was released May 13, 2024.
            # do not change this unless explicitly requested by the user
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "system",
                        "content": "You are an expert at creating concise, informative summaries of podcast content."
                    },
                    {
                        "role": "user",
                        "content": f"{prompt}\n\n{transcript[:4000]}"
                    }
                ],
                temperature=0.2,
                max_tokens=200
            )
            
            return response.choices[0].message.content.strip()
            
        except Exception as e:
            return f"Summary generation failed: {str(e)}"

================
File: attached_assets/youtube_handler.py
================
import re
import os
import tempfile
from datetime import datetime
from typing import Optional, Dict
from youtube_transcript_api import YouTubeTranscriptApi
import requests
import yt_dlp
import whisper
from pydub import AudioSegment
from googleapiclient.discovery import build
from caption_scraper import CaptionScraper

class YouTubeHandler:
    def __init__(self):
        """Initialize YouTube handler"""
        self.whisper_model = None  # Load model only when needed to save memory
        self.youtube_api = None
        self.caption_scraper = CaptionScraper()
        self._init_youtube_api()
    
    def _init_youtube_api(self):
        """Initialize YouTube Data API with authentication"""
        try:
            api_key = os.getenv('YOUTUBE_API_KEY')
            if api_key:
                self.youtube_api = build('youtube', 'v3', developerKey=api_key)
                print("YouTube API initialized successfully with authentication")
            else:
                print("YouTube API key not found, using fallback methods")
        except Exception as e:
            print(f"Failed to initialize YouTube API: {e}")
    
    def _get_video_metadata_with_api(self, video_id: str) -> Dict:
        """Get video metadata using authenticated YouTube Data API"""
        try:
            if self.youtube_api:
                request = self.youtube_api.videos().list(
                    part="snippet,contentDetails",
                    id=video_id
                )
                response = request.execute()
                
                if response['items']:
                    video = response['items'][0]
                    snippet = video['snippet']
                    
                    # Parse duration if available
                    duration = None
                    if 'contentDetails' in video and 'duration' in video['contentDetails']:
                        duration_str = video['contentDetails']['duration']
                        # Convert ISO 8601 duration to seconds (PT1H2M3S format)
                        match = re.match(r'PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?', duration_str)
                        if match:
                            hours, minutes, seconds = match.groups()
                            duration = (int(hours or 0) * 3600 + 
                                      int(minutes or 0) * 60 + 
                                      int(seconds or 0))
                    
                    # Parse upload date
                    upload_date = snippet.get('publishedAt', '')
                    try:
                        date_obj = datetime.fromisoformat(upload_date.replace('Z', '+00:00'))
                        formatted_date = date_obj.strftime('%Y-%m-%d')
                    except:
                        formatted_date = datetime.now().strftime('%Y-%m-%d')
                    
                    return {
                        'title': self._clean_title(snippet.get('title', f'Video {video_id}')),
                        'date': formatted_date,
                        'channel': snippet.get('channelTitle', 'Unknown Channel'),
                        'duration': duration
                    }
        except Exception as e:
            print(f"API metadata extraction failed: {e}")
        
        # Fallback metadata
        return {
            'title': f"Coffee with Scott Adams - Episode {video_id}",
            'date': datetime.now().strftime('%Y-%m-%d'),
            'channel': "Scott Adams",
            'duration': None
        }
    
    def extract_video_id(self, url: str) -> Optional[str]:
        """Extract video ID from various YouTube URL formats"""
        patterns = [
            r'(?:https?://)?(?:www\.)?youtube\.com/watch\?v=([a-zA-Z0-9_-]+)',
            r'(?:https?://)?(?:www\.)?youtu\.be/([a-zA-Z0-9_-]+)',
            r'(?:https?://)?(?:www\.)?youtube\.com/embed/([a-zA-Z0-9_-]+)',
            r'(?:https?://)?(?:www\.)?youtube\.com/v/([a-zA-Z0-9_-]+)'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                return match.group(1)
        return None
    
    def extract_transcript(self, video_id: str) -> Optional[Dict]:
        """
        Extract transcript and metadata from YouTube video
        Returns dict with transcript, title, date, and other metadata
        """
        try:
            # Get transcript using youtube-transcript-api
            transcript_list = YouTubeTranscriptApi.get_transcript(
                video_id,
                languages=['en', 'en-US', 'en-GB']  # Prefer English transcripts
            )
            
            # Combine transcript segments into full text
            full_transcript = self._combine_transcript_segments(transcript_list)
            
            if not full_transcript or len(full_transcript.strip()) < 50:
                raise ValueError("Transcript is too short or empty")
            
            # Get video metadata
            metadata = self._get_video_metadata(video_id)
            
            return {
                'transcript': full_transcript,
                'title': metadata.get('title', f'Video {video_id}'),
                'date': metadata.get('date', datetime.now().strftime('%Y-%m-%d')),
                'duration': metadata.get('duration'),
                'channel': metadata.get('channel'),
                'video_id': video_id
            }
            
        except Exception as e:
            error_msg = str(e)
            print(f"Error extracting transcript for video {video_id}: {error_msg}")
            
            # Check for specific YouTube blocking errors and try web scraping fallback
            if "IP belonging to a cloud provider" in error_msg or "blocked" in error_msg.lower():
                print("API blocked, trying web scraping method...")
                try:
                    return self.caption_scraper.extract_captions_from_page(video_id)
                except Exception as scrape_error:
                    print(f"Web scraping also failed: {scrape_error}")
                    raise Exception("Both API and web scraping methods failed. Try the Audio-Based extraction method.")
            else:
                raise Exception(f"Caption extraction failed: {error_msg}")
            
            return None

    def extract_transcript_from_audio(self, video_id: str, progress_callback=None, quality_level="Fast") -> Optional[Dict]:
        """
        Extract transcript from YouTube video audio using Whisper AI
        This method downloads audio and uses speech recognition for transcription
        """
        temp_dir = None
        try:
            # Create temporary directory for audio files
            temp_dir = tempfile.mkdtemp()
            audio_path = os.path.join(temp_dir, f"{video_id}.wav")
            
            if progress_callback:
                progress_callback("Downloading audio from YouTube...")
            
            # Download audio using yt-dlp with optimized settings and bot bypass
            ydl_opts = {
                'format': 'worstaudio/worst',  # Use lower quality for faster processing
                'outtmpl': os.path.join(temp_dir, f"{video_id}.%(ext)s"),
                'extractaudio': True,
                'audioformat': 'mp3',  # MP3 is smaller and faster to process
                'audioquality': '9',   # Lower quality for speed
                'quiet': True,
                'no_warnings': True,
                # Add headers to appear more like a regular browser
                'http_headers': {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                    'Accept-Language': 'en-us,en;q=0.5',
                    'Accept-Encoding': 'gzip,deflate',
                    'Accept-Charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',
                    'Keep-Alive': '300',
                    'Connection': 'keep-alive',
                },
                # Try to bypass age restrictions
                'age_limit': None,
                'skip_download': False,
            }
            
            url = f"https://www.youtube.com/watch?v={video_id}"
            
            # Get enhanced metadata using API if available
            api_metadata = self._get_video_metadata_with_api(video_id)
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                # Extract video info first
                info = ydl.extract_info(url, download=False)
                
                # Use API metadata if available, fallback to yt-dlp
                title = api_metadata.get('title') or info.get('title', f'Video {video_id}')
                duration = api_metadata.get('duration') or info.get('duration')
                upload_date = api_metadata.get('date') or info.get('upload_date')
                channel = api_metadata.get('channel') or info.get('uploader')
                
                # Format date
                if upload_date:
                    try:
                        date_obj = datetime.strptime(upload_date, '%Y%m%d')
                        formatted_date = date_obj.strftime('%Y-%m-%d')
                    except:
                        formatted_date = datetime.now().strftime('%Y-%m-%d')
                else:
                    formatted_date = datetime.now().strftime('%Y-%m-%d')
                
                # Download audio
                ydl.download([url])
            
            # Find the downloaded audio file
            downloaded_files = [f for f in os.listdir(temp_dir) if f.startswith(video_id)]
            if not downloaded_files:
                raise Exception("Failed to download audio file")
            
            audio_file = os.path.join(temp_dir, downloaded_files[0])
            
            if progress_callback:
                progress_callback("Converting audio format...")
            
            # Convert and compress audio for faster processing
            audio = AudioSegment.from_file(audio_file)
            
            # Compress audio: reduce sample rate and convert to mono for speed
            audio = audio.set_frame_rate(16000)  # Lower sample rate for faster processing
            audio = audio.set_channels(1)       # Convert to mono
            
            # Export as WAV for Whisper
            audio_path = os.path.join(temp_dir, f"{video_id}_compressed.wav")
            audio.export(audio_path, format="wav")
            
            if progress_callback:
                progress_callback("Loading speech recognition model...")
            
            # Load Whisper model based on quality level
            model_map = {
                "Fast": "tiny",
                "Balanced": "base", 
                "Best Quality": "small"
            }
            
            model_size = model_map.get(quality_level, "tiny")
            
            if self.whisper_model is None or getattr(self, '_current_model_size', None) != model_size:
                if progress_callback:
                    progress_callback(f"Loading {model_size} speech recognition model...")
                self.whisper_model = whisper.load_model(model_size)
                self._current_model_size = model_size
            
            if progress_callback:
                progress_callback("Transcribing audio... This may take a few minutes.")
            
            # Transcribe audio with optimized settings
            result = self.whisper_model.transcribe(
                audio_path,
                fp16=False,  # Use FP32 for CPU compatibility
                verbose=False,  # Reduce output
                language="en",  # Assume English for Scott Adams podcasts
                temperature=0.0,  # More consistent results
                compression_ratio_threshold=2.4,  # Prevent cutting off content
                logprob_threshold=-1.0,  # Include more uncertain words
                no_speech_threshold=0.6  # Better handling of quiet sections
            )
            transcript_text = result["text"]
            
            if not transcript_text or len(transcript_text.strip()) < 50:
                raise ValueError("Generated transcript is too short or empty")
            
            # Clean up the transcript
            cleaned_transcript = self._clean_whisper_transcript(transcript_text)
            
            return {
                'transcript': cleaned_transcript,
                'title': self._clean_title(title),
                'date': formatted_date,
                'duration': duration,
                'channel': channel,
                'video_id': video_id,
                'extraction_method': 'audio'  # Mark this as audio-extracted
            }
            
        except Exception as e:
            error_msg = str(e)
            print(f"Error extracting transcript from audio for video {video_id}: {error_msg}")
            
            # Check for specific YouTube blocking errors
            if "Sign in to confirm you're not a bot" in error_msg:
                raise Exception("YouTube is blocking audio downloads from this environment. This is common on cloud platforms. Try using the Caption-Based extraction method instead, which often works better.")
            elif "blocked" in error_msg.lower() or "forbidden" in error_msg.lower():
                raise Exception("YouTube has blocked access to this video's audio. Try using the Caption-Based extraction method instead.")
            else:
                raise Exception(f"Audio extraction failed: {error_msg}")
            
            return None
        finally:
            # Clean up temporary files
            if temp_dir and os.path.exists(temp_dir):
                import shutil
                try:
                    shutil.rmtree(temp_dir)
                except:
                    pass  # Best effort cleanup
    
    def _combine_transcript_segments(self, transcript_list: list) -> str:
        """Combine transcript segments into readable text"""
        if not transcript_list:
            return ""
        
        # Extract text from each segment
        text_segments = []
        for segment in transcript_list:
            text = segment.get('text', '').strip()
            if text:
                # Clean up common transcript artifacts
                text = self._clean_transcript_text(text)
                text_segments.append(text)
        
        # Join segments with spaces
        full_text = ' '.join(text_segments)
        
        # Basic formatting cleanup
        full_text = re.sub(r'\s+', ' ', full_text)  # Multiple spaces to single space
        full_text = re.sub(r'([.!?])\s*([A-Z])', r'\1 \2', full_text)  # Ensure space after punctuation
        
        return full_text.strip()
    
    def _clean_transcript_text(self, text: str) -> str:
        """Clean individual transcript text segments"""
        # Remove common transcript artifacts
        text = re.sub(r'\[.*?\]', '', text)  # Remove bracketed content
        text = re.sub(r'\(.*?\)', '', text)  # Remove parenthetical content
        
        # Fix common transcription issues
        text = re.sub(r'\buh\b', '', text, flags=re.IGNORECASE)
        text = re.sub(r'\bum\b', '', text, flags=re.IGNORECASE)
        text = re.sub(r'\ber\b', '', text, flags=re.IGNORECASE)
        
        # Clean up whitespace
        text = re.sub(r'\s+', ' ', text)
        
        return text.strip()
    
    def _get_video_metadata(self, video_id: str) -> Dict:
        """
        Get video metadata from YouTube
        This is a simplified approach - in production you might want to use YouTube Data API
        """
        try:
            # Try to extract basic info from YouTube page
            url = f"https://www.youtube.com/watch?v={video_id}"
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            
            response = requests.get(url, headers=headers, timeout=10)
            if response.status_code == 200:
                html = response.text
                
                # Extract title
                title_match = re.search(r'"title":"([^"]+)"', html)
                title = title_match.group(1) if title_match else f"Video {video_id}"
                
                # Clean up title (decode unicode escapes)
                title = title.encode().decode('unicode_escape')
                
                # Extract upload date (simplified approach)
                date_match = re.search(r'"uploadDate":"([^"]+)"', html)
                if date_match:
                    upload_date = date_match.group(1)
                    try:
                        # Parse ISO date format
                        date_obj = datetime.fromisoformat(upload_date.replace('Z', '+00:00'))
                        date = date_obj.strftime('%Y-%m-%d')
                    except:
                        date = datetime.now().strftime('%Y-%m-%d')
                else:
                    date = datetime.now().strftime('%Y-%m-%d')
                
                # Extract channel name
                channel_match = re.search(r'"author":"([^"]+)"', html)
                channel = channel_match.group(1) if channel_match else "Unknown Channel"
                
                return {
                    'title': self._clean_title(title),
                    'date': date,
                    'channel': channel,
                    'duration': None  # Would need YouTube Data API for accurate duration
                }
                
        except Exception as e:
            print(f"Warning: Could not extract metadata for video {video_id}: {str(e)}")
        
        # Fallback metadata
        return {
            'title': f"Coffee with Scott Adams - Episode {video_id}",
            'date': datetime.now().strftime('%Y-%m-%d'),
            'channel': "Scott Adams",
            'duration': None
        }
    
    def _clean_title(self, title: str) -> str:
        """Clean up video title"""
        # Remove common unwanted characters
        title = re.sub(r'[^\w\s\-\:\.\,\!\?]', '', title)
        
        # Limit length
        if len(title) > 200:
            title = title[:200] + "..."
        
        return title.strip()
    
    def validate_coffee_with_scott_adams(self, video_id: str) -> bool:
        """
        Validate if the video is likely a Coffee with Scott Adams episode
        This is a basic check - you might want to enhance this
        """
        try:
            metadata = self._get_video_metadata(video_id)
            title = metadata.get('title', '').lower()
            channel = metadata.get('channel', '').lower()
            
            # Check for Scott Adams related keywords
            scott_keywords = ['scott adams', 'coffee with scott', 'real coffee']
            
            return any(keyword in title or keyword in channel for keyword in scott_keywords)
            
        except Exception as e:
            print(f"Warning: Could not validate video {video_id}: {str(e)}")
            return True  # Default to allowing the video
    
    def get_available_transcript_languages(self, video_id: str) -> list:
        """Get list of available transcript languages for a video"""
        try:
            transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)
            languages = []
            
            for transcript in transcript_list:
                languages.append({
                    'language': transcript.language,
                    'language_code': transcript.language_code,
                    'is_generated': transcript.is_generated,
                    'is_translatable': transcript.is_translatable
                })
            
            return languages
            
        except Exception as e:
            print(f"Error getting transcript languages for {video_id}: {str(e)}")
            return []

    def _clean_whisper_transcript(self, text: str) -> str:
        """Clean Whisper-generated transcript text"""
        # Remove excessive whitespace
        text = re.sub(r'\s+', ' ', text)
        
        # Whisper sometimes adds timestamps or markers, remove them
        text = re.sub(r'\[\d+:\d+:\d+\.\d+\s*-->\s*\d+:\d+:\d+\.\d+\]', '', text)
        text = re.sub(r'\d+:\d+\.\d+', '', text)
        
        # Clean up common speech recognition artifacts
        text = re.sub(r'\[MUSIC\]', '', text, flags=re.IGNORECASE)
        text = re.sub(r'\[APPLAUSE\]', '', text, flags=re.IGNORECASE)
        text = re.sub(r'\[LAUGHTER\]', '', text, flags=re.IGNORECASE)
        text = re.sub(r'\[INAUDIBLE\]', '', text, flags=re.IGNORECASE)
        text = re.sub(r'\[UNCLEAR\]', '', text, flags=re.IGNORECASE)
        
        # Remove common filler words that speech recognition might capture
        text = re.sub(r'\b(uh|um|er|ah)\b', '', text, flags=re.IGNORECASE)
        
        # Ensure proper sentence spacing
        text = re.sub(r'([.!?])\s*([A-Z])', r'\1 \2', text)
        
        # Remove multiple spaces
        text = re.sub(r'\s+', ' ', text)
        
        return text.strip()

    def extract_transcript_with_api(self, video_id: str) -> Optional[Dict]:
        """
        Extract transcript using authenticated YouTube Data API
        This bypasses IP blocking by using official API access
        """
        try:
            if not self.youtube_api:
                raise Exception("YouTube API not initialized. API key required.")
            
            # Get video metadata first
            metadata = self._get_video_metadata_with_api(video_id)
            
            # Get list of available captions
            captions_request = self.youtube_api.captions().list(
                part="snippet",
                videoId=video_id
            )
            captions_response = captions_request.execute()
            
            if not captions_response.get('items'):
                raise Exception("No captions available for this video")
            
            # Find English captions (prefer manually created over auto-generated)
            english_caption = None
            for caption in captions_response['items']:
                lang = caption['snippet']['language']
                track_kind = caption['snippet'].get('trackKind', 'standard')
                
                if lang in ['en', 'en-US', 'en-GB']:
                    if track_kind == 'standard':  # Manually created captions
                        english_caption = caption
                        break
                    elif english_caption is None:  # Auto-generated as fallback
                        english_caption = caption
            
            if not english_caption:
                raise Exception("No English captions found for this video")
            
            # Download the caption content
            caption_id = english_caption['id']
            download_request = self.youtube_api.captions().download(
                id=caption_id,
                tfmt='srt'  # SubRip format
            )
            
            # Execute the download
            caption_content = download_request.execute()
            
            if isinstance(caption_content, bytes):
                caption_content = caption_content.decode('utf-8')
            
            # Parse SRT content to extract text
            transcript_text = self._parse_srt_content(caption_content)
            
            if not transcript_text or len(transcript_text.strip()) < 50:
                raise Exception("Generated transcript is too short or empty")
            
            return {
                'transcript': transcript_text,
                'title': metadata.get('title', f'Video {video_id}'),
                'date': metadata.get('date', datetime.now().strftime('%Y-%m-%d')),
                'duration': metadata.get('duration'),
                'channel': metadata.get('channel'),
                'video_id': video_id,
                'extraction_method': 'api_captions'
            }
            
        except Exception as e:
            print(f"Error extracting transcript with API for video {video_id}: {str(e)}")
            raise Exception(f"API caption extraction failed: {str(e)}")
    
    def _parse_srt_content(self, srt_content: str) -> str:
        """Parse SRT subtitle content to extract plain text"""
        import re
        
        lines = srt_content.split('\n')
        text_lines = []
        
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            
            # Skip sequence numbers and timestamp lines
            if line.isdigit() or '-->' in line or not line:
                i += 1
                continue
            
            # Clean subtitle text
            cleaned_line = re.sub(r'<[^>]+>', '', line)  # Remove HTML tags
            cleaned_line = re.sub(r'\[.*?\]', '', cleaned_line)  # Remove bracketed content
            cleaned_line = cleaned_line.strip()
            
            if cleaned_line:
                text_lines.append(cleaned_line)
            
            i += 1
        
        # Join and clean up text
        full_text = ' '.join(text_lines)
        full_text = re.sub(r'\s+', ' ', full_text)
        full_text = re.sub(r'([.!?])\s*([A-Z])', r'\1 \2', full_text)
        
        return full_text.strip()

    def extract_transcript_web_scraping(self, video_id: str) -> Optional[Dict]:
        """
        Extract transcript using web scraping - bypasses all API restrictions
        This method directly scrapes YouTube's web page for caption data
        """
        try:
            return self.caption_scraper.extract_captions_from_page(video_id)
        except Exception as e:
            print(f"Error with web scraping extraction for video {video_id}: {str(e)}")
            raise Exception(f"Web scraping extraction failed: {str(e)}")

================
File: client/advanced-test.html
================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Keyword Highlight Test</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
      line-height: 1.6;
    }
    .keyword-highlight {
      padding: 2px 4px;
      border-radius: 4px;
      font-weight: 500;
      cursor: help;
      transition: all 0.2s ease;
    }
    .keyword-highlight:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .bg-yellow-200 {
      background-color: #fef9c3;
      color: #713f12;
    }
    .bg-blue-200 {
      background-color: #bfdbfe;
      color: #1e3a8a;
    }
    .bg-green-200 {
      background-color: #bbf7d0;
      color: #14532d;
    }
    .bg-purple-200 {
      background-color: #e9d5ff;
      color: #581c87;
    }
    .bg-red-200 {
      background-color: #fecaca;
      color: #7f1d1d;
    }
    .transcript {
      white-space: pre-wrap;
      background-color: #f9fafb;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    }
    .test-case {
      margin-bottom: 30px;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 20px;
    }
    h2 {
      font-size: 1.2rem;
      margin-top: 1.5rem;
    }
  </style>
</head>
<body>
  <h1>Advanced Keyword Highlighting Test</h1>
  
  <div class="test-case">
    <h2>Test Case 1: Single Keyword</h2>
    <div class="transcript">
      This is a sample text with <span class="keyword-highlight bg-purple-200" title="concept (95% confidence)">decaf coffee</span> as a keyword.
    </div>
  </div>
  
  <div class="test-case">
    <h2>Test Case 2: Multiple Keywords with Different Categories</h2>
    <div class="transcript">
      <span class="keyword-highlight bg-green-200" title="name (90% confidence)">John Smith</span> wrote about <span class="keyword-highlight bg-purple-200" title="concept (85% confidence)">artificial intelligence</span> and its impact on <span class="keyword-highlight bg-red-200" title="action (75% confidence)">coding</span>. He used many <span class="keyword-highlight bg-blue-200" title="technical (88% confidence)">neural networks</span> in his research.
    </div>
  </div>
  
  <div class="test-case">
    <h2>Test Case 3: Overlapping Keywords</h2>
    <div class="transcript">
      The phrase <span class="keyword-highlight bg-purple-200" title="concept (80% confidence)">machine learning algorithms</span> contains the word <span class="keyword-highlight bg-blue-200" title="technical (90% confidence)">algorithms</span> which is a technical term.
    </div>
  </div>
  
  <div class="test-case">
    <h2>Test Case 4: Long Transcript Paragraph</h2>
    <div class="transcript">
      Coffee and <span class="keyword-highlight bg-purple-200" title="concept (95% confidence)">decaf coffee</span> can both affect how you feel. <span class="keyword-highlight bg-green-200" title="name (90% confidence)">Pavlov</span> was training his dog and that relates to <span class="keyword-highlight bg-purple-200" title="concept (87% confidence)">habituation</span>. The effect of <span class="keyword-highlight bg-red-200" title="action (85% confidence)">drinking</span> coffee is influenced by many factors.
    </div>
  </div>
  
  <script>
    // This is just a static test page, no JavaScript needed
  </script>
</body>
</html>

================
File: client/index.html
================
<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
    <title>TranscriptAI - YouTube Transcript Extraction Platform</title>
    <meta name="description" content="Advanced AI-powered YouTube transcript extraction with multiple methods. Fast, reliable, and always works." />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <!-- This is a replit script which adds a banner on the top of the page when opened in development mode outside the replit environment -->
    <script type="text/javascript" src="https://replit.com/public/js/replit-dev-banner.js"></script>
  </body>
</html>

================
File: client/src/App.tsx
================
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { NotificationProvider } from "@/lib/notification-context";
import { useEpisodeNotifications } from "@/hooks/use-episode-notifications";
import MainLayout from "@/components/layout/main-layout";
import Dashboard from "@/pages/dashboard";
import AddEpisode from "@/pages/add-episode";
import Episodes from "@/pages/episodes";
import Search from "@/pages/search";
import Admin from "@/pages/admin";
import AdminLogin from "@/pages/admin-login";
import NotFound from "@/pages/not-found";
import { BrowserRouter } from "react-router-dom";

// Component to initialize global hooks
function GlobalHooks() {
  useEpisodeNotifications();
  return null;
}

function Router() {
  return (
    <MainLayout>
      <Switch>
        <Route path="/" component={Dashboard} />
        <Route path="/add-episode" component={AddEpisode} />
        <Route path="/episodes" component={Episodes} />
        <Route path="/search" component={Search} />
        <Route path="/admin" component={Admin} />
        <Route path="/admin/login" component={AdminLogin} />
        <Route component={NotFound} />
      </Switch>
    </MainLayout>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>
        <TooltipProvider>
          <NotificationProvider>
            <GlobalHooks />
            <Toaster />
            <Router />
          </NotificationProvider>
        </TooltipProvider>
      </BrowserRouter>
    </QueryClientProvider>
  );
}

export default App;

================
File: client/src/components/admin/system-stats.tsx
================
import { motion } from "framer-motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { useSystemStats } from "@/hooks/use-episodes";
import { Activity, Cpu, HardDrive, Zap } from "lucide-react";

export default function SystemStats() {
  const { data: stats, isLoading } = useSystemStats();

  const systemMetrics = [
    {
      name: "CPU Usage",
      value: 42,
      icon: Cpu,
      color: "text-blue-400",
      bgColor: "bg-blue-500",
    },
    {
      name: "Memory",
      value: 67,
      icon: HardDrive,
      color: "text-purple-400",
      bgColor: "bg-purple-500",
    },
    {
      name: "Storage",
      value: 34,
      icon: HardDrive,
      color: "text-emerald-400",
      bgColor: "bg-emerald-500",
    },
    {
      name: "Network",
      value: 28,
      icon: Zap,
      color: "text-amber-400",
      bgColor: "bg-amber-500",
    },
  ];

  return (
    <Card className="glassmorphism border-white/10">
      <CardHeader>
        <CardTitle className="flex items-center">
          <Activity className="mr-2 h-5 w-5" />
          System Performance
        </CardTitle>
      </CardHeader>
      
      <CardContent className="space-y-6">
        {/* Performance Metrics */}
        <div className="grid grid-cols-2 gap-4">
          {systemMetrics.map((metric, index) => (
            <motion.div
              key={metric.name}
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              transition={{ delay: index * 0.1 }}
              className="bg-background/30 rounded-lg p-4"
            >
              <div className="flex items-center justify-between mb-2">
                <div className="flex items-center space-x-2">
                  <metric.icon className={`h-4 w-4 ${metric.color}`} />
                  <span className="text-sm text-muted-foreground">{metric.name}</span>
                </div>
                <span className={`text-sm font-semibold ${metric.color}`}>
                  {metric.value}%
                </span>
              </div>
              <Progress 
                value={metric.value} 
                className="h-2"
                // @ts-ignore - Progress component styling
                style={{
                  '--progress-background': `var(--${metric.bgColor.replace('bg-', '')})`,
                }}
              />
            </motion.div>
          ))}
        </div>

        {/* System Statistics */}
        <div className="space-y-4">
          <h4 className="font-semibold">System Statistics</h4>
          
          <div className="space-y-3">
            <div className="flex justify-between items-center">
              <span className="text-sm text-muted-foreground">Uptime</span>
              <span className="text-sm font-medium">15d 7h 32m</span>
            </div>
            
            <div className="flex justify-between items-center">
              <span className="text-sm text-muted-foreground">Active Connections</span>
              <span className="text-sm font-medium">247</span>
            </div>
            
            <div className="flex justify-between items-center">
              <span className="text-sm text-muted-foreground">Request Rate</span>
              <span className="text-sm font-medium">12.3/sec</span>
            </div>
            
            <div className="flex justify-between items-center">
              <span className="text-sm text-muted-foreground">Error Rate</span>
              <span className="text-sm font-medium text-emerald-400">0.02%</span>
            </div>
          </div>
        </div>

        {/* Processing Queue Stats */}
        {stats && (
          <div className="space-y-4 pt-4 border-t border-white/10">
            <h4 className="font-semibold">Processing Statistics</h4>
            
            <div className="space-y-3">
              <div className="flex justify-between items-center">
                <span className="text-sm text-muted-foreground">Total Episodes</span>
                <span className="text-sm font-medium">{stats.totalEpisodes}</span>
              </div>
              
              <div className="flex justify-between items-center">
                <span className="text-sm text-muted-foreground">Processing Queue</span>
                <span className="text-sm font-medium">{stats.processingQueue}</span>
              </div>
              
              <div className="flex justify-between items-center">
                <span className="text-sm text-muted-foreground">Success Rate</span>
                <span className="text-sm font-medium text-emerald-400">{stats.successRate}%</span>
              </div>
              
              <div className="flex justify-between items-center">
                <span className="text-sm text-muted-foreground">Daily Processed</span>
                <span className="text-sm font-medium">{stats.dailyProcessed}</span>
              </div>
            </div>
          </div>
        )}

        {/* Method Distribution */}
        {stats?.methodDistribution && (
          <div className="space-y-4 pt-4 border-t border-white/10">
            <h4 className="font-semibold">Method Distribution</h4>
            
            <div className="space-y-3">
              <div className="flex justify-between items-center">
                <span className="text-sm text-muted-foreground">Web Scraping</span>
                <span className="text-sm font-medium text-purple-400">
                  {stats.methodDistribution.scraping}
                </span>
              </div>
              
              <div className="flex justify-between items-center">
                <span className="text-sm text-muted-foreground">Caption-Based</span>
                <span className="text-sm font-medium text-blue-400">
                  {stats.methodDistribution.caption}
                </span>
              </div>
              
              <div className="flex justify-between items-center">
                <span className="text-sm text-muted-foreground">Audio-Based</span>
                <span className="text-sm font-medium text-emerald-400">
                  {stats.methodDistribution.audio}
                </span>
              </div>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}

================
File: client/src/components/admin/user-management.tsx
================
import { useState } from "react";
import { motion } from "framer-motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useUsers, useCreateUser, useDeleteUser } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { Users, Plus, Trash2, UserCheck } from "lucide-react";
import type { InsertUser } from "@shared/schema";

export default function UserManagement() {
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
  const [newUser, setNewUser] = useState<InsertUser>({
    username: "",
    email: "",
    password: "",
    role: "user",
  });

  const { data: users, isLoading } = useUsers();
  const createUserMutation = useCreateUser();
  const deleteUserMutation = useDeleteUser();
  const { toast } = useToast();

  const handleCreateUser = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!newUser.username || !newUser.email || !newUser.password) {
      toast({
        title: "Validation Error",
        description: "Please fill in all required fields",
        variant: "destructive",
      });
      return;
    }

    try {
      await createUserMutation.mutateAsync(newUser);
      setNewUser({ username: "", email: "", password: "", role: "user" });
      setIsCreateDialogOpen(false);
      toast({
        title: "User Created",
        description: "The user has been successfully created.",
      });
    } catch (error: any) {
      toast({
        title: "Error",
        description: error.message || "Failed to create user",
        variant: "destructive",
      });
    }
  };

  const handleDeleteUser = async (id: number, username: string) => {
    if (!confirm(`Are you sure you want to delete user "${username}"?`)) {
      return;
    }

    try {
      await deleteUserMutation.mutateAsync(id);
      toast({
        title: "User Deleted",
        description: "The user has been successfully deleted.",
      });
    } catch (error: any) {
      toast({
        title: "Error",
        description: error.message || "Failed to delete user",
        variant: "destructive",
      });
    }
  };

  return (
    <Card className="glassmorphism border-white/10">
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle className="flex items-center">
            <Users className="mr-2 h-5 w-5" />
            User Management
          </CardTitle>
          
          <Dialog open={isCreateDialogOpen} onOpenChange={setIsCreateDialogOpen}>
            <DialogTrigger asChild>
              <Button className="bg-primary hover:bg-primary/90">
                <Plus className="mr-2 h-4 w-4" />
                Add User
              </Button>
            </DialogTrigger>
            <DialogContent className="glassmorphism border-white/20">
              <DialogHeader>
                <DialogTitle>Create New User</DialogTitle>
              </DialogHeader>
              <form onSubmit={handleCreateUser} className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="username">Username</Label>
                  <Input
                    id="username"
                    value={newUser.username}
                    onChange={(e) => setNewUser({ ...newUser, username: e.target.value })}
                    className="bg-background/50 border-white/20"
                    required
                  />
                </div>
                
                <div className="space-y-2">
                  <Label htmlFor="email">Email</Label>
                  <Input
                    id="email"
                    type="email"
                    value={newUser.email}
                    onChange={(e) => setNewUser({ ...newUser, email: e.target.value })}
                    className="bg-background/50 border-white/20"
                    required
                  />
                </div>
                
                <div className="space-y-2">
                  <Label htmlFor="password">Password</Label>
                  <Input
                    id="password"
                    type="password"
                    value={newUser.password}
                    onChange={(e) => setNewUser({ ...newUser, password: e.target.value })}
                    className="bg-background/50 border-white/20"
                    required
                  />
                </div>
                
                <div className="space-y-2">
                  <Label htmlFor="role">Role</Label>
                  <Select
                    value={newUser.role}
                    onValueChange={(value) => setNewUser({ ...newUser, role: value })}
                  >
                    <SelectTrigger className="bg-background/50 border-white/20">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="user">User</SelectItem>
                      <SelectItem value="admin">Admin</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                
                <div className="flex justify-end space-x-3 pt-4">
                  <Button
                    type="button"
                    variant="outline"
                    onClick={() => setIsCreateDialogOpen(false)}
                    className="glassmorphism border-white/20"
                  >
                    Cancel
                  </Button>
                  <Button
                    type="submit"
                    disabled={createUserMutation.isPending}
                    className="bg-primary hover:bg-primary/90"
                  >
                    {createUserMutation.isPending ? "Creating..." : "Create User"}
                  </Button>
                </div>
              </form>
            </DialogContent>
          </Dialog>
        </div>
      </CardHeader>
      
      <CardContent>
        {isLoading ? (
          <div className="space-y-4">
            {Array.from({ length: 3 }).map((_, i) => (
              <div key={i} className="bg-background/30 rounded-lg p-4 animate-pulse">
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-4">
                    <div className="w-10 h-10 bg-muted rounded-full"></div>
                    <div className="space-y-2">
                      <div className="h-4 bg-muted rounded w-24"></div>
                      <div className="h-3 bg-muted rounded w-32"></div>
                    </div>
                  </div>
                  <div className="h-6 bg-muted rounded w-16"></div>
                </div>
              </div>
            ))}
          </div>
        ) : users?.length === 0 ? (
          <div className="text-center py-8 text-muted-foreground">
            <UserCheck className="h-12 w-12 mx-auto mb-4 opacity-50" />
            <h3 className="text-lg font-medium mb-2">No Users Found</h3>
            <p>Create your first user to get started.</p>
          </div>
        ) : (
          <div className="space-y-4">
            {users?.map((user, index) => (
              <motion.div
                key={user.id}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: index * 0.1 }}
                className="flex items-center justify-between bg-background/30 rounded-lg p-4"
              >
                <div className="flex items-center space-x-4">
                  <div className="w-10 h-10 bg-gradient-to-br from-primary to-purple-500 rounded-full flex items-center justify-center">
                    <span className="text-white font-semibold text-sm">
                      {user.username.charAt(0).toUpperCase()}
                    </span>
                  </div>
                  <div>
                    <h5 className="font-medium">{user.username}</h5>
                    <p className="text-sm text-muted-foreground">{user.email}</p>
                  </div>
                </div>
                
                <div className="flex items-center space-x-2">
                  <Badge className={
                    user.role === "admin" 
                      ? "bg-emerald-500/20 text-emerald-400" 
                      : "bg-blue-500/20 text-blue-400"
                  }>
                    {user.role.charAt(0).toUpperCase() + user.role.slice(1)}
                  </Badge>
                  
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => handleDeleteUser(user.id, user.username)}
                    disabled={deleteUserMutation.isPending}
                    className="text-red-400 hover:text-red-300 hover:bg-red-500/10"
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </div>
              </motion.div>
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  );
}

================
File: client/src/components/episodes/batch-process-dialog.tsx
================
import { useState } from "react";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { AlertCircle, Loader2 } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { useBatchProcess } from "@/hooks/use-episodes";
import { useToast } from "@/hooks/use-toast";
import type { ExtractionMethod } from "@/types";

interface BatchProcessDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  extractionMethod: ExtractionMethod;
}

export default function BatchProcessDialog({
  open,
  onOpenChange,
  extractionMethod
}: BatchProcessDialogProps) {
  const [urlsInput, setUrlsInput] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const batchProcessMutation = useBatchProcess();
  const { toast } = useToast();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    
    // Process URLs: split by newline, filter empty lines, and trim whitespace
    const urls = urlsInput
      .split("\n")
      .map(url => url.trim())
      .filter(url => url.length > 0);
    
    if (urls.length === 0) {
      setError("Please enter at least one URL");
      return;
    }

    // Validate URLs
    const invalidUrls = urls.filter(url => !url.includes("youtube.com/") && !url.includes("youtu.be/"));
    if (invalidUrls.length > 0) {
      setError(`Found ${invalidUrls.length} invalid YouTube URLs. Please check your input.`);
      return;
    }
    
    try {
      setIsSubmitting(true);
      const result = await batchProcessMutation.mutateAsync({ 
        urls, 
        extractionMethod 
      });
      
      // Count successful and failed processes
      const successful = result.results.filter((r: any) => r.success).length;
      const failed = result.results.filter((r: any) => !r.success).length;
      
      toast({
        title: "Batch Process Started",
        description: `Successfully queued ${successful} episodes${failed > 0 ? `, ${failed} failed` : ''}.`,
        variant: successful > 0 ? "default" : "destructive",
      });
      
      // Reset form and close dialog if at least one was successful
      if (successful > 0) {
        setUrlsInput("");
        onOpenChange(false);
      }
    } catch (error: any) {
      setError(error.message || "An error occurred while processing your request");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Batch Process Episodes</DialogTitle>
          <DialogDescription>
            Enter one YouTube URL per line to process multiple episodes using web scraping.
          </DialogDescription>
        </DialogHeader>
        
        <form onSubmit={handleSubmit} className="space-y-4">
          {error && (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          
          <div className="space-y-2">
            <Label htmlFor="urls">YouTube URLs (one per line)</Label>
            <Textarea
              id="urls"
              placeholder="https://www.youtube.com/watch?v=..."
              value={urlsInput}
              onChange={(e) => setUrlsInput(e.target.value)}
              rows={8}
              className="font-mono text-sm"
              disabled={isSubmitting}
            />
          </div>
          
          <DialogFooter>
            <Button 
              type="button" 
              variant="outline" 
              onClick={() => onOpenChange(false)}
              disabled={isSubmitting}
            >
              Cancel
            </Button>
            <Button 
              type="submit"
              disabled={isSubmitting}
              className="bg-gradient-to-r from-primary to-purple-500 hover:from-primary/90 hover:to-purple-500/90"
            >
              {isSubmitting ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Processing...
                </>
              ) : (
                "Start Batch Processing"
              )}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================
File: client/src/components/episodes/episode-card.tsx
================
import { motion } from "framer-motion";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Eye, Trash2, RotateCcw } from "lucide-react";
import { useDeleteEpisode } from "@/hooks/use-episodes";
import { useToast } from "@/hooks/use-toast";
import TranscriptViewer from "./transcript-viewer";
import { useState, useRef } from "react";
import type { Episode } from "@shared/schema";

interface EpisodeCardProps {
  episode: Episode;
  viewMode: "grid" | "list";
}

export default function EpisodeCard({ episode, viewMode }: EpisodeCardProps) {
  const { toast } = useToast();
  const deleteEpisodeMutation = useDeleteEpisode();
  const [isTranscriptOpen, setIsTranscriptOpen] = useState(false);
  const deletingRef = useRef(false);

  const handleDelete = async () => {
    // Prevent duplicate delete operations
    if (deletingRef.current || deleteEpisodeMutation.isPending) {
      return;
    }
    
    try {
      // Set deleting flag to true
      deletingRef.current = true;
      
      // Attempt to delete the episode
      await deleteEpisodeMutation.mutateAsync(episode.id);
      
      // Only show success toast if we get here (no error thrown)
      toast({
        title: "Episode Deleted",
        description: "The episode has been successfully deleted.",
      });
    } catch (error: any) {
      console.error("Failed to delete episode:", error);
      // Only show error toast when there's an actual error
      toast({
        title: "Error Deleting Episode",
        description: error.message || "Failed to delete episode. Please try again.",
        variant: "destructive",
      });
    } finally {
      // Reset deleting flag
      deletingRef.current = false;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case "completed":
        return "bg-emerald-500";
      case "processing":
        return "bg-amber-500";
      case "failed":
        return "bg-red-500";
      default:
        return "bg-slate-500";
    }
  };

  const getStatusText = (status: string) => {
    switch (status) {
      case "completed":
        return "âœ“ Processed";
      case "processing":
        return "â³ Processing";
      case "failed":
        return "âœ— Failed";
      default:
        return "â¸ Pending";
    }
  };

  const getMethodColor = (method: string) => {
    switch (method) {
      case "caption":
        return "bg-blue-500/20 text-blue-400";
      case "scraping":
        return "bg-purple-500/20 text-purple-400";
      case "audio":
        return "bg-emerald-500/20 text-emerald-400";
      default:
        return "bg-slate-500/20 text-slate-400";
    }
  };

  const getMethodText = (method: string) => {
    switch (method) {
      case "caption":
        return "Caption-Based";
      case "scraping":
        return "Web Scraping";
      case "audio":
        return "Audio-Based";
      default:
        return method;
    }
  };

  if (viewMode === "list") {
    return (
      <>
        <Card className="glassmorphism border-white/10 hover:bg-white/5 transition-colors">
          <CardContent className="p-6">
            <div className="flex items-center space-x-6">
              <img 
                src={episode.thumbnailUrl || "https://images.unsplash.com/photo-1540575467063-178a50c2df87?ixlib=rb-4.0.3&auto=format&fit=crop&w=120&h=80"} 
                alt={episode.title}
                className="w-20 h-12 object-cover rounded"
              />
              
              <div className="flex-1 min-w-0">
                <h3 className="font-medium text-sm line-clamp-1 mb-1">{episode.title}</h3>
                <p className="text-xs text-muted-foreground mb-2">{episode.channel} â€¢ {episode.duration}</p>
                <div className="flex items-center space-x-2">
                  <Badge className={getMethodColor(episode.extractionMethod)}>
                    {getMethodText(episode.extractionMethod)}
                  </Badge>
                  <Badge className={getStatusColor(episode.status)}>
                    {getStatusText(episode.status)}
                  </Badge>
                </div>
              </div>
              
              <div className="flex items-center space-x-2">
                <span className="text-xs text-muted-foreground">
                  {episode.wordCount ? `${episode.wordCount} words` : ""}
                </span>
                <Button 
                  variant="ghost" 
                  size="sm"
                  onClick={() => setIsTranscriptOpen(true)}
                  disabled={!episode.transcript}
                  title={episode.transcript ? "View transcript" : "Transcript not available"}
                >
                  <Eye className="h-4 w-4" />
                </Button>
                {episode.status === "failed" && (
                  <Button variant="ghost" size="sm">
                    <RotateCcw className="h-4 w-4" />
                  </Button>
                )}
                <Button 
                  variant="ghost" 
                  size="sm"
                  onClick={handleDelete}
                  disabled={deleteEpisodeMutation.isPending}
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
        
        <TranscriptViewer 
          episode={episode}
          isOpen={isTranscriptOpen}
          onClose={() => setIsTranscriptOpen(false)}
        />
      </>
    );
  }

  return (
    <motion.div
      whileHover={{ y: -4, scale: 1.02 }}
      transition={{ type: "spring", stiffness: 300, damping: 30 }}
    >
      <Card className="glassmorphism border-white/10 hover:bg-white/5 transition-colors overflow-hidden">
        <div className="relative">
          <img 
            src={episode.thumbnailUrl || "https://images.unsplash.com/photo-1540575467063-178a50c2df87?ixlib=rb-4.0.3&auto=format&fit=crop&w=400&h=225"} 
            alt={episode.title}
            className="w-full h-48 object-cover"
          />
          <div className="absolute top-3 right-3 bg-black/70 text-white text-xs px-2 py-1 rounded font-mono">
            {episode.duration}
          </div>
          <div className={`absolute top-3 left-3 text-white text-xs px-2 py-1 rounded-full ${getStatusColor(episode.status)}`}>
            {getStatusText(episode.status)}
          </div>
        </div>
        
        <CardContent className="p-6">
          <h3 className="font-medium text-sm line-clamp-2 mb-2">{episode.title}</h3>
          <p className="text-xs text-muted-foreground mb-4 line-clamp-2">
            {episode.description || `${episode.channel} â€¢ ${new Date(episode.createdAt).toLocaleDateString()}`}
          </p>
          
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2 text-xs">
              <Badge className={getMethodColor(episode.extractionMethod)}>
                {getMethodText(episode.extractionMethod)}
              </Badge>
              <span className="text-muted-foreground">
                {episode.wordCount ? `${episode.wordCount} words` : ""}
              </span>
            </div>
            
            <div className="flex items-center space-x-2">
              <Button 
                variant="ghost" 
                size="sm"
                onClick={() => setIsTranscriptOpen(true)}
                disabled={!episode.transcript}
                title={episode.transcript ? "View transcript" : "Transcript not available"}
              >
                <Eye className="h-4 w-4" />
              </Button>
              {episode.status === "failed" && (
                <Button variant="ghost" size="sm">
                  <RotateCcw className="h-4 w-4" />
                </Button>
              )}
              <Button 
                variant="ghost" 
                size="sm"
                onClick={handleDelete}
                disabled={deleteEpisodeMutation.isPending}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>
      
      <TranscriptViewer 
        episode={episode}
        isOpen={isTranscriptOpen}
        onClose={() => setIsTranscriptOpen(false)}
      />
    </motion.div>
  );
}

================
File: client/src/components/episodes/extraction-method-selector.tsx
================
import { motion } from "framer-motion";
import { Card, CardContent } from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { Zap, Globe, Mic, Lock } from "lucide-react";
import type { ExtractionMethod } from "@/types";

interface ExtractionMethodSelectorProps {
  value: ExtractionMethod;
  onChange: (method: ExtractionMethod) => void;
}

const methods = [
  {
    id: "caption" as ExtractionMethod,
    name: "ðŸ“ Caption-Based",
    description: "Fast API extraction using YouTube's built-in captions",
    icon: Zap,
    badge: "Coming Soon",
    badgeColor: "bg-gray-500/20 text-gray-400",
    pros: ["Lightning fast", "High accuracy"],
    cons: ["May be blocked"],
    iconColor: "text-gray-400",
    bgColor: "bg-gray-500/20",
    disabled: true
  },
  {
    id: "scraping" as ExtractionMethod,
    name: "ðŸŒ Web Scraping",
    description: "Bypasses all blocks and restrictions",
    icon: Globe,
    badge: "Recommended",
    badgeColor: "bg-purple-500/20 text-purple-400",
    pros: ["Always works", "Most reliable"],
    cons: ["Slightly slower"],
    iconColor: "text-purple-400",
    bgColor: "bg-purple-500/20",
    disabled: false
  },
  {
    id: "audio" as ExtractionMethod,
    name: "ðŸŽ¤ Audio-Based",
    description: "Speech recognition from audio track",
    icon: Mic,
    badge: "Coming Soon",
    badgeColor: "bg-gray-500/20 text-gray-400",
    pros: ["No captions needed", "Works offline"],
    cons: ["Takes 2-5 minutes"],
    iconColor: "text-gray-400",
    bgColor: "bg-gray-500/20",
    disabled: true
  }
];

export default function ExtractionMethodSelector({ value, onChange }: ExtractionMethodSelectorProps) {
  return (
    <div className="space-y-4">
      <h4 className="text-lg font-semibold">Extraction Method</h4>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        {methods.map((method, index) => (
          <motion.div
            key={method.id}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: index * 0.1 }}
          >
            <Card
              className={cn(
                "transition-all duration-300 border-2",
                method.disabled 
                  ? "opacity-70 cursor-not-allowed border-gray-500/20" 
                  : "cursor-pointer hover:scale-105",
                value === method.id && !method.disabled
                  ? "border-primary bg-primary/5 shadow-lg shadow-primary/20"
                  : "glassmorphism border-white/20 hover:border-white/40"
              )}
              onClick={() => !method.disabled && onChange(method.id)}
            >
              <CardContent className="p-6 text-center">
                <div className="flex items-center justify-between mb-4">
                  <div className={cn("w-12 h-12 rounded-xl flex items-center justify-center", method.bgColor)}>
                    <method.icon className={cn("w-6 h-6", method.iconColor)} />
                  </div>
                  <span className={cn("text-xs px-2 py-1 rounded-full", method.badgeColor)}>
                    {method.badge}
                  </span>
                </div>
                
                <h5 className="font-semibold text-lg mb-2">
                  {method.name}
                  {method.disabled && (
                    <span className="ml-2 inline-flex items-center">
                      <Lock className="w-3 h-3 text-gray-400" />
                    </span>
                  )}
                </h5>
                <p className="text-sm text-muted-foreground mb-4">
                  {method.disabled ? "Future Feature - " : ""}{method.description}
                </p>
                
                <div className="space-y-2 text-xs">
                  {method.pros.map((pro, i) => (
                    <div key={i} className="flex items-center justify-center text-emerald-400">
                      <span>â€¢ {pro}</span>
                    </div>
                  ))}
                  {method.cons.map((con, i) => (
                    <div key={i} className="flex items-center justify-center text-amber-400">
                      <span>â€¢ {con}</span>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          </motion.div>
        ))}
      </div>
    </div>
  );
}

================
File: client/src/components/episodes/highlighted-transcript.tsx
================
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Loader2, Sparkles, Filter, RotateCcw } from "lucide-react";
import { analyzeKeywords, highlightText, type AnalysisResult, type AnalysisProgressCallback } from "@/lib/keyword-analyzer";
import { Progress } from "@/components/ui/progress";

interface HighlightedTranscriptProps {
  transcript: string;
}

export default function HighlightedTranscript({ transcript }: HighlightedTranscriptProps) {
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [analysis, setAnalysis] = useState<AnalysisResult | null>(null);
  const [showHighlights, setShowHighlights] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [selectedCategories, setSelectedCategories] = useState<Set<string>>(new Set(['important', 'technical', 'name', 'concept', 'action']));
  const [progressStatus, setProgressStatus] = useState<string>('');
  const [progressValue, setProgressValue] = useState<number>(0);

  const handleProgressUpdate: AnalysisProgressCallback = (status, progress) => {
    setProgressStatus(status);
    setProgressValue(progress);
  };

  const handleAnalyze = async () => {
    setIsAnalyzing(true);
    setError(null);
    setProgressValue(0);
    setProgressStatus('Preparing to analyze...');
    
    try {
      const result = await analyzeKeywords(transcript, handleProgressUpdate);
      setAnalysis(result);
      setShowHighlights(true);
    } catch (err: any) {
      setError(err.message || 'Failed to analyze keywords');
      console.error('Keyword analysis error:', err);
    } finally {
      setIsAnalyzing(false);
    }
  };

  const toggleCategory = (category: string) => {
    const newCategories = new Set(selectedCategories);
    if (newCategories.has(category)) {
      newCategories.delete(category);
    } else {
      newCategories.add(category);
    }
    setSelectedCategories(newCategories);
  };

  const getFilteredKeywords = () => {
    if (!analysis) return [];
    return analysis.keywords.filter(keyword => selectedCategories.has(keyword.category));
  };

  const getHighlightedText = () => {
    if (!analysis || !showHighlights) return transcript;
    const filteredKeywords = getFilteredKeywords();
    return highlightText(transcript, filteredKeywords);
  };

  const getCategoryStats = () => {
    if (!analysis) return {};
    return {
      important: analysis.categories.important.length,
      technical: analysis.categories.technical.length,
      name: analysis.categories.name.length,
      concept: analysis.categories.concept.length,
      action: analysis.categories.action.length
    };
  };

  const categoryColors = {
    important: 'bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-200 border-yellow-300 dark:border-yellow-700',
    technical: 'bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200 border-blue-300 dark:border-blue-700',
    name: 'bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-200 border-green-300 dark:border-green-700',
    concept: 'bg-purple-100 dark:bg-purple-900/30 text-purple-800 dark:text-purple-200 border-purple-300 dark:border-purple-700',
    action: 'bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-200 border-red-300 dark:border-red-700'
  };

  const categoryLabels = {
    important: 'Important',
    technical: 'Technical',
    name: 'Names',
    concept: 'Concepts',
    action: 'Actions'
  };

  return (
    <div className="space-y-6">
      {/* Controls */}
      <div className="flex flex-col sm:flex-row sm:items-center gap-3 justify-between">
        <div>
          {!isAnalyzing && !analysis && (
            <Button
              onClick={handleAnalyze}
              className="flex items-center gap-2 bg-gradient-to-r from-purple-500 to-blue-500 hover:from-purple-600 hover:to-blue-600"
            >
              <Sparkles className="w-4 h-4" />
              Analyze Keywords
            </Button>
          )}
          
          {isAnalyzing && (
            <div className="space-y-2">
              <div className="flex items-center gap-2 text-gray-600 dark:text-gray-400">
                <Loader2 className="w-4 h-4 animate-spin" />
                <span>{progressStatus}</span>
              </div>
              <Progress value={progressValue} className="w-[250px] h-2" />
            </div>
          )}
          
          {error && (
            <div className="text-red-500 text-sm flex items-center gap-2">
              <span>Error: {error}</span>
              <Button 
                variant="ghost" 
                size="sm"
                onClick={handleAnalyze}
                className="h-7 px-2"
              >
                Retry
              </Button>
            </div>
          )}
        </div>

        {analysis && (
          <div className="flex items-center gap-2 flex-wrap">
            <Button
              size="sm"
              variant="outline"
              onClick={() => setShowHighlights(!showHighlights)}
              className="h-8"
            >
              {showHighlights ? 'Hide Highlights' : 'Show Highlights'}
            </Button>
            
            <Button
              size="sm"
              variant="outline"
              onClick={() => {
                setAnalysis(null);
                setShowHighlights(false);
                setProgressValue(0);
                setProgressStatus('');
              }}
              className="h-8"
            >
              <RotateCcw className="w-3 h-3 mr-1" />
              Reset
            </Button>
            
            <div className="ml-auto flex items-center">
              <Filter className="w-4 h-4 mr-1 text-gray-500" />
              <span className="text-xs text-gray-500 mr-2">Filter:</span>
              {['important', 'technical', 'name', 'concept', 'action'].map((category) => {
                const stats = getCategoryStats();
                const count = stats[category as keyof typeof stats] || 0;
                return (
                  <Badge
                    key={category}
                    variant={selectedCategories.has(category) ? "default" : "outline"}
                    className={`mr-1 cursor-pointer ${getCategoryColorClass(category)}`}
                    onClick={() => toggleCategory(category)}
                  >
                    {getCategoryLabel(category)} ({count})
                  </Badge>
                );
              })}
            </div>
          </div>
        )}
      </div>

      {/* Category Filters */}
      {analysis && (
        <div className="flex justify-between items-center">
          {analysis && getFilteredKeywords().length > 0 && (
            <div className="text-xs text-gray-600 dark:text-gray-400">
              Showing {getFilteredKeywords().length} keywords
            </div>
          )}
        </div>
      )}

      {/* Transcript */}
      <div className="bg-white/50 dark:bg-gray-800/50 p-6 rounded-lg border border-gray-200/50 dark:border-gray-700/50">
        <div 
          className="whitespace-pre-wrap text-gray-700 dark:text-gray-300 leading-relaxed font-mono text-sm bg-gray-50 dark:bg-gray-900/50 p-4 rounded border overflow-auto"
          style={{ lineHeight: '1.7', wordBreak: 'break-word' }}
          dangerouslySetInnerHTML={{ 
            __html: getHighlightedText()
          }}
        />
      </div>

      {/* Keyword Legend */}
      {analysis && showHighlights && getFilteredKeywords().length > 0 && (
        <div className="p-4 bg-gradient-to-r from-gray-50 to-blue-50 dark:from-gray-900/20 dark:to-blue-900/20 rounded-lg border border-gray-200/50 dark:border-gray-700/50">
          <h5 className="font-medium text-sm mb-3 flex items-center gap-2">
            <Sparkles className="w-4 h-4" />
            Keyword Legend
          </h5>
          
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 text-xs">
            {['important', 'technical', 'name', 'concept', 'action'].map((category) => (
              <div key={category} className="flex items-center gap-2">
                <div className={`w-3 h-3 rounded ${getCategoryBgClass(category)}`} />
                <span>{getCategoryLabel(category)}</span>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* CSS for keyword highlights */}
      <style dangerouslySetInnerHTML={{
        __html: `
        .keyword-highlight {
          padding: 2px 4px;
          border-radius: 4px;
          font-weight: 500;
          cursor: help;
          transition: all 0.2s ease;
          display: inline;
          margin: 0 1px;
          white-space: pre-wrap;
          line-height: 1.7;
        }
        .keyword-highlight:hover {
          transform: scale(1.05);
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
          position: relative;
          z-index: 5;
        }
        `
      }} />
    </div>
  );
}

function getCategoryLabel(category: string): string {
  switch (category) {
    case 'important': return 'Important';
    case 'technical': return 'Technical';
    case 'name': return 'Names';
    case 'concept': return 'Concepts';
    case 'action': return 'Actions';
    default: return category;
  }
}

function getCategoryColorClass(category: string): string {
  switch (category) {
    case 'important': return 'bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-200 border-yellow-300 dark:border-yellow-700';
    case 'technical': return 'bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200 border-blue-300 dark:border-blue-700';
    case 'name': return 'bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-200 border-green-300 dark:border-green-700';
    case 'concept': return 'bg-purple-100 dark:bg-purple-900/30 text-purple-800 dark:text-purple-200 border-purple-300 dark:border-purple-700';
    case 'action': return 'bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-200 border-red-300 dark:border-red-700';
    default: return 'bg-gray-100 dark:bg-gray-900/30 text-gray-800 dark:text-gray-200 border-gray-300 dark:border-gray-700';
  }
}

function getCategoryBgClass(category: string): string {
  switch (category) {
    case 'important': return 'bg-yellow-200';
    case 'technical': return 'bg-blue-200';
    case 'name': return 'bg-green-200';
    case 'concept': return 'bg-purple-200';
    case 'action': return 'bg-red-200';
    default: return 'bg-gray-200';
  }
}

================
File: client/src/components/episodes/processing-status.tsx
================
import { useEffect, useState } from "react";
import { motion } from "framer-motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { useProcessingStatus } from "@/hooks/use-episodes";
import { Activity, X, CheckCircle, AlertCircle, Clock, FileText, Brain, Zap } from "lucide-react";
import { ReactNode } from "react";

// Helper function to safely check and convert unknown values to ReactNode
const safeRender = (value: unknown): ReactNode => {
  if (typeof value === 'string') return value;
  if (typeof value === 'number') return String(value);
  if (typeof value === 'boolean') return String(value);
  return null;
};

interface ProcessingStatusProps {
  episodeId: number;
  onComplete?: () => void;
}

export default function ProcessingStatus({ episodeId, onComplete }: ProcessingStatusProps) {
  const { data: status, isLoading } = useProcessingStatus(episodeId);
  const [timeElapsed, setTimeElapsed] = useState(0);
  const [startTime, setStartTime] = useState<Date | null>(null);

  useEffect(() => {
    if (status?.status === "processing" && !startTime) {
      setStartTime(new Date());
    }
  }, [status?.status, startTime]);

  useEffect(() => {
    if (status?.status === "processing" && startTime) {
      const timer = setInterval(() => {
        setTimeElapsed(Math.floor((Date.now() - startTime.getTime()) / 1000));
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [status?.status, startTime]);

  useEffect(() => {
    if (status?.status === "completed" && onComplete) {
      setTimeout(onComplete, 3000);
    }
  }, [status?.status, onComplete]);

  if (isLoading || !status) {
    return null;
  }

  const getStatusInfo = () => {
    switch (status.status) {
      case "processing":
        return {
          icon: Activity,
          color: "text-blue-400",
          bgColor: "bg-blue-500/10",
          borderColor: "border-blue-500/30"
        };
      case "completed":
        return {
          icon: CheckCircle,
          color: "text-emerald-400",
          bgColor: "bg-emerald-500/10",
          borderColor: "border-emerald-500/30"
        };
      case "failed":
        return {
          icon: AlertCircle,
          color: "text-red-400",
          bgColor: "bg-red-500/10",
          borderColor: "border-red-500/30"
        };
      default:
        return {
          icon: Activity,
          color: "text-slate-400",
          bgColor: "bg-slate-500/10",
          borderColor: "border-slate-500/30"
        };
    }
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const getStepIcon = (step: string) => {
    if (step?.includes("transcript") || step?.includes("Extracting")) {
      return <FileText className="h-4 w-4 text-blue-500" />;
    }
    if (step?.includes("summary") || step?.includes("AI")) {
      return <Brain className="h-4 w-4 text-purple-500" />;
    }
    if (step?.includes("Initializing")) {
      return <Zap className="h-4 w-4 text-green-500" />;
    }
    return <Activity className="h-4 w-4 text-gray-500 animate-spin" />;
  };

  const statusInfo = getStatusInfo();
  const progress = Math.max(0, Math.min(100, status.progress || 0));

  return (
    <motion.div
      initial={{ opacity: 0, y: 20, scale: 0.95 }}
      animate={{ opacity: 1, y: 0, scale: 1 }}
      exit={{ opacity: 0, y: -20, scale: 0.95 }}
      transition={{ duration: 0.3 }}
    >
      <Card className={`glassmorphism border-2 ${statusInfo.borderColor} ${statusInfo.bgColor} shadow-lg`}>
        <CardHeader className="pb-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <statusInfo.icon className={`h-6 w-6 ${statusInfo.color} ${
                status.status === "processing" ? "animate-pulse" : ""
              }`} />
              <div>
                <CardTitle className="text-lg">
                  {status.status === "processing" ? "Processing Episode" :
                   status.status === "completed" ? "Processing Complete" :
                   status.status === "failed" ? "Processing Failed" :
                   "Processing Episode"}
                </CardTitle>
                <Badge variant="outline" className="mt-1 text-xs">
                  {status.extractionMethod === "caption" ? "Caption-Based" :
                   status.extractionMethod === "scraping" ? "Web Scraping" :
                   status.extractionMethod === "audio" ? "Audio-Based" :
                   "Processing"}
                </Badge>
              </div>
            </div>
            <Button variant="ghost" size="sm" onClick={onComplete}>
              <X className="h-4 w-4" />
            </Button>
          </div>
        </CardHeader>
        
        <CardContent className="space-y-5">
          {/* Progress Section */}
          <div className="space-y-3">
            <div className="flex items-center gap-3">
              {getStepIcon(status.currentStep || "")}
              <span className="text-sm font-medium flex-1">
                {status.currentStep || "Preparing to process..."}
              </span>
              <span className={`text-lg font-bold ${statusInfo.color}`}>
                {progress}%
              </span>
            </div>
            
            {status.status !== "failed" && (
              <div className="relative">
                <Progress value={progress} className="h-3" />
                <motion.div 
                  className={`absolute top-0 left-0 h-3 rounded-full bg-gradient-to-r ${
                    progress < 30 ? "from-blue-500 to-blue-600" :
                    progress < 70 ? "from-yellow-500 to-orange-500" :
                    "from-green-500 to-emerald-500"
                  }`}
                  initial={{ width: 0 }}
                  animate={{ width: `${progress}%` }}
                  transition={{ duration: 0.5, ease: "easeOut" }}
                />
              </div>
            )}
          </div>

          {/* Timing Information */}
          {status.status === "processing" && timeElapsed > 0 && (
            <div className="grid grid-cols-2 gap-4 text-sm">
              <div className="flex items-center gap-2">
                <Clock className="h-4 w-4 text-gray-500" />
                <div>
                  <div className="text-muted-foreground">Elapsed</div>
                  <div className="font-mono font-medium">{formatTime(timeElapsed)}</div>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <FileText className="h-4 w-4 text-blue-500" />
                <div>
                  <div className="text-muted-foreground">Method</div>
                  <div className="font-medium">
                    {status.extractionMethod === "caption" ? "Caption-Based" :
                     status.extractionMethod === "scraping" ? "Web Scraping" :
                     "Audio-Based"}
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Content Information */}
          {status.transcript && (
            <div className="bg-gray-50 dark:bg-gray-900 p-3 rounded-lg">
              <div className="flex items-center justify-between text-sm">
                <span className="text-muted-foreground">Content extracted:</span>
                <span className="font-medium">{status.transcript.length.toLocaleString()} characters</span>
              </div>
              {status.wordCount && (
                <div className="flex items-center justify-between text-sm mt-1">
                  <span className="text-muted-foreground">Word count:</span>
                  <span className="font-medium">{status.wordCount.toLocaleString()} words</span>
                </div>
              )}
            </div>
          )}

          {/* Completion Status */}
          {status.status === "completed" && (
            <div className="space-y-2">
              <div className="flex items-center justify-between text-sm">
                <span className="text-emerald-400">âœ“ Transcript extracted</span>
                <span className="text-muted-foreground">{status.wordCount} words</span>
              </div>
              {status.summary && typeof status.summary === 'string' && (
                <div className="text-sm text-emerald-400">âœ“ Summary generated</div>
              )}
              {Array.isArray(status.topics) && status.topics.length > 0 && (
                <div className="text-sm text-emerald-400">âœ“ Topics extracted</div>
              )}
            </div>
          )}

          {/* Error Display */}
          {status.status === "failed" && status.errorMessage && (
            <div className="p-4 bg-red-50 dark:bg-red-950 border border-red-200 dark:border-red-800 rounded-lg">
              <div className="flex items-center gap-2 mb-2">
                <AlertCircle className="h-4 w-4 text-red-500" />
                <span className="font-medium text-red-700 dark:text-red-300">Processing Failed</span>
              </div>
              <p className="text-sm text-red-600 dark:text-red-400">
                {status.errorMessage}
              </p>
            </div>
          )}

          {/* Real-time Processing Indicator */}
          {status.status === "processing" && (
            <div className="flex items-center justify-center pt-2">
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <div className="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
                <span>Processing in real-time...</span>
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </motion.div>
  );
}

================
File: client/src/components/episodes/simple-processing-indicator.tsx
================
import { useEffect, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { X, Loader2, CheckCircle, AlertCircle } from "lucide-react";
import { useQuery } from "@tanstack/react-query";

interface SimpleProcessingIndicatorProps {
  episodeId: number;
  onClose?: () => void;
}

export default function SimpleProcessingIndicator({ episodeId, onClose }: SimpleProcessingIndicatorProps) {
  const { data: episode } = useQuery({
    queryKey: ["/api/episodes", episodeId],
    queryFn: () => fetch(`/api/episodes/${episodeId}`).then(res => res.json()),
    refetchInterval: 1000,
    enabled: !!episodeId,
  });
  
  const [dots, setDots] = useState("");

  // Animated dots for processing
  useEffect(() => {
    if (episode?.status === "processing") {
      const interval = setInterval(() => {
        setDots(prev => prev.length >= 3 ? "" : prev + ".");
      }, 500);
      return () => clearInterval(interval);
    }
  }, [episode?.status]);

  // Auto-close on completion
  useEffect(() => {
    if (episode?.status === "completed" && onClose) {
      setTimeout(onClose, 2000);
    }
  }, [episode?.status, onClose]);

  if (!episode) {
    return (
      <Card className="bg-blue-50 dark:bg-blue-950 border-2 border-blue-200 dark:border-blue-800">
        <CardContent className="p-4">
          <div className="flex items-center gap-3">
            <Loader2 className="h-5 w-5 animate-spin text-blue-500" />
            <span className="text-sm font-medium">Loading episode...</span>
          </div>
        </CardContent>
      </Card>
    );
  }

  if (episode.status === "processing") {
    return (
      <Card className="bg-blue-50 dark:bg-blue-950 border-2 border-blue-200 dark:border-blue-800">
        <CardContent className="p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <Loader2 className="h-5 w-5 animate-spin text-blue-500" />
              <div>
                <h3 className="font-medium text-sm">Processing Episode</h3>
                <p className="text-xs text-muted-foreground">Extracting transcript{dots}</p>
                <p className="text-xs text-muted-foreground mt-1">
                  Method: {episode.extractionMethod === "caption" ? "Caption-Based" :
                           episode.extractionMethod === "scraping" ? "Web Scraping" :
                           "Audio-Based"}
                </p>
              </div>
            </div>
            {onClose && (
              <Button variant="ghost" size="sm" onClick={onClose}>
                <X className="h-4 w-4" />
              </Button>
            )}
          </div>
        </CardContent>
      </Card>
    );
  }

  if (episode.status === "completed") {
    return (
      <Card className="bg-green-50 dark:bg-green-950 border-2 border-green-200 dark:border-green-800">
        <CardContent className="p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <CheckCircle className="h-5 w-5 text-green-500" />
              <div>
                <h3 className="font-medium text-sm">Processing Complete</h3>
                <p className="text-xs text-muted-foreground">
                  Successfully extracted {episode.transcript?.length || 0} characters
                </p>
              </div>
            </div>
            {onClose && (
              <Button variant="ghost" size="sm" onClick={onClose}>
                <X className="h-4 w-4" />
              </Button>
            )}
          </div>
        </CardContent>
      </Card>
    );
  }

  if (episode.status === "failed") {
    return (
      <Card className="bg-red-50 dark:bg-red-950 border-2 border-red-200 dark:border-red-800">
        <CardContent className="p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <AlertCircle className="h-5 w-5 text-red-500" />
              <div>
                <h3 className="font-medium text-sm">Processing Failed</h3>
                <p className="text-xs text-muted-foreground">
                  {episode.errorMessage || "Failed to extract transcript"}
                </p>
              </div>
            </div>
            {onClose && (
              <Button variant="ghost" size="sm" onClick={onClose}>
                <X className="h-4 w-4" />
              </Button>
            )}
          </div>
        </CardContent>
      </Card>
    );
  }

  return null;
}

================
File: client/src/components/episodes/transcript-viewer.tsx
================
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Badge } from "@/components/ui/badge";
import { Clock, User, FileText } from "lucide-react";
import HighlightedTranscript from "./highlighted-transcript";
import type { Episode } from "@/../../shared/schema";
import { ReactNode } from "react";

// Helper function to safely check and convert unknown values to ReactNode
const safeRender = (value: unknown): ReactNode => {
  if (typeof value === 'string') return value;
  if (typeof value === 'number') return String(value);
  if (typeof value === 'boolean') return String(value);
  return null;
};

interface TranscriptViewerProps {
  episode: Episode | null;
  isOpen: boolean;
  onClose: () => void;
}

export default function TranscriptViewer({ episode, isOpen, onClose }: TranscriptViewerProps) {
  if (!episode) return null;

  const formatDuration = (seconds: number | null) => {
    if (!seconds) return "N/A";
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[80vh] bg-white/95 dark:bg-gray-900/95 backdrop-blur-md border border-white/20">
        <DialogHeader className="border-b border-white/10 pb-4">
          <DialogTitle className="text-xl font-semibold text-gray-900 dark:text-white flex items-center gap-2">
            <FileText className="w-5 h-5" />
            Transcript Viewer
          </DialogTitle>
          
          {/* Episode Info */}
          <div className="space-y-3 pt-2">
            <h3 className="text-lg font-medium text-gray-800 dark:text-gray-200 line-clamp-2">
              {episode.title || 'YouTube Video'}
            </h3>
            
            <div className="flex flex-wrap items-center gap-4 text-sm text-gray-600 dark:text-gray-400">
              {episode.channel && (
                <div className="flex items-center gap-1">
                  <User className="w-4 h-4" />
                  <span>{episode.channel}</span>
                </div>
              )}
              
              {episode.duration && (
                <div className="flex items-center gap-1">
                  <Clock className="w-4 h-4" />
                  <span>{formatDuration(Number(episode.duration))}</span>
                </div>
              )}
              
              <Badge variant="secondary" className="bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300">
                {episode.extractionMethod}
              </Badge>
              
              {episode.wordCount && (
                <span className="text-xs bg-gray-100 dark:bg-gray-800 px-2 py-1 rounded">
                  {episode.wordCount.toLocaleString()} words
                </span>
              )}
            </div>
          </div>
        </DialogHeader>

        <div className="flex-1 min-h-0">
          <ScrollArea className="h-[60vh] pr-4">
            <div className="space-y-6">
              {/* AI Summary */}
              {(() => {
                if (typeof episode.summary === 'string' && episode.summary.trim() !== '') {
                  return (
                    <div className="bg-gradient-to-r from-blue-50 to-purple-50 dark:from-blue-900/20 dark:to-purple-900/20 p-4 rounded-lg border border-blue-200/50 dark:border-blue-700/50">
                      <h4 className="font-medium text-blue-900 dark:text-blue-300 mb-2 flex items-center gap-2">
                        ðŸ¤– AI Summary
                      </h4>
                      <p className="text-gray-700 dark:text-gray-300 leading-relaxed">
                        {episode.summary}
                      </p>
                    </div>
                  );
                }
                return null;
              })()}

              {/* Topics */}
              {(() => {
                if (episode.topics && Array.isArray(episode.topics) && episode.topics.length > 0) {
                  return (
                    <div className="bg-gradient-to-r from-green-50 to-emerald-50 dark:from-green-900/20 dark:to-emerald-900/20 p-4 rounded-lg border border-green-200/50 dark:border-green-700/50">
                      <h4 className="font-medium text-green-900 dark:text-green-300 mb-3 flex items-center gap-2">
                        ðŸ·ï¸ Key Topics
                      </h4>
                      <div className="flex flex-wrap gap-2">
                        {episode.topics.map((topic: string, index: number) => (
                          <Badge 
                            key={index} 
                            variant="outline" 
                            className="bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-300 border-green-300 dark:border-green-600"
                          >
                            {topic}
                          </Badge>
                        ))}
                      </div>
                    </div>
                  );
                }
                return null;
              })()}

              {/* Full Transcript with AI Keyword Highlighting */}
              <div className="bg-white/50 dark:bg-gray-800/50 p-6 rounded-lg border border-gray-200/50 dark:border-gray-700/50">
                <h4 className="font-medium text-gray-900 dark:text-gray-200 mb-4 flex items-center gap-2">
                  ðŸ“ Full Transcript
                </h4>
                
                {(() => {
                  if (typeof episode.transcript === 'string' && episode.transcript) {
                    return <HighlightedTranscript transcript={episode.transcript} />;
                  }
                  return (
                    <div className="text-center py-8 text-gray-500 dark:text-gray-400">
                      <FileText className="w-12 h-12 mx-auto mb-3 opacity-50" />
                      <p>Transcript not available</p>
                      <p className="text-sm">Processing may still be in progress</p>
                    </div>
                  );
                })()}
              </div>
            </div>
          </ScrollArea>
        </div>
      </DialogContent>
    </Dialog>
  );
}

================
File: client/src/components/layout/header.tsx
================
import { Button } from "@/components/ui/button";
import { NotificationBell } from "@/components/ui/notification-bell";

export default function Header() {
  return (
    <header className="glassmorphism border-b border-white/10 px-8 py-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-4">
          <div className="flex items-center space-x-2 glassmorphism rounded-full px-4 py-2 border border-white/10">
            <div className="w-2 h-2 bg-emerald-400 rounded-full animate-pulse"></div>
            <span className="text-sm">System Online</span>
          </div>
        </div>
        
        <div className="flex items-center space-x-4">
          <NotificationBell />
        </div>
      </div>
    </header>
  );
}

================
File: client/src/components/layout/main-layout.tsx
================
import { ReactNode } from "react";
import Sidebar from "./sidebar";
import Header from "./header";

interface MainLayoutProps {
  children: ReactNode;
}

export default function MainLayout({ children }: MainLayoutProps) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-800 text-slate-50">
      <div className="flex">
        <Sidebar />
        <div className="flex-1 ml-64">
          <Header />
          <main className="p-8">
            {children}
          </main>
        </div>
      </div>
    </div>
  );
}

================
File: client/src/components/layout/sidebar.tsx
================
import { Link, useLocation } from "wouter";
import { motion } from "framer-motion";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { 
  LayoutDashboard, 
  Plus, 
  Search, 
  Video, 
  BarChart3, 
  Settings, 
  User,
  Play
} from "lucide-react";

const navigation = [
  { name: "Dashboard", href: "/", icon: LayoutDashboard },
  { name: "Add Episode", href: "/add-episode", icon: Plus },
  { name: "Episodes", href: "/episodes", icon: Video },
  { name: "Search", href: "/search", icon: Search },
  { name: "Admin", href: "/admin", icon: Settings },
];

export default function Sidebar() {
  const [location] = useLocation();

  return (
    <div className="fixed left-0 top-0 h-full w-64 glassmorphism border-r border-white/10 z-40">
      <div className="p-6">
        {/* Logo */}
        <motion.div 
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          className="flex items-center space-x-3 mb-8"
        >
          <div className="w-10 h-10 bg-gradient-to-r from-primary to-purple-500 rounded-xl flex items-center justify-center">
            <Play className="w-6 h-6 text-white" />
          </div>
          <h1 className="text-xl font-bold bg-gradient-to-r from-primary to-purple-500 bg-clip-text text-transparent">
            TranscriptAI
          </h1>
        </motion.div>

        {/* Navigation */}
        <nav className="space-y-2">
          {navigation.map((item, index) => {
            const isActive = location === item.href;
            return (
              <motion.div
                key={item.name}
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ delay: index * 0.1 }}
              >
                <Link href={item.href}>
                  <Button
                    variant="ghost"
                    className={cn(
                      "w-full justify-start h-12 px-4 transition-all duration-200",
                      isActive 
                        ? "bg-primary/20 text-primary border border-primary/30" 
                        : "hover:bg-white/10 text-slate-300"
                    )}
                  >
                    <item.icon className="mr-3 h-5 w-5" />
                    {item.name}
                  </Button>
                </Link>
              </motion.div>
            );
          })}
        </nav>

        {/* User Profile */}
        <motion.div 
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.6 }}
          className="absolute bottom-6 left-6 right-6"
        >
          <div className="glassmorphism rounded-xl p-4 mb-4 border border-white/10">
            <div className="flex items-center space-x-3">
              <div className="w-8 h-8 bg-gradient-to-r from-primary to-purple-500 rounded-full flex items-center justify-center">
                <User className="w-4 h-4 text-white" />
              </div>
              <div>
                <p className="text-sm font-medium">Admin User</p>
                <p className="text-xs text-slate-400">Administrator</p>
              </div>
            </div>
          </div>
        </motion.div>
      </div>
    </div>
  );
}

================
File: client/src/components/search/search-results.tsx
================
import { motion } from "framer-motion";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { ExternalLink, Eye } from "lucide-react";
import type { SearchResult } from "@shared/schema";

interface SearchResultsProps {
  results: { results: SearchResult[]; totalResults: number };
  query: string;
}

const highlightText = (text: string, query: string) => {
  if (!query) return text;
  
  const regex = new RegExp(`(${query})`, 'gi');
  const parts = text.split(regex);
  
  return parts.map((part, index) => 
    regex.test(part) ? (
      <mark key={index} className="bg-amber-500/30 text-amber-200 px-1 rounded">
        {part}
      </mark>
    ) : part
  );
};

export default function SearchResults({ results, query }: SearchResultsProps) {
  if (!results || results.totalResults === 0) {
    return (
      <Card className="glassmorphism border-white/10">
        <CardContent className="p-12 text-center">
          <div className="text-muted-foreground">
            <h3 className="text-lg font-medium mb-2">No Results Found</h3>
            <p>No transcripts match your search query. Try different keywords or check your spelling.</p>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold">
          Search Results ({results.totalResults} found)
        </h3>
        <div className="text-sm text-muted-foreground">
          Showing results for "{query}"
        </div>
      </div>

      <div className="space-y-4">
        {results.results.map((result, index) => (
          <motion.div
            key={result.episode.id}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: index * 0.1 }}
          >
            <Card className="glassmorphism border-white/10 hover:bg-white/5 transition-colors">
              <CardContent className="p-6">
                <div className="flex items-start space-x-4">
                  <img 
                    src={result.episode.thumbnailUrl || "https://images.unsplash.com/photo-1589903308904-1010c2294adc?ixlib=rb-4.0.3&auto=format&fit=crop&w=120&h=80"} 
                    alt={result.episode.title}
                    className="w-20 h-12 object-cover rounded-lg flex-shrink-0"
                  />
                  
                  <div className="flex-1 space-y-3">
                    <div className="flex items-center justify-between">
                      <h4 className="font-semibold text-lg">
                        {highlightText(result.episode.title, query)}
                      </h4>
                      <span className="text-xs text-muted-foreground">
                        {Math.round((result.highlights[0]?.matchScore || 0) * 100)}% match
                      </span>
                    </div>
                    
                    <p className="text-sm text-muted-foreground">
                      {result.episode.channel} â€¢ {result.episode.duration} â€¢ {
                        new Date(result.episode.createdAt).toLocaleDateString()
                      }
                    </p>

                    {/* Search Highlights */}
                    <div className="space-y-3">
                      {result.highlights.slice(0, 2).map((highlight, i) => (
                        <div key={i} className="bg-background/30 rounded-lg p-4">
                          <p className="text-sm leading-relaxed">
                            {highlightText(highlight.segment, query)}
                          </p>
                          <div className="flex items-center justify-between mt-2">
                            <span className="text-xs text-muted-foreground">
                              Timestamp: {highlight.timestamp}
                            </span>
                            <Button variant="link" size="sm" className="text-primary h-auto p-0">
                              <ExternalLink className="mr-1 h-3 w-3" />
                              Jump to segment
                            </Button>
                          </div>
                        </div>
                      ))}
                    </div>

                    <div className="flex items-center justify-between pt-2">
                      <div className="flex items-center space-x-3">
                        <Badge className={
                          result.episode.extractionMethod === "caption" ? "bg-blue-500/20 text-blue-400" :
                          result.episode.extractionMethod === "scraping" ? "bg-purple-500/20 text-purple-400" :
                          "bg-emerald-500/20 text-emerald-400"
                        }>
                          {result.episode.extractionMethod === "caption" ? "Caption-Based" :
                           result.episode.extractionMethod === "scraping" ? "Web Scraping" :
                           "Audio-Based"}
                        </Badge>
                        <span className="text-xs text-muted-foreground">
                          {result.totalMatches} matches â€¢ {result.episode.wordCount} words
                        </span>
                      </div>
                      
                      <Button variant="outline" size="sm" className="glassmorphism border-white/20">
                        <Eye className="mr-2 h-4 w-4" />
                        View Full Transcript
                      </Button>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </motion.div>
        ))}
      </div>

      {/* Pagination would go here */}
      <div className="flex items-center justify-center space-x-4 mt-8">
        <Button variant="outline" className="glassmorphism border-white/20" disabled>
          Previous
        </Button>
        <div className="flex items-center space-x-2">
          <Button variant="default" size="sm" className="w-8 h-8 p-0">1</Button>
          <Button variant="outline" size="sm" className="w-8 h-8 p-0 glassmorphism border-white/20">2</Button>
          <Button variant="outline" size="sm" className="w-8 h-8 p-0 glassmorphism border-white/20">3</Button>
        </div>
        <Button variant="outline" className="glassmorphism border-white/20">
          Next
        </Button>
      </div>
    </div>
  );
}

================
File: client/src/components/search/transcript-modal.tsx
================
import { useState } from "react";
import { motion } from "framer-motion";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Badge } from "@/components/ui/badge";
import { Search, Download, Edit, ExternalLink, X } from "lucide-react";
import type { Episode } from "@shared/schema";

interface TranscriptModalProps {
  episode: Episode | null;
  isOpen: boolean;
  onClose: () => void;
}

const highlightText = (text: string, query: string) => {
  if (!query) return text;
  
  const regex = new RegExp(`(${query})`, 'gi');
  const parts = text.split(regex);
  
  return parts.map((part, index) => 
    regex.test(part) ? (
      <mark key={index} className="bg-amber-500/30 text-amber-200 px-1 rounded">
        {part}
      </mark>
    ) : part
  );
};

// Mock transcript segments with timestamps
const generateTranscriptSegments = (transcript: string) => {
  if (!transcript) return [];
  
  const sentences = transcript.split(/[.!?]+/).filter(s => s.trim());
  return sentences.map((sentence, index) => ({
    timestamp: `${Math.floor(index * 30 / 60)}:${(index * 30 % 60).toString().padStart(2, '0')}`,
    text: sentence.trim(),
  }));
};

export default function TranscriptModal({ episode, isOpen, onClose }: TranscriptModalProps) {
  const [searchQuery, setSearchQuery] = useState("");
  const [matchCount, setMatchCount] = useState(0);

  if (!episode) return null;

  const transcriptSegments = generateTranscriptSegments(episode.transcript || "");
  
  const filteredSegments = transcriptSegments.filter(segment =>
    !searchQuery || segment.text.toLowerCase().includes(searchQuery.toLowerCase())
  );

  // Count total matches
  const totalMatches = searchQuery 
    ? transcriptSegments.reduce((count, segment) => {
        const matches = segment.text.toLowerCase().split(searchQuery.toLowerCase()).length - 1;
        return count + matches;
      }, 0)
    : 0;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl h-[80vh] glassmorphism border-white/20">
        {/* Header */}
        <DialogHeader className="border-b border-white/10 pb-4">
          <div className="flex items-center justify-between">
            <div>
              <DialogTitle className="text-xl">{episode.title}</DialogTitle>
              <div className="flex items-center space-x-4 mt-2 text-sm text-muted-foreground">
                <span>{episode.channel}</span>
                <span>â€¢</span>
                <span>{episode.duration}</span>
                <span>â€¢</span>
                <span>{episode.wordCount} words</span>
              </div>
            </div>
            <Button variant="ghost" size="sm" onClick={onClose}>
              <X className="h-4 w-4" />
            </Button>
          </div>
        </DialogHeader>

        {/* Search Bar */}
        <div className="flex items-center space-x-4 py-4 border-b border-white/10">
          <div className="flex-1 relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search in transcript..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10 bg-background/50 border-white/20"
            />
          </div>
          
          <Badge className={
            episode.extractionMethod === "caption" ? "bg-blue-500/20 text-blue-400" :
            episode.extractionMethod === "scraping" ? "bg-purple-500/20 text-purple-400" :
            "bg-emerald-500/20 text-emerald-400"
          }>
            {episode.extractionMethod === "caption" ? "Caption-Based" :
             episode.extractionMethod === "scraping" ? "Web Scraping" :
             "Audio-Based"}
          </Badge>
        </div>

        {/* Transcript Content */}
        <div className="flex-1 min-h-0">
          <ScrollArea className="h-full pr-4">
            {transcriptSegments.length === 0 ? (
              <div className="text-center py-12 text-muted-foreground">
                <Search className="h-12 w-12 mx-auto mb-4 opacity-50" />
                <h3 className="text-lg font-medium mb-2">No Transcript Available</h3>
                <p>This episode doesn't have a transcript yet or processing is still in progress.</p>
              </div>
            ) : (
              <div className="space-y-4 font-mono text-sm leading-relaxed">
                {filteredSegments.map((segment, index) => (
                  <motion.div
                    key={index}
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: index * 0.02 }}
                    className="flex space-x-4 hover:bg-white/5 rounded-lg p-3 transition-colors"
                  >
                    <Button
                      variant="ghost"
                      size="sm"
                      className="text-primary hover:text-primary/80 min-w-[60px] h-auto p-1 text-xs"
                    >
                      {segment.timestamp}
                    </Button>
                    <p className="text-slate-300 flex-1">
                      {highlightText(segment.text, searchQuery)}
                    </p>
                  </motion.div>
                ))}
                
                {searchQuery && filteredSegments.length === 0 && (
                  <div className="text-center py-8 text-muted-foreground">
                    <Search className="h-8 w-8 mx-auto mb-2 opacity-50" />
                    <p>No matches found for "{searchQuery}"</p>
                  </div>
                )}
              </div>
            )}
          </ScrollArea>
        </div>

        {/* Footer */}
        <div className="flex items-center justify-between pt-4 border-t border-white/10">
          <div className="flex items-center space-x-4">
            <Button variant="outline" className="glassmorphism border-white/20">
              <Download className="mr-2 h-4 w-4" />
              Export
            </Button>
            <Button variant="outline" className="glassmorphism border-white/20">
              <Edit className="mr-2 h-4 w-4" />
              Edit
            </Button>
            <Button variant="outline" className="glassmorphism border-white/20">
              <ExternalLink className="mr-2 h-4 w-4" />
              Open Video
            </Button>
          </div>
          
          {searchQuery && (
            <div className="text-sm text-muted-foreground">
              {totalMatches} matches found
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}

================
File: client/src/components/ui/accordion.tsx
================
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }

================
File: client/src/components/ui/alert-dialog.tsx
================
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

================
File: client/src/components/ui/alert.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }

================
File: client/src/components/ui/aspect-ratio.tsx
================
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }

================
File: client/src/components/ui/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

================
File: client/src/components/ui/badge.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

================
File: client/src/components/ui/breadcrumb.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}

================
File: client/src/components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: client/src/components/ui/calendar.tsx
================
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }

================
File: client/src/components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: client/src/components/ui/carousel.tsx
================
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}

================
File: client/src/components/ui/chart.tsx
================
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item?.dataKey || item?.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}

================
File: client/src/components/ui/checkbox.tsx
================
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

================
File: client/src/components/ui/collapsible.tsx
================
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }

================
File: client/src/components/ui/command.tsx
================
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}

================
File: client/src/components/ui/context-menu.tsx
================
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 max-h-[--radix-context-menu-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}

================
File: client/src/components/ui/dialog.tsx
================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

================
File: client/src/components/ui/drawer.tsx
================
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}

================
File: client/src/components/ui/dropdown-menu.tsx
================
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

================
File: client/src/components/ui/form.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

================
File: client/src/components/ui/hover-card.tsx
================
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-hover-card-content-transform-origin]",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }

================
File: client/src/components/ui/input-otp.tsx
================
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }

================
File: client/src/components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

================
File: client/src/components/ui/label.tsx
================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

================
File: client/src/components/ui/menubar.tsx
================
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return <MenubarPrimitive.RadioGroup {...props} />
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}

================
File: client/src/components/ui/navigation-menu.tsx
================
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}

================
File: client/src/components/ui/notification-bell.tsx
================
import React from "react";
import { Bell, CheckCircle, Trash2, Info, AlertCircle, AlertTriangle } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useNotifications, Notification } from "@/lib/notification-context";
import { Link } from "wouter";

export function NotificationBell() {
  const { notifications, unreadCount, markAsRead, markAllAsRead, removeNotification, clearAllNotifications } = useNotifications();

  // Get formatted time (e.g., "2 hours ago", "Yesterday", etc.)
  const getFormattedTime = (timestamp: number) => {
    const now = Date.now();
    const diff = now - timestamp;
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (minutes < 1) return "Just now";
    if (minutes < 60) return `${minutes} ${minutes === 1 ? "minute" : "minutes"} ago`;
    if (hours < 24) return `${hours} ${hours === 1 ? "hour" : "hours"} ago`;
    if (days < 7) return `${days} ${days === 1 ? "day" : "days"} ago`;
    
    // For older notifications, show the date
    return new Date(timestamp).toLocaleDateString();
  };

  // Get icon based on notification type
  const getNotificationIcon = (type: Notification["type"]) => {
    switch (type) {
      case "success":
        return <CheckCircle className="h-4 w-4 text-emerald-500" />;
      case "warning":
        return <AlertTriangle className="h-4 w-4 text-amber-500" />;
      case "error":
        return <AlertCircle className="h-4 w-4 text-red-500" />;
      case "info":
      default:
        return <Info className="h-4 w-4 text-blue-500" />;
    }
  };

  // Handle notification click - mark as read and follow link if present
  const handleNotificationClick = (notification: Notification) => {
    if (!notification.read) {
      markAsRead(notification.id);
    }
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="ghost"
          size="sm"
          className="relative glassmorphism border border-white/10 hover:bg-white/20"
          aria-label="View notifications"
        >
          <Bell className="w-5 h-5" />
          {unreadCount > 0 && (
            <span className="absolute -top-1 -right-1 flex h-5 w-5 items-center justify-center rounded-full bg-primary text-xs text-white">
              {unreadCount > 9 ? "9+" : unreadCount}
            </span>
          )}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-80 max-h-[70vh] overflow-y-auto glassmorphism border-white/10">
        <div className="flex items-center justify-between p-2">
          <DropdownMenuLabel>Notifications</DropdownMenuLabel>
          <div className="flex gap-2">
            {unreadCount > 0 && (
              <Button variant="ghost" size="sm" onClick={markAllAsRead}>
                Mark all as read
              </Button>
            )}
            {notifications.length > 0 && (
              <Button variant="ghost" size="sm" onClick={clearAllNotifications} aria-label="Clear all notifications">
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>
        <DropdownMenuSeparator />
        
        {notifications.length === 0 ? (
          <div className="py-6 text-center text-muted-foreground">
            <Bell className="h-8 w-8 mx-auto mb-2 opacity-30" />
            <p>No notifications</p>
          </div>
        ) : (
          notifications.map((notification) => (
            <div key={notification.id}>
              <DropdownMenuItem
                className={`p-3 cursor-pointer ${!notification.read ? 'bg-muted/20' : ''}`}
                onClick={() => handleNotificationClick(notification)}
              >
                <div className="flex gap-2">
                  <div className="flex-shrink-0 mt-1">
                    {getNotificationIcon(notification.type)}
                  </div>
                  <div className="flex-grow">
                    <div className="flex justify-between">
                      <p className="font-medium">{notification.title}</p>
                      <button 
                        onClick={(e) => {
                          e.stopPropagation();
                          removeNotification(notification.id);
                        }}
                        className="opacity-50 hover:opacity-100"
                        aria-label="Delete notification"
                      >
                        <Trash2 className="h-3 w-3" />
                      </button>
                    </div>
                    <p className="text-sm text-muted-foreground">{notification.message}</p>
                    <div className="flex justify-between mt-1">
                      <span className="text-xs text-muted-foreground">
                        {getFormattedTime(notification.timestamp)}
                      </span>
                      {notification.link && (
                        <Link href={notification.link}>
                          <span className="text-xs text-primary hover:underline">View</span>
                        </Link>
                      )}
                    </div>
                  </div>
                </div>
              </DropdownMenuItem>
              <DropdownMenuSeparator />
            </div>
          ))
        )}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

================
File: client/src/components/ui/pagination.tsx
================
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}

================
File: client/src/components/ui/popover.tsx
================
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }

================
File: client/src/components/ui/progress.tsx
================
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-2 w-full overflow-hidden rounded-full bg-gray-100 dark:bg-gray-800",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-gradient-to-r from-purple-500 to-blue-500 transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

================
File: client/src/components/ui/radio-group.tsx
================
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }

================
File: client/src/components/ui/resizable.tsx
================
"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }

================
File: client/src/components/ui/scroll-area.tsx
================
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

================
File: client/src/components/ui/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

================
File: client/src/components/ui/separator.tsx
================
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

================
File: client/src/components/ui/sheet.tsx
================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

================
File: client/src/components/ui/sidebar.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContextProps>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <SheetHeader className="sr-only">
              <SheetTitle>Sidebar</SheetTitle>
              <SheetDescription>Displays the mobile sidebar.</SheetDescription>
            </SheetHeader>
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden text-sidebar-foreground md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex w-full flex-1 flex-col bg-background",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}

================
File: client/src/components/ui/skeleton.tsx
================
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }

================
File: client/src/components/ui/slider.tsx
================
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }

================
File: client/src/components/ui/stats-card-grid.tsx
================
import { Card, CardContent, CardHeader, CardTitle } from "./card";
import { Play, CheckCircle, Clock, Database, TrendingUp, TrendingDown, Minus, Info, RefreshCw, Maximize2, FileText } from "lucide-react";
import { motion, AnimatePresence, useMotionValue, useTransform, useSpring } from "framer-motion";
import { 
  Tooltip, 
  TooltipContent, 
  TooltipProvider, 
  TooltipTrigger,
  TooltipPortal 
} from "./tooltip";
import { cn } from "@/lib/utils";
import { useState, useEffect } from "react";
import { Button } from "./button";
import { Badge } from "./badge";
import { formatRelativeTime } from "@/lib/utils";

interface StatsData {
  totalEpisodes?: number;
  successRate?: number;
  averageProcessingTime?: string;
  totalWordCount?: string;
  // Historical data for sparklines
  history?: {
    totalEpisodes?: number[];
    successRate?: number[];
    processingTime?: number[];
    wordCount?: number[];
  };
  // Add trend indicators (optional)
  trends?: {
    totalEpisodes?: number;
    successRate?: number;
    processingTime?: number;
    wordCount?: number;
  };
  lastUpdated?: string;
}

interface StatsCardGridProps {
  stats?: StatsData;
  statsLoading: boolean;
  className?: string;
  onRefresh?: () => void;
  colorScheme?: 'default' | 'vibrant' | 'minimal';
}

interface StatCardProps {
  title: string;
  value: string | number;
  loading: boolean;
  icon: React.ReactNode;
  color: string;
  tooltip: string;
  trend?: number;
  historyData?: number[];
  onClick?: () => void;
  expanded?: boolean;
  accentColor?: string;
}

// TextIcon component (for word count)
const TextIcon = FileText;

// Simple sparkline chart component
function SparkLine({ data, color = "rgba(255,255,255,0.5)", height = 20, className }: { data?: number[], color?: string, height?: number, className?: string }) {
  if (!data || data.length < 2) return null;

  const min = Math.min(...data);
  const max = Math.max(...data);
  const range = max - min || 1;
  
  const points = data.map((value, i) => {
    const x = (i / (data.length - 1)) * 100;
    const y = 100 - ((value - min) / range) * 100;
    return `${x},${y}`;
  }).join(' ');

  return (
    <svg 
      viewBox="0 0 100 100" 
      className={cn("w-full overflow-visible", className)} 
      height={height} 
      preserveAspectRatio="none"
    >
      <polyline
        points={points}
        fill="none"
        stroke={color}
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        vectorEffect="non-scaling-stroke"
      />
      {/* Add a highlight for the last point */}
      <circle 
        cx={(data.length - 1) / (data.length - 1) * 100} 
        cy={100 - ((data[data.length - 1] - min) / range) * 100} 
        r="2" 
        fill={color}
      />
    </svg>
  );
}

// Animated counter for numbers
function AnimatedCounter({ value, color }: { value: number, color: string }) {
  const springValue = useSpring(0, { stiffness: 100, damping: 30 });
  
  useEffect(() => {
    springValue.set(value);
  }, [value, springValue]);
  
  return (
    <motion.span className={color}>
      {useTransform(springValue, Math.round)}
    </motion.span>
  );
}

function StatCard({ 
  title, 
  value, 
  loading, 
  icon, 
  color, 
  tooltip, 
  trend, 
  historyData, 
  onClick,
  expanded,
  accentColor = "rgba(255,255,255,0.2)" 
}: StatCardProps) {
  // Determine trend icon and color
  const getTrendIcon = () => {
    if (trend === undefined) return null;
    if (trend > 0) return <TrendingUp className="h-4 w-4 text-emerald-400" />;
    if (trend < 0) return <TrendingDown className="h-4 w-4 text-red-400" />;
    return <Minus className="h-4 w-4 text-gray-400" />;
  };
  
  // Determine trend text and add "since last period" context
  const getTrendText = () => {
    if (trend === undefined) return "";
    if (trend > 0) return `+${trend}% since last period`;
    if (trend < 0) return `${trend}% since last period`;
    return "No change since last period";
  };

  // Handle mouse interaction for card tilt effect
  const rotateX = useMotionValue(0);
  const rotateY = useMotionValue(0);
  
  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    if (loading) return;
    
    const card = e.currentTarget;
    const rect = card.getBoundingClientRect();
    
    // Calculate the center of the card
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    // Calculate the mouse position relative to the center
    const mouseX = e.clientX - centerX;
    const mouseY = e.clientY - centerY;
    
    // Calculate the rotation values with a sensitivity factor
    const sensitivity = 0.01;
    rotateX.set(-mouseY * sensitivity);
    rotateY.set(mouseX * sensitivity);
  };

  const handleMouseLeave = () => {
    // Animate back to the initial position
    rotateX.set(0);
    rotateY.set(0);
  };

  // Skeleton loading state variants
  const skeletonVariants = {
    loading: {
      opacity: [0.3, 0.6, 0.3],
      transition: {
        repeat: Infinity,
        duration: 1.5
      }
    },
    loaded: {
      opacity: 1
    }
  };
  
  return (
    <motion.div
      onClick={onClick}
      style={{ 
        rotateX, 
        rotateY, 
        transformStyle: "preserve-3d",
        perspective: 1000
      }}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onMouseMove={handleMouseMove}
      onMouseLeave={handleMouseLeave}
      className={cn(
        "cursor-pointer transition-all duration-200",
        onClick && "cursor-pointer"
      )}
    >
      <Card className={cn(
        "glassmorphism border-white/10 overflow-hidden relative group hover:bg-white/5 transition-all duration-200 hover:shadow-lg",
        "h-full"
      )}>
        {/* Pulse gradient overlay during loading */}
        {loading && (
          <motion.div 
            className="absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent" 
            animate={{
              x: ["0%", "100%"],
            }}
            transition={{
              repeat: Infinity,
              duration: 1.5,
              ease: "linear"
            }}
          />
        )}
        
        {/* Accent color top border */}
        <div 
          className="absolute top-0 left-0 right-0 h-1 transform origin-left transition-all duration-300 group-hover:scale-x-100"
          style={{ backgroundColor: accentColor }}
        />
        
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <TooltipProvider>
            <Tooltip delayDuration={300}>
              <TooltipTrigger asChild>
                <CardTitle className="text-sm font-medium text-muted-foreground cursor-help group-hover:text-white transition-colors flex items-center gap-1.5">
                  {title}
                  <Info className="h-3 w-3 opacity-50 group-hover:opacity-100" />
                </CardTitle>
              </TooltipTrigger>
              <TooltipPortal>
                <TooltipContent 
                  side="top"
                  align="center"
                  sideOffset={8} 
                  className="z-[100] max-w-xs w-fit p-3 bg-black/90 backdrop-blur-sm border border-white/10 text-white shadow-lg rounded-lg"
                  avoidCollisions
                  collisionPadding={20}
                >
                  <p className="text-sm">{tooltip}</p>
                  {trend !== undefined && (
                    <Badge variant="outline" className="mt-2 text-xs">
                      {getTrendText()}
                    </Badge>
                  )}
                </TooltipContent>
              </TooltipPortal>
            </Tooltip>
          </TooltipProvider>
          <div className="transition-transform group-hover:scale-110 group-hover:rotate-12">
            {icon}
          </div>
        </CardHeader>
        
        <CardContent className="relative">
          <AnimatePresence mode="wait">
            {loading ? (
              <motion.div
                key="loading"
                variants={skeletonVariants}
                initial="loaded"
                animate="loading"
                className="h-8 w-1/2 bg-white/10 rounded-md"
              />
            ) : (
              <motion.div
                key="content"
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
                transition={{ duration: 0.3 }}
                className={cn("text-2xl font-bold", color)}
              >
                {typeof value === 'number' ? (
                  <AnimatedCounter value={value} color={color} />
                ) : (
                  value
                )}
              </motion.div>
            )}
          </AnimatePresence>
          
          {/* Sparkline chart */}
          {!loading && historyData && historyData.length > 1 && (
            <motion.div 
              className="mt-2"
              initial={{ opacity: 0 }}
              animate={{ opacity: 0.7 }}
              whileHover={{ opacity: 1 }}
            >
              <SparkLine 
                data={historyData} 
                color={accentColor}
                height={20}
              />
            </motion.div>
          )}
          
          {/* Trend indicator */}
          {!loading && trend !== undefined && (
            <motion.div 
              initial={{ opacity: 0, scale: 0.8 }}
              animate={{ opacity: 1, scale: 1 }}
              transition={{ delay: 0.2 }}
              className="absolute bottom-1 right-1 text-xs flex items-center gap-1 opacity-70 group-hover:opacity-100 transition-opacity"
            >
              {getTrendIcon()}
              <span className={cn(
                trend > 0 ? "text-emerald-400" : trend < 0 ? "text-red-400" : "text-gray-400"
              )}>
                {trend > 0 ? `+${trend}%` : `${trend}%`}
              </span>
            </motion.div>
          )}
          
          {/* Expand button for detailed view */}
          {!loading && onClick && (
            <motion.div 
              className="absolute top-0 right-0 p-1 opacity-0 group-hover:opacity-100 transition-opacity"
              initial={{ opacity: 0 }}
              animate={{ opacity: expanded ? 1 : 0 }}
              whileHover={{ opacity: 1 }}
            >
              <Maximize2 className="h-3.5 w-3.5 text-white/50 hover:text-white" />
            </motion.div>
          )}
        </CardContent>
      </Card>
    </motion.div>
  );
}

export function StatsCardGrid({ stats, statsLoading, className, onRefresh, colorScheme = 'default' }: StatsCardGridProps) {
  const [expanded, setExpanded] = useState<string | null>(null);
  const [fadeIn, setFadeIn] = useState(false);
  
  // Get color scheme based on the selected theme
  const getColorScheme = () => {
    switch (colorScheme) {
      case 'vibrant':
        return {
          totalEpisodes: { text: 'text-fuchsia-400', accent: 'rgba(232,121,249,0.3)' },
          processingTime: { text: 'text-cyan-400', accent: 'rgba(34,211,238,0.3)' },
          wordCount: { text: 'text-amber-400', accent: 'rgba(251,191,36,0.3)' },
        };
      case 'minimal':
        return {
          totalEpisodes: { text: 'text-white', accent: 'rgba(255,255,255,0.3)' },
          processingTime: { text: 'text-white', accent: 'rgba(255,255,255,0.3)' },
          wordCount: { text: 'text-white', accent: 'rgba(255,255,255,0.3)' },
        };
      default:
        return {
          totalEpisodes: { text: 'text-primary', accent: 'rgba(147,197,253,0.3)' },
          processingTime: { text: 'text-purple-400', accent: 'rgba(192,132,252,0.3)' },
          wordCount: { text: 'text-amber-400', accent: 'rgba(251,191,36,0.3)' },
        };
    }
  };
  
  const colors = getColorScheme();
  
  const formatSuccessRate = (rate?: number) => {
    if (rate === undefined) return "100%";
    return `${Math.round(rate)}%`;
  };
  
  const formatWordCountValue = (wordCount?: string) => {
    if (!wordCount) return "0";
    return wordCount;
  };
  
  useEffect(() => {
    // Trigger fade-in animation after component mounts
    const timer = setTimeout(() => setFadeIn(true), 100);
    return () => clearTimeout(timer);
  }, []);
  
  // Format relative time for last updated
  const getLastUpdatedText = () => {
    if (!stats?.lastUpdated) return "Never updated";
    return formatRelativeTime(stats.lastUpdated);
  };
  
  const handleCardClick = (statType: string) => {
    if (expanded === statType) {
      setExpanded(null);
    } else {
      setExpanded(statType);
    }
  };
  
  // Add a title and description to the stats section
  return (
    <motion.section
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: fadeIn ? 1 : 0, y: fadeIn ? 0 : 20 }}
      transition={{ duration: 0.5, staggerChildren: 0.1 }}
      className={cn("space-y-4", className)}
    >
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold group flex items-center">
            System Performance
            <span className="ml-2 opacity-0 group-hover:opacity-100 transition-opacity text-xs text-muted-foreground">
              {stats?.lastUpdated && !statsLoading && `Last updated: ${getLastUpdatedText()}`}
            </span>
          </h2>
          <p className="text-sm text-muted-foreground mt-1">Overview of system metrics and performance indicators</p>
        </div>
        
        {onRefresh && (
          <Button 
            size="sm" 
            variant="ghost" 
            onClick={onRefresh}
            disabled={statsLoading}
            className="group"
          >
            <RefreshCw className={cn(
              "h-4 w-4 mr-2 transition-all",
              statsLoading ? "animate-spin" : "group-hover:animate-spin-once"
            )} />
            {statsLoading ? "Refreshing..." : "Refresh"}
          </Button>
        )}
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <StatCard
          title="Total Episodes"
          value={stats?.totalEpisodes || 0}
          loading={statsLoading}
          icon={<Play className={cn("h-4 w-4", colors.totalEpisodes.text)} />}
          color={colors.totalEpisodes.text}
          tooltip="Total number of episodes processed by the system"
          trend={stats?.trends?.totalEpisodes}
          historyData={stats?.history?.totalEpisodes}
          onClick={() => handleCardClick('episodes')}
          expanded={expanded === 'episodes'}
          accentColor={colors.totalEpisodes.accent}
        />

        <StatCard
          title="Avg Processing Time"
          value={stats?.averageProcessingTime || "0min"}
          loading={statsLoading}
          icon={<Clock className={cn("h-4 w-4", colors.processingTime.text)} />}
          color={colors.processingTime.text}
          tooltip="Average time to process an episode"
          trend={stats?.trends?.processingTime}
          historyData={stats?.history?.processingTime}
          onClick={() => handleCardClick('processing')}
          expanded={expanded === 'processing'}
          accentColor={colors.processingTime.accent}
        />

        <StatCard
          title="Total Word Count"
          value={formatWordCountValue(stats?.totalWordCount)}
          loading={statsLoading}
          icon={<TextIcon className={cn("h-4 w-4", colors.wordCount.text)} />}
          color={colors.wordCount.text}
          tooltip="Total number of words across all transcripts"
          trend={stats?.trends?.wordCount}
          historyData={stats?.history?.wordCount}
          onClick={() => handleCardClick('wordcount')}
          expanded={expanded === 'wordcount'}
          accentColor={colors.wordCount.accent}
        />
      </div>
      
      {/* Add keyboard accessibility instructions */}
      <div className="text-xs text-muted-foreground mt-2 opacity-0 hover:opacity-70 transition-opacity">
        Tip: Click cards for details. Press Tab to navigate, Enter to select.
      </div>
    </motion.section>
  );
}

// Add this to your global CSS or create a utility class
// .animate-spin-once {
//   animation: spin 1s linear;
// }
// .animate-pulse-slow {
//   animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
// }

================
File: client/src/components/ui/switch.tsx
================
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

================
File: client/src/components/ui/table.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

================
File: client/src/components/ui/tabs.tsx
================
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: client/src/components/ui/textarea.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

================
File: client/src/components/ui/toast.tsx
================
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

================
File: client/src/components/ui/toaster.tsx
================
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

================
File: client/src/components/ui/toggle-group.tsx
================
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }

================
File: client/src/components/ui/toggle.tsx
================
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }

================
File: client/src/components/ui/tooltip.tsx
================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipPortal = TooltipPrimitive.Portal

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider, TooltipPortal }

================
File: client/src/hooks/use-admin-auth.ts
================
import { useState, useEffect } from 'react';
import { adminApi } from '@/lib/api';
import { useToast } from './use-toast';
import { useNavigate } from 'react-router-dom';

export function useAdminAuth() {
  const [isAuthenticated, setIsAuthenticated] = useState<boolean | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const { toast } = useToast();
  const navigate = useNavigate();
  
  // Check authentication status on mount
  useEffect(() => {
    const checkAuth = async () => {
      setIsLoading(true);
      try {
        const { isAuthenticated } = await adminApi.checkAuth();
        setIsAuthenticated(isAuthenticated);
      } catch (error) {
        setIsAuthenticated(false);
      } finally {
        setIsLoading(false);
      }
    };
    
    checkAuth();
  }, []);
  
  // Login function
  const login = async (username: string, password: string) => {
    setIsLoading(true);
    try {
      await adminApi.login(username, password);
      setIsAuthenticated(true);
      toast({
        title: "Login Successful",
        description: "You are now logged in as admin",
      });
      return true;
    } catch (error: any) {
      setIsAuthenticated(false);
      toast({
        title: "Login Failed",
        description: error.message || "Invalid credentials",
        variant: "destructive",
      });
      return false;
    } finally {
      setIsLoading(false);
    }
  };
  
  // Logout function
  const logout = async () => {
    setIsLoading(true);
    try {
      await adminApi.logout();
      setIsAuthenticated(false);
      toast({
        title: "Logged Out",
        description: "You have been logged out successfully",
      });
      navigate('/admin/login');
    } catch (error) {
      toast({
        title: "Logout Failed",
        description: "There was an issue logging out",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };
  
  return {
    isAuthenticated,
    isLoading,
    login,
    logout,
  };
}

================
File: client/src/hooks/use-app-updates.ts
================
import { useEffect } from 'react';
import { useNotifications } from '@/lib/notification-context';

// App version for checking updates
const APP_VERSION = '1.0.0';
const APP_VERSION_KEY = 'podster_app_version';

// Define list of updates
const APP_UPDATES = [
  {
    version: '1.0.0',
    updates: [
      {
        title: 'Welcome to Podster',
        message: 'Your AI-powered podcast transcript analysis platform is ready to use.',
        type: 'info' as const,
        link: '/'
      },
      {
        title: 'New Feature: Notifications',
        message: 'Stay updated with the latest application changes and features.',
        type: 'success' as const,
        link: null
      },
      {
        title: 'Get Started',
        message: 'Start by adding a podcast episode to extract and analyze.',
        type: 'info' as const,
        link: '/add-episode'
      }
    ]
  },
  // Add future app versions and their updates here
  // {
  //   version: '1.0.1',
  //   updates: [...]
  // }
];

export function useAppUpdates() {
  const { addNotification } = useNotifications();

  useEffect(() => {
    // Get the last seen app version from local storage
    const lastSeenVersion = localStorage.getItem(APP_VERSION_KEY) || '0.0.0';
    
    // If this is the first time or there's a version update
    if (lastSeenVersion !== APP_VERSION) {
      // Find all updates that are newer than the last seen version
      const newUpdates = APP_UPDATES.filter(update => {
        // Simple semver comparison (only works for basic version numbering)
        return compareVersions(update.version, lastSeenVersion) > 0;
      });
      
      // Add notifications for all new updates
      newUpdates.forEach(update => {
        update.updates.forEach(notification => {
          addNotification({
            title: notification.title,
            message: notification.message,
            type: notification.type,
            link: notification.link || undefined
          });
        });
      });
      
      // Update the last seen version
      localStorage.setItem(APP_VERSION_KEY, APP_VERSION);
    }
  }, [addNotification]);

  // Function to add a custom update notification
  const addAppUpdate = (update: {
    title: string;
    message: string;
    type: 'info' | 'success' | 'warning' | 'error';
    link?: string;
  }) => {
    addNotification(update);
  };

  return { addAppUpdate };
}

// Simple version comparison function
function compareVersions(v1: string, v2: string): number {
  const parts1 = v1.split('.').map(Number);
  const parts2 = v2.split('.').map(Number);
  
  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
    const part1 = parts1[i] || 0;
    const part2 = parts2[i] || 0;
    
    if (part1 > part2) return 1;
    if (part1 < part2) return -1;
  }
  
  return 0;
}

================
File: client/src/hooks/use-auth.ts
================
import { useState, useEffect } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { authApi, usersApi } from "@/lib/api";
import type { User, InsertUser } from "@shared/schema";

interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
}

export function useAuth() {
  const [authState, setAuthState] = useState<AuthState>({
    user: null,
    token: null,
    isAuthenticated: false,
  });

  useEffect(() => {
    // Check for stored auth state on mount
    const storedToken = localStorage.getItem("auth_token");
    const storedUser = localStorage.getItem("auth_user");
    
    if (storedToken && storedUser) {
      try {
        setAuthState({
          user: JSON.parse(storedUser),
          token: storedToken,
          isAuthenticated: true,
        });
      } catch (error) {
        // Clear invalid stored data
        localStorage.removeItem("auth_token");
        localStorage.removeItem("auth_user");
      }
    }
  }, []);

  const loginMutation = useMutation({
    mutationFn: ({ username, password }: { username: string; password: string }) =>
      authApi.login(username, password),
    onSuccess: (data) => {
      const newAuthState = {
        user: data.user,
        token: data.token,
        isAuthenticated: true,
      };
      
      setAuthState(newAuthState);
      localStorage.setItem("auth_token", data.token);
      localStorage.setItem("auth_user", JSON.stringify(data.user));
    },
  });

  const logout = () => {
    setAuthState({
      user: null,
      token: null,
      isAuthenticated: false,
    });
    localStorage.removeItem("auth_token");
    localStorage.removeItem("auth_user");
  };

  return {
    ...authState,
    login: loginMutation.mutate,
    logout,
    isLoggingIn: loginMutation.isPending,
    loginError: loginMutation.error,
  };
}

export function useUsers() {
  return useQuery({
    queryKey: ["/api/admin/users"],
    queryFn: usersApi.getAll,
  });
}

export function useCreateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (user: InsertUser) => usersApi.create(user),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/admin/users"] });
    },
  });
}

export function useDeleteUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (id: number) => usersApi.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/admin/users"] });
    },
  });
}

export function useChangePassword() {
  return useMutation({
    mutationFn: ({ userId, currentPassword, newPassword }: {
      userId: number;
      currentPassword: string;
      newPassword: string;
    }) => usersApi.changePassword(userId, currentPassword, newPassword),
  });
}

================
File: client/src/hooks/use-episode-notifications.ts
================
import { useEffect, useRef } from 'react';
import { useNotifications } from '@/lib/notification-context';
import { useRecentEpisodes } from '@/hooks/use-episodes';
import type { Episode } from '@shared/schema';

export function useEpisodeNotifications() {
  const { addNotification } = useNotifications();
  const { data: episodes } = useRecentEpisodes();
  
  // Keep track of the previously seen episodes
  const previousEpisodesRef = useRef<Episode[]>([]);
  
  useEffect(() => {
    if (!episodes) return;
    
    const prevEpisodes = previousEpisodesRef.current;
    
    // Find newly added episodes (not in previous list)
    const newEpisodes = episodes.filter(
      episode => !prevEpisodes.some(prev => prev.id === episode.id)
    );
    
    // Find episodes with changed status
    const statusChangedEpisodes = episodes.filter(episode => {
      const prevEpisode = prevEpisodes.find(prev => prev.id === episode.id);
      return prevEpisode && prevEpisode.status !== episode.status;
    });
    
    // Notify about new episodes
    newEpisodes.forEach(episode => {
      addNotification({
        title: 'New Episode Added',
        message: `"${episode.title}" has been added for processing`,
        type: 'info',
        link: '/episodes'
      });
    });
    
    // Notify about status changes
    statusChangedEpisodes.forEach(episode => {
      const status = episode.status;
      
      if (status === 'completed') {
        addNotification({
          title: 'Episode Processing Complete',
          message: `"${episode.title}" has been successfully processed`,
          type: 'success',
          link: '/episodes'
        });
      } else if (status === 'failed') {
        addNotification({
          title: 'Episode Processing Failed',
          message: `"${episode.title}" processing failed. Please try again.`,
          type: 'error',
          link: '/episodes'
        });
      }
    });
    
    // Update the reference to current episodes
    previousEpisodesRef.current = episodes;
  }, [episodes, addNotification]);
}

================
File: client/src/hooks/use-episodes.ts
================
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { episodesApi, statsApi } from "@/lib/api";
import type { Episode, InsertEpisode, SystemStats, EpisodeWithProgress } from "@shared/schema";

export function useEpisodes() {
  return useQuery({
    queryKey: ["/api/episodes"],
    queryFn: episodesApi.getAll,
    refetchInterval: 5000, // Refresh every 5 seconds to catch status updates
  });
}

export function useRecentEpisodes() {
  return useQuery({
    queryKey: ["/api/episodes", "recent"],
    queryFn: async () => {
      const episodes = await episodesApi.getAll();
      return episodes.slice(0, 6); // Return only the 6 most recent
    },
    refetchInterval: 2000, // Refresh every 2 seconds for more responsive UI
    staleTime: 0, // Always consider data stale
    refetchOnMount: 'always', // Always refetch when component mounts
  });
}

export function useEpisode(id: number) {
  return useQuery({
    queryKey: ["/api/episodes", id],
    queryFn: () => episodesApi.getById(id),
    enabled: !!id,
  });
}

export function useCreateEpisode() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (episode: InsertEpisode) => episodesApi.create(episode),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/episodes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/stats"] });
    },
  });
}

export function useDeleteEpisode() {
  const queryClient = useQueryClient();
  
  return useMutation({
    // Use a more specific mutation key to avoid conflicts
    mutationKey: ['deleteEpisode'],
    
    mutationFn: async (id: number) => {
      try {
        const response = await episodesApi.delete(id);
        return response;
      } catch (error: any) {
        // Extract the error message from the API response if available
        const errorData = error.response?.data;
        throw new Error(errorData?.message || errorData?.error || 'Failed to delete episode');
      }
    },
    
    onSuccess: () => {
      // Only invalidate queries on success
      queryClient.invalidateQueries({ queryKey: ["/api/episodes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/stats"] });
    },
    
    // Only retry once to avoid multiple error notifications
    retry: 0
  });
}

export function useUpdateTranscript() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, transcript }: { id: number; transcript: string }) => 
      episodesApi.updateTranscript(id, transcript),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ["/api/episodes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/episodes", variables.id] });
    },
  });
}

export function useProcessingStatus(episodeId: number) {
  return useQuery({
    queryKey: ["/api/processing-status", episodeId],
    queryFn: () => episodesApi.getProcessingStatus(episodeId),
    enabled: !!episodeId,
    refetchInterval: (query) => {
      // Poll every 500ms for real-time updates when processing
      if (query.state.data?.status === "processing") {
        return 500;
      }
      // Continue polling for a few seconds after completion to show final state
      if (query.state.data?.status === "completed" || query.state.data?.status === "failed") {
        return 3000;
      }
      return false;
    },
    staleTime: 0, // Always fetch fresh data
    gcTime: 0, // Don't cache old data
  });
}

export function useProcessEpisode() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, options }: { id: number; options?: { generateSummary?: boolean; extractTopics?: boolean } }) => 
      episodesApi.process(id, options),
    onSuccess: (_, variables) => {
      // Invalidate all necessary queries to ensure UI updates
      queryClient.invalidateQueries({ queryKey: ["/api/episodes"] }); // Invalidate all episodes
      queryClient.invalidateQueries({ queryKey: ["/api/episodes", variables.id] }); // Invalidate specific episode
      queryClient.invalidateQueries({ queryKey: ["/api/episodes", "recent"] }); // Invalidate recent episodes
      queryClient.invalidateQueries({ queryKey: ["/api/processing-status", variables.id] }); // Invalidate processing status
      queryClient.invalidateQueries({ queryKey: ["/api/stats"] }); // Invalidate stats
      
      // Force a refetch of recent episodes immediately
      queryClient.refetchQueries({ queryKey: ["/api/episodes", "recent"] });
    },
  });
}

export function useSystemStats() {
  return useQuery({
    queryKey: ["/api/stats"],
    queryFn: statsApi.getSystemStats,
    refetchInterval: 5000, // Refresh more frequently to catch updates
    staleTime: 0, // Always consider data stale
    refetchOnMount: 'always', // Always refetch when component mounts
  });
}

export function useBatchProcess() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ urls, extractionMethod }: { urls: string[]; extractionMethod: string }) => 
      episodesApi.batchProcess(urls, extractionMethod),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/episodes"] });
      queryClient.invalidateQueries({ queryKey: ["/api/stats"] });
    },
  });
}

================
File: client/src/hooks/use-mobile.tsx
================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

================
File: client/src/hooks/use-search.ts
================
import { useMutation, useQuery } from "@tanstack/react-query";
import { searchApi } from "@/lib/api";
import type { SearchRequestPayload } from "@/types";
import type { SearchResult } from "@shared/schema";

export function useSearch() {
  return useMutation({
    mutationFn: (payload: SearchRequestPayload) => searchApi.search(payload),
  });
}

export function useRecentSearches(userId?: number) {
  return useQuery({
    queryKey: ["/api/search", "recent", userId],
    queryFn: async () => {
      // This would need a backend endpoint for recent searches
      // For now, return empty array
      return [];
    },
    enabled: !!userId,
  });
}

================
File: client/src/hooks/use-toast.ts
================
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: client/src/hooks/useSystemStats.ts
================
import { useState, useEffect, useCallback } from 'react';
import axios from 'axios';

// Define the stats data structure
export interface StatsData {
  totalEpisodes?: number;
  successRate?: number;
  averageProcessingTime?: string;
  totalWordCount?: string;
  // Historical data for sparklines
  history?: {
    totalEpisodes?: number[];
    successRate?: number[];
    processingTime?: number[];
    wordCount?: number[];
  };
  // Add trend indicators
  trends?: {
    totalEpisodes?: number;
    successRate?: number;
    processingTime?: number;
    wordCount?: number;
  };
  lastUpdated?: string;
}

/**
 * Custom hook to fetch and manage system statistics
 * 
 * @param refreshInterval - Interval in ms to auto-refresh stats (0 to disable)
 * @param mockData - If true, returns mock data instead of making API calls (for development)
 */
export function useSystemStats(refreshInterval = 0, mockData = false) {
  const [stats, setStats] = useState<StatsData | undefined>(undefined);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // Mock data generator for development and testing
  const generateMockData = useCallback((): StatsData => {
    // Generate random values
    const totalEpisodes = Math.floor(Math.random() * 50) + 100;
    const successRate = Math.floor(Math.random() * 10) + 90;
    const processingMinutes = Math.floor(Math.random() * 15) + 5;
    const totalWordCount = Math.floor(Math.random() * 500000) + 1000000; // Between 1M and 1.5M words
    
    // Generate realistic trends
    const totalEpisodesTrend = Math.floor(Math.random() * 15) + 1;
    const successRateTrend = Math.floor(Math.random() * 5) - 2;
    const processingTimeTrend = Math.floor(Math.random() * 10) - 5;
    const wordCountTrend = Math.floor(Math.random() * 20) + 5;
    
    // Generate historical data for charts
    const generateHistory = (count: number, baseValue: number, volatility: number) => {
      const history = [baseValue];
      for (let i = 1; i < count; i++) {
        const change = (Math.random() - 0.5) * volatility;
        const newValue = Math.max(0, history[i-1] + change);
        history.push(newValue);
      }
      return history;
    };
    
    // For word count history, make it steadily increasing
    const generateWordCountHistory = (count: number, baseValue: number) => {
      const history = [baseValue * 0.1]; // Start at 10% of current value
      const step = baseValue * 0.9 / count; // Divide remaining 90% into steps
      
      for (let i = 1; i < count; i++) {
        // Add a step plus some random variation
        const randomVariation = (Math.random() * 0.4 + 0.8) * step; // 80%-120% of step
        history.push(history[i-1] + randomVariation);
      }
      
      // Make sure the last value is the current total
      history[count-1] = baseValue;
      
      return history;
    };
    
    return {
      totalEpisodes,
      successRate,
      averageProcessingTime: `${processingMinutes}min`,
      totalWordCount: totalWordCount.toLocaleString(),
      history: {
        totalEpisodes: generateHistory(20, totalEpisodes - 50, 15),
        successRate: generateHistory(20, successRate - 10, 5),
        processingTime: generateHistory(20, processingMinutes - 5, 3),
        wordCount: generateWordCountHistory(20, totalWordCount),
      },
      trends: {
        totalEpisodes: totalEpisodesTrend,
        successRate: successRateTrend,
        processingTime: processingTimeTrend,
        wordCount: wordCountTrend,
      },
      lastUpdated: new Date().toISOString(),
    };
  }, []);
  
  // Fetch stats from API
  const fetchStats = useCallback(async () => {
    if (mockData) {
      setLoading(true);
      // Simulate API delay
      setTimeout(() => {
        setStats(generateMockData());
        setLoading(false);
        setError(null);
      }, 800);
      return;
    }
    
    try {
      setLoading(true);
      const response = await axios.get('/api/stats');
      setStats({
        ...response.data,
        lastUpdated: new Date().toISOString(),
      });
      setError(null);
    } catch (err) {
      setError('Failed to fetch system statistics');
      console.error('Error fetching system stats:', err);
    } finally {
      setLoading(false);
    }
  }, [mockData, generateMockData]);
  
  // Manual refresh function
  const refreshStats = useCallback(() => {
    fetchStats();
  }, [fetchStats]);
  
  // Initial fetch and setup interval if needed
  useEffect(() => {
    fetchStats();
    
    // Set up auto-refresh interval if enabled
    let intervalId: NodeJS.Timeout | null = null;
    if (refreshInterval > 0) {
      intervalId = setInterval(fetchStats, refreshInterval);
    }
    
    // Clean up interval on unmount
    return () => {
      if (intervalId) clearInterval(intervalId);
    };
  }, [fetchStats, refreshInterval]);
  
  return {
    stats,
    loading,
    error,
    refreshStats,
  };
}

================
File: client/src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 222 84% 5%; /* #0F172A */
  --foreground: 210 40% 98%; /* #F8FAFC */
  --muted: 217 32% 17%; /* #1E293B */
  --muted-foreground: 215 20% 65%; /* #94A3B8 */
  --popover: 222 84% 5%; /* #0F172A */
  --popover-foreground: 210 40% 98%; /* #F8FAFC */
  --card: 222 84% 5%; /* #0F172A */
  --card-foreground: 210 40% 98%; /* #F8FAFC */
  --border: 217 32% 17%; /* #1E293B */
  --input: 217 32% 17%; /* #1E293B */
  --primary: 217 91% 60%; /* #3B82F6 */
  --primary-foreground: 222 84% 5%; /* #0F172A */
  --secondary: 217 32% 17%; /* #1E293B */
  --secondary-foreground: 210 40% 98%; /* #F8FAFC */
  --accent: 217 32% 17%; /* #1E293B */
  --accent-foreground: 210 40% 98%; /* #F8FAFC */
  --destructive: 0 84% 60%; /* #EF4444 */
  --destructive-foreground: 210 40% 98%; /* #F8FAFC */
  --ring: 217 91% 60%; /* #3B82F6 */
  --radius: 0.5rem;
  --sidebar-background: 222 84% 5%; /* #0F172A */
  --sidebar-foreground: 210 40% 98%; /* #F8FAFC */
  --sidebar-primary: 217 91% 60%; /* #3B82F6 */
  --sidebar-primary-foreground: 222 84% 5%; /* #0F172A */
  --sidebar-accent: 217 32% 17%; /* #1E293B */
  --sidebar-accent-foreground: 210 40% 98%; /* #F8FAFC */
  --sidebar-border: 217 32% 17%; /* #1E293B */
  --sidebar-ring: 217 91% 60%; /* #3B82F6 */
}

.dark {
  --background: 222 84% 5%; /* #0F172A */
  --foreground: 210 40% 98%; /* #F8FAFC */
  --muted: 217 32% 17%; /* #1E293B */
  --muted-foreground: 215 20% 65%; /* #94A3B8 */
  --popover: 222 84% 5%; /* #0F172A */
  --popover-foreground: 210 40% 98%; /* #F8FAFC */
  --card: 222 84% 5%; /* #0F172A */
  --card-foreground: 210 40% 98%; /* #F8FAFC */
  --border: 217 32% 17%; /* #1E293B */
  --input: 217 32% 17%; /* #1E293B */
  --primary: 217 91% 60%; /* #3B82F6 */
  --primary-foreground: 222 84% 5%; /* #0F172A */
  --secondary: 217 32% 17%; /* #1E293B */
  --secondary-foreground: 210 40% 98%; /* #F8FAFC */
  --accent: 217 32% 17%; /* #1E293B */
  --accent-foreground: 210 40% 98%; /* #F8FAFC */
  --destructive: 0 84% 60%; /* #EF4444 */
  --destructive-foreground: 210 40% 98%; /* #F8FAFC */
  --ring: 217 91% 60%; /* #3B82F6 */
}

@layer base {
  * {
    @apply border-border;
  }

  html {
    @apply dark;
  }

  body {
    @apply font-sans antialiased bg-background text-foreground;
    font-family: 'Inter', system-ui, sans-serif;
  }
}

@layer utilities {
  .glassmorphism {
    background: rgba(255, 255, 255, 0.05);
    -webkit-backdrop-filter: blur(10px);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .text-gradient {
    background: linear-gradient(135deg, hsl(var(--primary)), hsl(272 91% 60%));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .line-clamp-1 {
    display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .line-clamp-3 {
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: hsl(var(--background));
}

::-webkit-scrollbar-thumb {
  background: hsl(var(--muted));
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: hsl(var(--muted-foreground));
}

/* Animation keyframes */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideUp {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes float {
  0%, 100% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-10px);
  }
}

@keyframes shimmer {
  0% {
    background-position: -200px 0;
  }
  100% {
    background-position: 200px 0;
  }
}

.animate-fade-in {
  animation: fadeIn 0.5s ease-in-out;
}

.animate-slide-up {
  animation: slideUp 0.3s ease-out;
}

.animate-float {
  animation: float 3s ease-in-out infinite;
}

/* Loading spinner */
@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.animate-spin {
  animation: spin 1s linear infinite;
}

.animate-spin-once {
  animation: spin 1s linear;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.animate-pulse-slow {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Progress bar animations */
.progress-bar {
  background: linear-gradient(90deg, hsl(var(--primary)), hsl(272 91% 60%));
  background-size: 200px 100%;
  animation: shimmer 2s infinite;
}

/* Hover effects */
.card-hover {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.card-hover:hover {
  transform: translateY(-4px) scale(1.02);
  box-shadow: 0 20px 40px rgba(59, 130, 246, 0.3);
}

/* Method card selection */
.method-card {
  transition: all 0.3s ease;
  cursor: pointer;
}

.method-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 30px rgba(139, 92, 246, 0.4);
}

.method-card.selected {
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(139, 92, 246, 0.2));
  border: 2px solid hsl(var(--primary));
}

/* Navigation item effects */
.nav-item {
  position: relative;
  transition: all 0.3s ease;
}

.nav-item::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 0;
  width: 0;
  height: 2px;
  background: linear-gradient(90deg, hsl(var(--primary)), hsl(272 91% 60%));
  transition: width 0.3s ease;
}

.nav-item.active::after,
.nav-item:hover::after {
  width: 100%;
}

/* Custom mark/highlight styling */
mark {
  background: rgba(245, 158, 11, 0.3);
  color: rgb(252, 211, 77);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

/* Focus styles */
*:focus-visible {
  outline: 2px solid hsl(var(--ring));
  outline-offset: 2px;
}

/* Selection styles */
::selection {
  background: rgba(59, 130, 246, 0.3);
  color: hsl(var(--foreground));
}

================
File: client/src/lib/api.ts
================
import { apiRequest } from "./queryClient";
import type { 
  Episode, 
  InsertEpisode, 
  User, 
  InsertUser,
  SearchResult,
  SystemStats,
  EpisodeWithProgress 
} from "@shared/schema";
import type { SearchRequestPayload } from "@/types";

export const episodesApi = {
  getAll: async (): Promise<Episode[]> => {
    const response = await apiRequest("GET", "/api/episodes");
    return response.json();
  },

  getById: async (id: number): Promise<Episode> => {
    const response = await apiRequest("GET", `/api/episodes/${id}`);
    return response.json();
  },

  getByVideoId: async (videoId: string): Promise<Episode> => {
    const response = await apiRequest("GET", `/api/episodes/${videoId}`);
    return response.json();
  },

  create: async (episode: InsertEpisode): Promise<Episode> => {
    const response = await apiRequest("POST", "/api/episodes", episode);
    return response.json();
  },

  delete: async (id: number): Promise<{ message: string }> => {
    try {
      const response = await apiRequest("DELETE", `/api/episodes/${id}`);
      
      // Only try to parse JSON if status is OK
      if (response.ok) {
        return response.json();
      }
      
      // If we get here, something went wrong but the error might not be in JSON format
      try {
        const error = await response.json();
        throw new Error(error.message || error.error || 'Failed to delete episode');
      } catch (parseError) {
        // If JSON parsing fails, use status text
        throw new Error(`Error ${response.status}: ${response.statusText}`);
      }
    } catch (error: any) {
      // Re-throw the error for the mutation to handle
      if (error.message) {
        throw error;
      }
      throw new Error('Failed to connect to the server');
    }
  },

  updateTranscript: async (id: number, transcript: string): Promise<Episode> => {
    const response = await apiRequest("PUT", `/api/episodes/${id}/transcript`, { transcript });
    return response.json();
  },

  getProcessingStatus: async (id: number): Promise<EpisodeWithProgress> => {
    const response = await apiRequest("GET", `/api/processing-status/${id}`);
    return response.json();
  },

  process: async (id: number, options?: { generateSummary?: boolean; extractTopics?: boolean }): Promise<void> => {
    await apiRequest("POST", `/api/process/${id}`, options);
  },

  batchProcess: async (urls: string[], extractionMethod: string): Promise<any> => {
    const response = await apiRequest("POST", "/api/batch-process", { urls, extractionMethod });
    return response.json();
  }
};

export const searchApi = {
  search: async (payload: SearchRequestPayload): Promise<{ results: SearchResult[]; totalResults: number }> => {
    const response = await apiRequest("POST", "/api/search", payload);
    return response.json();
  }
};

export const statsApi = {
  getSystemStats: async (): Promise<SystemStats> => {
    const response = await apiRequest("GET", "/api/stats");
    return response.json();
  }
};

export const usersApi = {
  getAll: async (): Promise<User[]> => {
    const response = await apiRequest("GET", "/api/admin/users");
    return response.json();
  },

  create: async (user: InsertUser): Promise<User> => {
    const response = await apiRequest("POST", "/api/admin/users", user);
    return response.json();
  },

  delete: async (id: number): Promise<void> => {
    await apiRequest("DELETE", `/api/admin/users/${id}`);
  },

  changePassword: async (userId: number, currentPassword: string, newPassword: string): Promise<void> => {
    await apiRequest("POST", "/api/admin/change_password", {
      userId,
      currentPassword,
      newPassword
    });
  }
};

export const authApi = {
  login: async (username: string, password: string): Promise<{ user: User; token: string }> => {
    const response = await apiRequest("POST", "/api/auth/login", { username, password });
    return response.json();
  }
};

export const enrichmentApi = {
  enrich: async (episodeId: number, generateSummary: boolean, extractTopics: boolean): Promise<Episode> => {
    const response = await apiRequest("POST", "/api/enrich", {
      episodeId,
      generateSummary,
      extractTopics
    });
    return response.json();
  }
};

export const exportApi = {
  exportData: async (format: 'json' | 'csv'): Promise<Blob> => {
    const response = await apiRequest("GET", `/api/export/${format}`);
    return response.blob();
  }
};

export const adminApi = {
  login: async (username: string, password: string): Promise<{ success: boolean }> => {
    const response = await apiRequest("POST", "/api/admin/login", { username, password });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || "Login failed");
    }
    
    return response.json();
  },
  
  logout: async (): Promise<{ success: boolean }> => {
    const response = await apiRequest("POST", "/api/admin/logout");
    return response.json();
  },
  
  checkAuth: async (): Promise<{ isAuthenticated: boolean }> => {
    try {
      const response = await apiRequest("GET", "/api/admin/check-auth");
      
      if (response.ok) {
        return response.json();
      } else {
        return { isAuthenticated: false };
      }
    } catch (error) {
      console.error("Auth check error:", error);
      return { isAuthenticated: false };
    }
  }
};

================
File: client/src/lib/keyword-analyzer.ts
================
// Instead of using OpenAI directly in the browser, we'll call our backend
const API_BASE = "";

export interface KeywordHighlight {
  keyword: string;
  category: 'important' | 'technical' | 'name' | 'concept' | 'action';
  confidence: number;
  positions: Array<{
    start: number;
    end: number;
  }>;
}

export interface AnalysisResult {
  keywords: KeywordHighlight[];
  categories: {
    important: string[];
    technical: string[];
    name: string[];
    concept: string[];
    action: string[];
  };
}

export interface AnalysisProgressCallback {
  (status: string, progress: number): void;
}

// Default timeout of 30 seconds
const DEFAULT_TIMEOUT = 30000;

export async function analyzeKeywords(
  transcript: string, 
  progressCallback?: AnalysisProgressCallback,
  timeout: number = DEFAULT_TIMEOUT
): Promise<AnalysisResult> {
  try {
    // Notify that we're starting
    progressCallback?.('Starting keyword analysis...', 10);
    
    // Create a controller to enable timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    // Start the request
    progressCallback?.('Sending request to server...', 20);
    
    const response = await fetch('/api/analyze-keywords', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ transcript }),
      signal: controller.signal
    });

    // Clear the timeout since we got a response
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      progressCallback?.('Error from server', 0);
      throw new Error(`Failed to analyze keywords: ${response.statusText}`);
    }

    progressCallback?.('Processing results...', 80);
    const result = await response.json();
    
    // Analysis complete
    progressCallback?.('Analysis complete!', 100);
    return result;
  } catch (error) {
    console.error('Error analyzing keywords:', error);
    
    // Check if this was an abort/timeout
    if (error instanceof DOMException && error.name === 'AbortError') {
      progressCallback?.('Analysis timed out. Using simplified analysis.', 90);
      return generateFallbackAnalysis(transcript);
    }
    
    // Other errors
    progressCallback?.('Analysis failed. Using simplified analysis.', 90);
    return generateFallbackAnalysis(transcript);
  }
}

function generateFallbackAnalysis(transcript: string): AnalysisResult {
  // Very basic fallback that just extracts frequent words
  const words = transcript.toLowerCase().match(/\b\w+\b/g) || [];
  const wordCounts = new Map<string, number>();
  
  for (const word of words) {
    if (word.length < 4) continue; // Skip short words
    wordCounts.set(word, (wordCounts.get(word) || 0) + 1);
  }
  
  // Get most frequent words
  const keywords = Array.from(wordCounts.entries())
    .filter(([word, count]) => count > 1)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 15)
    .map(([word, count]) => {
      // Simple categorization
      let category: 'important' | 'technical' | 'name' | 'concept' | 'action' = 'important';
      
      if (/^[A-Z]/.test(word)) {
        category = 'name';
      } else if (/ing$/.test(word)) {
        category = 'action';
      } else if (/tion$|ment$|ity$|ism$/.test(word)) {
        category = 'concept';
      } else if (/ology$|ical$|tech|data|code/.test(word)) {
        category = 'technical';
      }
      
      return {
        keyword: word,
        category,
        confidence: Math.min(0.6, count / 30),
        positions: findAllPositions(transcript, word)
      };
    });
  
  // Create categories
  const categories: AnalysisResult['categories'] = {
    important: [],
    technical: [],
    name: [],
    concept: [],
    action: []
  };
  
  for (const kw of keywords) {
    switch (kw.category) {
      case 'important': categories.important.push(kw.keyword); break;
      case 'technical': categories.technical.push(kw.keyword); break;
      case 'name': categories.name.push(kw.keyword); break;
      case 'concept': categories.concept.push(kw.keyword); break;
      case 'action': categories.action.push(kw.keyword); break;
    }
  }
  
  return { keywords, categories };
}

function findAllPositions(text: string, keyword: string): Array<{start: number, end: number}> {
  const positions: Array<{start: number, end: number}> = [];
  const lowerText = text.toLowerCase();
  const lowerKeyword = keyword.toLowerCase();
  
  let startIndex = 0;
  while (true) {
    const index = lowerText.indexOf(lowerKeyword, startIndex);
    if (index === -1) break;
    
    // Check if this is a whole word match by examining the characters before and after
    const prevChar = index > 0 ? lowerText[index - 1] : ' ';
    const nextChar = index + lowerKeyword.length < lowerText.length 
      ? lowerText[index + lowerKeyword.length] 
      : ' ';
    
    // Word boundary is any non-alphanumeric character
    const isPrevBoundary = /[^a-z0-9]/.test(prevChar);
    const isNextBoundary = /[^a-z0-9]/.test(nextChar);
    
    // Only add if both boundaries are satisfied
    if (isPrevBoundary && isNextBoundary) {
      // Use the exact start and end indices for the keyword
      positions.push({
        start: index,
        end: index + keyword.length
      });
    }
    
    // Move past this occurrence to find the next one
    startIndex = index + 1;
  }
  
  return positions;
}

export function highlightText(text: string, keywords: KeywordHighlight[]): string {
  if (!keywords || keywords.length === 0) return text;
  
  // Create an array of all positions with their categories
  interface HighlightPosition {
    start: number;
    end: number;
    category: string;
    keyword: string;
    confidence: number;
  }
  
  // Collect all positions
  const positions: HighlightPosition[] = [];
  for (const keyword of keywords) {
    for (const position of keyword.positions) {
      // Verify the position
      const actualText = text.substring(position.start, position.end);
      if (actualText.toLowerCase() === keyword.keyword.toLowerCase()) {
        positions.push({
          start: position.start,
          end: position.end,
          category: keyword.category,
          keyword: keyword.keyword,
          confidence: keyword.confidence
        });
      }
    }
  }
  
  // If no valid positions, return original text
  if (positions.length === 0) return text;
  
  // Sort positions by start index
  positions.sort((a, b) => a.start - b.start);
  
  // Handle overlapping highlights - resolve conflicts
  const resolvedPositions: HighlightPosition[] = [];
  for (const pos of positions) {
    // Check if this position overlaps with any previously added position
    let overlaps = false;
    for (const existingPos of resolvedPositions) {
      // Check for overlap
      if (pos.start < existingPos.end && pos.end > existingPos.start) {
        overlaps = true;
        break;
      }
    }
    
    // Only add non-overlapping positions
    if (!overlaps) {
      resolvedPositions.push(pos);
    }
  }
  
  // Build the highlighted text
  let result = '';
  let lastIndex = 0;
  
  for (const pos of resolvedPositions) {
    // Add text before this highlight
    result += text.substring(lastIndex, pos.start);
    
    // Add the highlighted portion
    const colorClass = getCategoryColor(pos.category);
    const confidenceValue = Math.round(pos.confidence * 100);
    const titleText = `${escapeHtml(pos.category)} (${confidenceValue}% confidence)`;
    
    result += `<span class="keyword-highlight ${escapeHtml(colorClass)}" title="${escapeHtml(titleText)}">`;
    result += text.substring(pos.start, pos.end);
    result += '</span>';
    
    // Update lastIndex
    lastIndex = pos.end;
  }
  
  // Add any remaining text
  result += text.substring(lastIndex);
  
  return result;
}

// Helper function to escape HTML special characters
function escapeHtml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

function getCategoryColor(category: string): string {
  switch (category) {
    case 'important':
      return 'bg-yellow-200 dark:bg-yellow-800/50 text-yellow-900 dark:text-yellow-200';
    case 'technical':
      return 'bg-blue-200 dark:bg-blue-800/50 text-blue-900 dark:text-blue-200';
    case 'name':
      return 'bg-green-200 dark:bg-green-800/50 text-green-900 dark:text-green-200';
    case 'concept':
      return 'bg-purple-200 dark:bg-purple-800/50 text-purple-900 dark:text-purple-200';
    case 'action':
      return 'bg-red-200 dark:bg-red-800/50 text-red-900 dark:text-red-200';
    default:
      return 'bg-gray-200 dark:bg-gray-800/50 text-gray-900 dark:text-gray-200';
  }
}

================
File: client/src/lib/notification-context.tsx
================
import React, { createContext, useContext, useState, useEffect } from "react";

// Define the structure of a notification
export interface Notification {
  id: string;
  title: string;
  message: string;
  timestamp: number;
  read: boolean;
  type: "info" | "success" | "warning" | "error";
  link?: string;
}

// Define the context shape
interface NotificationContextType {
  notifications: Notification[];
  unreadCount: number;
  addNotification: (notification: Omit<Notification, "id" | "timestamp" | "read">) => void;
  markAsRead: (id: string) => void;
  markAllAsRead: () => void;
  removeNotification: (id: string) => void;
  clearAllNotifications: () => void;
}

// Create the context with a default value
const NotificationContext = createContext<NotificationContextType | undefined>(undefined);

// Storage key for local storage
const STORAGE_KEY = "podster_notifications";

// Provider component
export function NotificationProvider({ children }: { children: React.ReactNode }) {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  
  // Calculate unread count
  const unreadCount = notifications.filter(n => !n.read).length;
  
  // Load notifications from localStorage on initial render
  useEffect(() => {
    const storedNotifications = localStorage.getItem(STORAGE_KEY);
    if (storedNotifications) {
      try {
        setNotifications(JSON.parse(storedNotifications));
      } catch (error) {
        console.error("Failed to parse stored notifications:", error);
        // If parsing fails, clear the storage
        localStorage.removeItem(STORAGE_KEY);
      }
    }
    
    // Add a default welcome notification if no notifications exist
    else {
      const welcomeNotification: Notification = {
        id: "welcome",
        title: "Welcome to Podster!",
        message: "You'll see application updates and notifications here.",
        timestamp: Date.now(),
        read: false,
        type: "info"
      };
      setNotifications([welcomeNotification]);
    }
  }, []);
  
  // Save to localStorage whenever notifications change
  useEffect(() => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(notifications));
  }, [notifications]);
  
  // Add a new notification
  const addNotification = (notification: Omit<Notification, "id" | "timestamp" | "read">) => {
    const newNotification: Notification = {
      ...notification,
      id: crypto.randomUUID(),
      timestamp: Date.now(),
      read: false
    };
    
    setNotifications(prev => [newNotification, ...prev]);
  };
  
  // Mark a notification as read
  const markAsRead = (id: string) => {
    setNotifications(prev => 
      prev.map(notification => 
        notification.id === id ? { ...notification, read: true } : notification
      )
    );
  };
  
  // Mark all notifications as read
  const markAllAsRead = () => {
    setNotifications(prev => 
      prev.map(notification => ({ ...notification, read: true }))
    );
  };
  
  // Remove a notification
  const removeNotification = (id: string) => {
    setNotifications(prev => prev.filter(notification => notification.id !== id));
  };
  
  // Clear all notifications
  const clearAllNotifications = () => {
    setNotifications([]);
  };
  
  return (
    <NotificationContext.Provider
      value={{
        notifications,
        unreadCount,
        addNotification,
        markAsRead,
        markAllAsRead,
        removeNotification,
        clearAllNotifications
      }}
    >
      {children}
    </NotificationContext.Provider>
  );
}

// Custom hook to use the notification context
export function useNotifications() {
  const context = useContext(NotificationContext);
  if (context === undefined) {
    throw new Error("useNotifications must be used within a NotificationProvider");
  }
  return context;
}

================
File: client/src/lib/queryClient.ts
================
import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    try {
      // Try to parse the error response as JSON
      const errorData = await res.json();
      throw new Error(errorData.message || errorData.error || `${res.status}: ${res.statusText}`);
    } catch (e) {
      // If JSON parsing fails, fall back to status text
      const text = await res.text().catch(() => res.statusText);
      throw new Error(`${res.status}: ${text || res.statusText}`);
    }
  }
}

export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<Response> {
  try {
    const res = await fetch(url, {
      method,
      headers: data ? { "Content-Type": "application/json" } : {},
      body: data ? JSON.stringify(data) : undefined,
      credentials: "include",
    });

    // Don't throw here - just return the response
    // Let the caller decide how to handle errors
    return res;
  } catch (error) {
    // This will only catch network errors
    console.error("Network error:", error);
    throw new Error("Failed to connect to server. Please check your internet connection.");
  }
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    const res = await fetch(queryKey[0] as string, {
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: true,
      staleTime: 30000,
      retry: 1,
    },
    mutations: {
      retry: false,
    },
  },
});

================
File: client/src/lib/utils.ts
================
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

/**
 * Format a date as a relative time string (e.g., "2 hours ago")
 */
export function formatRelativeTime(dateString: string): string {
  try {
    const date = new Date(dateString);
    const now = new Date();
    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);
    
    // Less than a minute
    if (diffInSeconds < 60) {
      return 'Just now';
    }
    
    // Less than an hour
    const diffInMinutes = Math.floor(diffInSeconds / 60);
    if (diffInMinutes < 60) {
      return `${diffInMinutes} ${diffInMinutes === 1 ? 'minute' : 'minutes'} ago`;
    }
    
    // Less than a day
    const diffInHours = Math.floor(diffInMinutes / 60);
    if (diffInHours < 24) {
      return `${diffInHours} ${diffInHours === 1 ? 'hour' : 'hours'} ago`;
    }
    
    // Less than a week
    const diffInDays = Math.floor(diffInHours / 24);
    if (diffInDays < 7) {
      return `${diffInDays} ${diffInDays === 1 ? 'day' : 'days'} ago`;
    }
    
    // Format date as string
    return date.toLocaleDateString();
  } catch (e) {
    return dateString;
  }
}

================
File: client/src/main.tsx
================
import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";

createRoot(document.getElementById("root")!).render(<App />);

================
File: client/src/pages/add-episode.tsx
================
import { useState } from "react";
import { motion } from "framer-motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";
import { useToast } from "@/hooks/use-toast";
import { useCreateEpisode } from "@/hooks/use-episodes";
import ExtractionMethodSelector from "@/components/episodes/extraction-method-selector";
import SimpleProcessingIndicator from "@/components/episodes/simple-processing-indicator";
import BatchProcessDialog from "@/components/episodes/batch-process-dialog";
import { Link, Video, Zap, Layers } from "lucide-react";
import type { ExtractionMethod } from "@/types";

export default function AddEpisode() {
  const [youtubeUrl, setYoutubeUrl] = useState("");
  const [extractionMethod, setExtractionMethod] = useState<ExtractionMethod>("scraping");
  const [generateSummary, setGenerateSummary] = useState(false);
  const [extractTopics, setExtractTopics] = useState(false);
  const [processingEpisodeId, setProcessingEpisodeId] = useState<number | null>(null);
  const [batchDialogOpen, setBatchDialogOpen] = useState(false);
  
  const { toast } = useToast();
  const createEpisodeMutation = useCreateEpisode();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!youtubeUrl) {
      toast({
        title: "Error",
        description: "Please enter a YouTube URL",
        variant: "destructive",
      });
      return;
    }

    try {
      const episode = await createEpisodeMutation.mutateAsync({
        youtubeUrl,
        extractionMethod,
        generateSummary,
        extractTopics,
        userId: 1 // Default user
      });

      setProcessingEpisodeId(episode.id);
      setYoutubeUrl("");
      
      toast({
        title: "Episode Added",
        description: "Your episode has been added to the processing queue.",
      });
    } catch (error: any) {
      toast({
        title: "Error",
        description: error.message || "Failed to add episode",
        variant: "destructive",
      });
    }
  };

  return (
    <div className="max-w-4xl mx-auto space-y-8">
      {/* Header */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="text-center space-y-4"
      >
        <h1 className="text-3xl font-bold">Add New Episode</h1>
        <p className="text-muted-foreground">
          Extract transcripts from YouTube videos using multiple methods
        </p>
      </motion.div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        {/* Main Form */}
        <motion.div
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          className="lg:col-span-2 space-y-6"
        >
          <Card className="glassmorphism border-white/10">
            <CardHeader>
              <CardTitle className="flex items-center">
                <Link className="mr-2 h-5 w-5 text-primary" />
                YouTube URL
              </CardTitle>
            </CardHeader>
            <CardContent>
              <form onSubmit={handleSubmit} className="space-y-6">
                <div className="space-y-2">
                  <Label htmlFor="url">Video URL</Label>
                  <Input
                    id="url"
                    type="url"
                    placeholder="https://www.youtube.com/watch?v=..."
                    value={youtubeUrl}
                    onChange={(e) => setYoutubeUrl(e.target.value)}
                    className="bg-background/50 border-white/20"
                  />
                  <p className="text-sm text-muted-foreground">
                    Enter the YouTube video URL to extract transcript
                  </p>
                </div>

                <ExtractionMethodSelector
                  value={extractionMethod}
                  onChange={setExtractionMethod}
                />

                <div className="space-y-4">
                  <h4 className="text-lg font-semibold">Advanced Options</h4>
                  <div className="space-y-3">
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        id="summary"
                        checked={generateSummary}
                        onCheckedChange={(checked) => setGenerateSummary(checked === true)}
                      />
                      <Label htmlFor="summary" className="text-sm">
                        Generate AI summary
                      </Label>
                    </div>
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        id="topics"
                        checked={extractTopics}
                        onCheckedChange={(checked) => setExtractTopics(checked === true)}
                      />
                      <Label htmlFor="topics" className="text-sm">
                        Extract key topics
                      </Label>
                    </div>
                  </div>
                </div>

                <div className="flex space-x-4">
                  <Button
                    type="submit"
                    disabled={createEpisodeMutation.isPending}
                    className="flex-1 bg-gradient-to-r from-primary to-purple-500 hover:from-primary/90 hover:to-purple-500/90"
                  >
                    <Video className="mr-2 h-4 w-4" />
                    {createEpisodeMutation.isPending ? "Adding..." : "Start Extraction"}
                  </Button>
                  <Button
                    type="button"
                    variant="outline"
                    className="glassmorphism border-white/20"
                    onClick={() => setBatchDialogOpen(true)}
                  >
                    <Layers className="mr-2 h-4 w-4" />
                    Batch Process
                  </Button>
                </div>
              </form>
            </CardContent>
          </Card>
        </motion.div>

        {/* Status Panel */}
        <motion.div
          initial={{ opacity: 0, x: 20 }}
          animate={{ opacity: 1, x: 0 }}
          className="space-y-6"
        >
          {processingEpisodeId && (
            <SimpleProcessingIndicator 
              episodeId={processingEpisodeId}
              onClose={() => setProcessingEpisodeId(null)}
            />
          )}

          {/* Quick Stats */}
          <Card className="glassmorphism border-white/10">
            <CardHeader>
              <CardTitle className="flex items-center text-lg">
                <Zap className="mr-2 h-5 w-5 text-primary" />
                Quick Stats
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <div className="flex justify-between text-sm">
                <span>Queue Position</span>
                <span className="font-mono">#1</span>
              </div>
              <div className="flex justify-between text-sm">
                <span>Estimated Time</span>
                <span className="font-mono">30s</span>
              </div>
              <div className="flex justify-between text-sm">
                <span>Success Rate</span>
                <span className="font-mono text-emerald-400">98.7%</span>
              </div>
            </CardContent>
          </Card>

          {/* Method Comparison */}
          <Card className="glassmorphism border-white/10">
            <CardHeader>
              <CardTitle className="text-lg">Method Comparison</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <div className="flex justify-between items-center">
                  <span className="text-sm">Caption-Based</span>
                  <span className="text-xs bg-blue-500/20 text-blue-400 px-2 py-1 rounded">~30s</span>
                </div>
                <div className="w-full bg-background/30 rounded-full h-1">
                  <div className="bg-blue-500 h-1 rounded-full w-1/4"></div>
                </div>
              </div>
              
              <div className="space-y-2">
                <div className="flex justify-between items-center">
                  <span className="text-sm">Web Scraping</span>
                  <span className="text-xs bg-purple-500/20 text-purple-400 px-2 py-1 rounded">~1-2min</span>
                </div>
                <div className="w-full bg-background/30 rounded-full h-1">
                  <div className="bg-purple-500 h-1 rounded-full w-1/2"></div>
                </div>
              </div>
              
              <div className="space-y-2">
                <div className="flex justify-between items-center">
                  <span className="text-sm">Audio-Based</span>
                  <span className="text-xs bg-emerald-500/20 text-emerald-400 px-2 py-1 rounded">~2-5min</span>
                </div>
                <div className="w-full bg-background/30 rounded-full h-1">
                  <div className="bg-emerald-500 h-1 rounded-full w-full"></div>
                </div>
              </div>
            </CardContent>
          </Card>
        </motion.div>
      </div>

      {/* Batch Processing Dialog */}
      <BatchProcessDialog 
        open={batchDialogOpen}
        onOpenChange={setBatchDialogOpen}
        extractionMethod="scraping" // Always use scraping for batch processing
      />
    </div>
  );
}

================
File: client/src/pages/admin-login.tsx
================
import { useState } from "react";
import { motion } from "framer-motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useAdminAuth } from "@/hooks/use-admin-auth";
import { Navigate } from "react-router-dom";
import { Shield, Lock } from "lucide-react";

export default function AdminLogin() {
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const { login, isAuthenticated, isLoading } = useAdminAuth();

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    await login(username, password);
  };

  // Redirect to admin dashboard if already authenticated
  if (isAuthenticated) {
    return <Navigate to="/admin" replace />;
  }

  return (
    <div className="flex items-center justify-center min-h-screen">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="w-full max-w-md"
      >
        <Card className="glassmorphism border-white/10">
          <CardHeader className="space-y-1 text-center">
            <CardTitle className="text-2xl flex justify-center items-center gap-2">
              <Shield className="h-6 w-6" />
              Admin Login
            </CardTitle>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleLogin} className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="username">Username</Label>
                <Input
                  id="username"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  className="bg-background/50 border-white/20"
                  required
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="password">Password</Label>
                <Input
                  id="password"
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  className="bg-background/50 border-white/20"
                  required
                />
              </div>
              <Button
                type="submit"
                className="w-full bg-primary hover:bg-primary/90"
                disabled={isLoading}
              >
                {isLoading ? (
                  <span className="flex items-center gap-2">
                    <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
                      <circle
                        className="opacity-25"
                        cx="12"
                        cy="12"
                        r="10"
                        stroke="currentColor"
                        strokeWidth="4"
                      ></circle>
                      <path
                        className="opacity-75"
                        fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                      ></path>
                    </svg>
                    Logging in...
                  </span>
                ) : (
                  <span className="flex items-center gap-2">
                    <Lock className="h-4 w-4" />
                    Login
                  </span>
                )}
              </Button>
            </form>
          </CardContent>
        </Card>
      </motion.div>
    </div>
  );
}

================
File: client/src/pages/admin.tsx
================
import { motion } from "framer-motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { useSystemStats } from "@/hooks/use-episodes";
import UserManagement from "@/components/admin/user-management";
import SystemStats from "@/components/admin/system-stats";
import { 
  Settings, 
  Users, 
  Activity, 
  Database, 
  Download, 
  RefreshCw, 
  AlertTriangle,
  BarChart3,
  LogOut
} from "lucide-react";
import { useAdminAuth } from "@/hooks/use-admin-auth";
import { Navigate } from "react-router-dom";
import { useEffect } from "react";

export default function Admin() {
  const { data: stats, isLoading } = useSystemStats();
  const { isAuthenticated, isLoading: authLoading, logout } = useAdminAuth();

  // If authentication is still loading, show nothing
  if (authLoading) {
    return null;
  }

  // If not authenticated, redirect to login
  if (!isAuthenticated) {
    return <Navigate to="/admin/login" replace />;
  }

  return (
    <div className="space-y-8">
      {/* Header */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="flex justify-between items-center"
      >
        <h1 className="text-3xl font-bold">Admin Dashboard</h1>
        <Button
          variant="outline"
          className="flex items-center gap-2"
          onClick={logout}
        >
          <LogOut className="h-4 w-4" />
          Logout
        </Button>
      </motion.div>
      
      <p className="text-muted-foreground">
        Manage users, monitor system performance, and configure settings
      </p>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        {/* Main Content */}
        <div className="lg:col-span-2 space-y-8">
          {/* System Performance */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.1 }}
          >
            <SystemStats />
          </motion.div>

          {/* User Management */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2 }}
          >
            <UserManagement />
          </motion.div>

          {/* Processing Queue */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.3 }}
          >
            <Card className="glassmorphism border-white/10">
              <CardHeader>
                <CardTitle className="flex items-center">
                  <Activity className="mr-2 h-5 w-5" />
                  Processing Queue
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-3">
                  <div className="flex items-center justify-between bg-background/30 rounded-lg p-3">
                    <div className="flex items-center space-x-3">
                      <div className="w-3 h-3 bg-emerald-500 rounded-full animate-pulse"></div>
                      <span>Advanced React Patterns</span>
                    </div>
                    <span className="text-xs text-muted-foreground">Processing... 2:34 remaining</span>
                  </div>
                  
                  <div className="flex items-center justify-between bg-background/30 rounded-lg p-3">
                    <div className="flex items-center space-x-3">
                      <div className="w-3 h-3 bg-amber-500 rounded-full"></div>
                      <span>JavaScript Performance</span>
                    </div>
                    <span className="text-xs text-muted-foreground">Queued</span>
                  </div>

                  <div className="flex items-center justify-between bg-background/30 rounded-lg p-3">
                    <div className="flex items-center space-x-3">
                      <div className="w-3 h-3 bg-blue-500 rounded-full"></div>
                      <span>Machine Learning Basics</span>
                    </div>
                    <span className="text-xs text-muted-foreground">Queued</span>
                  </div>
                </div>
              </CardContent>
            </Card>
          </motion.div>
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Quick Actions */}
          <motion.div
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: 0.1 }}
          >
            <Card className="glassmorphism border-white/10">
              <CardHeader>
                <CardTitle className="text-lg">Quick Actions</CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <Button className="w-full justify-start bg-primary hover:bg-primary/90">
                  <Download className="mr-3 h-4 w-4" />
                  Export Database
                </Button>
                <Button className="w-full justify-start bg-purple-500 hover:bg-purple-600">
                  <Database className="mr-3 h-4 w-4" />
                  Clean Cache
                </Button>
                <Button className="w-full justify-start bg-emerald-500 hover:bg-emerald-600">
                  <RefreshCw className="mr-3 h-4 w-4" />
                  Restart Services
                </Button>
                <Button className="w-full justify-start bg-red-500 hover:bg-red-600">
                  <AlertTriangle className="mr-3 h-4 w-4" />
                  Emergency Stop
                </Button>
              </CardContent>
            </Card>
          </motion.div>

          {/* Recent Activity */}
          <motion.div
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: 0.2 }}
          >
            <Card className="glassmorphism border-white/10">
              <CardHeader>
                <CardTitle className="text-lg">Recent Activity</CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="flex items-center space-x-3 text-sm">
                  <div className="w-2 h-2 bg-emerald-500 rounded-full"></div>
                  <span>Episode processed successfully</span>
                </div>
                <div className="flex items-center space-x-3 text-sm">
                  <div className="w-2 h-2 bg-blue-500 rounded-full"></div>
                  <span>New user registered</span>
                </div>
                <div className="flex items-center space-x-3 text-sm">
                  <div className="w-2 h-2 bg-amber-500 rounded-full"></div>
                  <span>Database backup completed</span>
                </div>
                <div className="flex items-center space-x-3 text-sm">
                  <div className="w-2 h-2 bg-red-500 rounded-full"></div>
                  <span>Processing error logged</span>
                </div>
              </CardContent>
            </Card>
          </motion.div>

          {/* Analytics Summary */}
          <motion.div
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: 0.3 }}
          >
            <Card className="glassmorphism border-white/10">
              <CardHeader>
                <CardTitle className="text-lg flex items-center">
                  <BarChart3 className="mr-2 h-5 w-5" />
                  Analytics
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-3">
                  <div className="flex justify-between items-center">
                    <span className="text-sm text-muted-foreground">Success Rate</span>
                    <span className="font-semibold text-emerald-400">
                      {isLoading ? "..." : `${stats?.successRate || 0}%`}
                    </span>
                  </div>
                  
                  <div className="flex justify-between items-center">
                    <span className="text-sm text-muted-foreground">Daily Processed</span>
                    <span className="font-semibold text-primary">
                      {isLoading ? "..." : stats?.dailyProcessed || 0}
                    </span>
                  </div>
                  
                  <div className="flex justify-between items-center">
                    <span className="text-sm text-muted-foreground">Queue Length</span>
                    <span className="font-semibold text-amber-400">
                      {isLoading ? "..." : stats?.processingQueue || 0}
                    </span>
                  </div>
                </div>
                
                <div className="pt-3 border-t border-white/10">
                  <p className="text-xs text-muted-foreground mb-2">Method Distribution</p>
                  <div className="space-y-2">
                    <div className="flex justify-between text-xs">
                      <span>Web Scraping</span>
                      <span className="text-purple-400">67%</span>
                    </div>
                    <div className="flex justify-between text-xs">
                      <span>Caption-Based</span>
                      <span className="text-blue-400">24%</span>
                    </div>
                    <div className="flex justify-between text-xs">
                      <span>Audio-Based</span>
                      <span className="text-emerald-400">9%</span>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </motion.div>
        </div>
      </div>
    </div>
  );
}

================
File: client/src/pages/dashboard.tsx
================
import { motion } from "framer-motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Link } from "wouter";
import { Play, Clock, CheckCircle, Database, Plus, ArrowRight, Eye, RefreshCw, Settings } from "lucide-react";
import { useRecentEpisodes } from "@/hooks/use-episodes";
import { useSystemStats as useEnhancedSystemStats } from "@/hooks/useSystemStats";
import TranscriptViewer from "@/components/episodes/transcript-viewer";
import { useState, useEffect } from "react";
import type { Episode } from "@shared/schema";
import { useQueryClient } from "@tanstack/react-query";
import { StatsCardGrid } from "@/components/ui/stats-card-grid";
import { useAppUpdates } from "@/hooks/use-app-updates";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

export default function Dashboard() {
  const queryClient = useQueryClient();
  const [selectedEpisode, setSelectedEpisode] = useState<Episode | null>(null);
  const [isTranscriptOpen, setIsTranscriptOpen] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const [colorScheme, setColorScheme] = useState<'default' | 'vibrant' | 'minimal'>('default');
  
  // Use the new system stats hook with real data
  const { stats, loading: statsLoading, refreshStats } = useEnhancedSystemStats(30000, false);
  
  const { data: recentEpisodes, isLoading: episodesLoading, refetch: refetchEpisodes } = useRecentEpisodes();
  
  // Initialize app updates
  useAppUpdates();

  // Debug: Log stats when they change
  useEffect(() => {
    if (stats) {
      console.log('Dashboard received stats:', stats);
    }
  }, [stats]);
  
  // Set up auto-refresh every 30 seconds (increased from 5 for better UX)
  useEffect(() => {
    const intervalId = setInterval(() => {
      refreshData(false);
    }, 30000);
    
    return () => clearInterval(intervalId);
  }, []);

  const handleViewTranscript = (episode: Episode) => {
    setSelectedEpisode(episode);
    setIsTranscriptOpen(true);
  };
  
  // Cycle through color schemes
  const cycleColorScheme = () => {
    setColorScheme(current => {
      if (current === 'default') return 'vibrant';
      if (current === 'vibrant') return 'minimal';
      return 'default';
    });
  };
  
  const refreshData = async (showRefreshState = true) => {
    if (showRefreshState) {
      setRefreshing(true);
    }
    
    try {
      // Refresh stats using our new hook
      refreshStats();
      
      // Invalidate and refetch all necessary queries
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ["/api/episodes"] }),
        queryClient.invalidateQueries({ queryKey: ["/api/episodes", "recent"] }),
        queryClient.invalidateQueries({ queryKey: ["/api/stats"] }),
        refetchEpisodes()
      ]);
    } catch (error) {
      console.error("Failed to refresh data:", error);
    }
    
    if (showRefreshState) {
      setTimeout(() => setRefreshing(false), 500);
    }
  };

  return (
    <div className="space-y-8">
      {/* Hero Section */}
      <motion.section 
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="text-center space-y-6"
      >
        <h1 className="text-4xl md:text-6xl font-bold bg-gradient-to-r from-primary to-purple-500 bg-clip-text text-transparent">
          Podcast Transcript AI
        </h1>
        <p className="text-xl text-muted-foreground max-w-2xl mx-auto">
          Created by <a href="https://x.com/Pragmanic0" className="text-primary">Gadsdencode</a>
        </p>
        <p className="text-xl text-muted-foreground max-w-2xl mx-auto">
          All credit and gratitude to Scott Adams for the podcast content and assembling the #CWSA community (IYKYK).
        </p>
        <div className="flex items-center justify-center gap-4">
          <Link href="/add-episode">
            <Button size="lg" className="bg-gradient-to-r from-primary to-purple-500 hover:from-primary/90 hover:to-purple-500/90">
              <Plus className="mr-2 h-5 w-5" />
              Start Extracting
            </Button>
          </Link>
          <div className="flex gap-2">
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button 
                    size="icon" 
                    variant="outline" 
                    onClick={() => refreshData()}
                    disabled={refreshing || statsLoading}
                    title="Refresh data"
                    className={refreshing ? "animate-spin" : ""}
                  >
                    <RefreshCw className="h-5 w-5" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>Refresh dashboard data</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
            
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button 
                    size="icon" 
                    variant="outline" 
                    onClick={cycleColorScheme}
                    title="Change theme"
                  >
                    <Settings className="h-5 w-5" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>Change stats visualization style</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </div>
        </div>
      </motion.section>

      {/* Stats Cards - Using our enhanced component */}
      <StatsCardGrid 
        stats={stats} 
        statsLoading={statsLoading}
        onRefresh={refreshStats}
        colorScheme={colorScheme}
      />

      {/* Recent Episodes */}
      <motion.section
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.2 }}
        className="space-y-6"
      >
        <div className="flex items-center justify-between">
          <h2 className="text-2xl font-bold">Recent Episodes</h2>
          <Link href="/episodes">
            <Button variant="outline" className="glassmorphism border-white/20">
              View All
              <ArrowRight className="ml-2 h-4 w-4" />
            </Button>
          </Link>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {episodesLoading ? (
            Array.from({ length: 3 }).map((_, i) => (
              <Card key={i} className="glassmorphism border-white/10 animate-pulse">
                <div className="h-32 bg-muted rounded-t-lg"></div>
                <CardContent className="p-6">
                  <div className="h-4 bg-muted rounded mb-2"></div>
                  <div className="h-3 bg-muted rounded w-3/4 mb-4"></div>
                  <div className="flex justify-between">
                    <div className="h-3 bg-muted rounded w-1/4"></div>
                    <div className="h-3 bg-muted rounded w-1/4"></div>
                  </div>
                </CardContent>
              </Card>
            ))
          ) : recentEpisodes?.length === 0 ? (
            <Card className="glassmorphism border-white/10 col-span-full">
              <CardContent className="p-12 text-center">
                <div className="text-muted-foreground">
                  <Play className="h-12 w-12 mx-auto mb-4 opacity-50" />
                  <h3 className="text-lg font-medium mb-2">No Episodes Yet</h3>
                  <p className="mb-4">Start by adding your first YouTube video to extract transcripts.</p>
                  <Link href="/add-episode">
                    <Button>
                      <Plus className="mr-2 h-4 w-4" />
                      Add Episode
                    </Button>
                  </Link>
                </div>
              </CardContent>
            </Card>
          ) : (
            recentEpisodes?.slice(0, 6).map((episode, index) => (
              <motion.div
                key={episode.id}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: index * 0.1 }}
              >
                <Card className="glassmorphism border-white/10 hover:bg-white/5 transition-colors">
                  <div className="relative">
                    <img 
                      src={episode.thumbnailUrl || "https://images.unsplash.com/photo-1540575467063-178a50c2df87?ixlib=rb-4.0.3&auto=format&fit=crop&w=400&h=225"} 
                      alt={episode.title}
                      className="w-full h-32 object-cover rounded-t-lg"
                    />
                    <div className="absolute top-2 right-2 bg-black/70 text-white text-xs px-2 py-1 rounded font-mono">
                      {episode.duration}
                    </div>
                    <div className={`absolute top-2 left-2 text-white text-xs px-2 py-1 rounded-full ${
                      episode.status === "completed" ? "bg-emerald-500" :
                      episode.status === "processing" ? "bg-amber-500" :
                      episode.status === "failed" ? "bg-red-500" :
                      "bg-slate-500"
                    }`}>
                      {episode.status === "completed" ? "âœ“ Processed" :
                       episode.status === "processing" ? "â³ Processing" :
                       episode.status === "failed" ? "âœ— Failed" :
                       "â¸ Pending"}
                    </div>
                  </div>
                  <CardContent className="p-4">
                    <h3 className="font-medium text-sm line-clamp-2 mb-2">{episode.title}</h3>
                    <p className="text-xs text-muted-foreground mb-3">{episode.channel}</p>
                    <div className="flex items-center justify-between text-xs mb-3">
                      <span className={`px-2 py-1 rounded ${
                        episode.extractionMethod === "caption" ? "bg-blue-500/20 text-blue-400" :
                        episode.extractionMethod === "scraping" ? "bg-purple-500/20 text-purple-400" :
                        "bg-emerald-500/20 text-emerald-400"
                      }`}>
                        {episode.extractionMethod === "caption" ? "Caption-Based" :
                         episode.extractionMethod === "scraping" ? "Web Scraping" :
                         "Audio-Based"}
                      </span>
                      <span className="text-muted-foreground">
                        {episode.wordCount ? `${episode.wordCount} words` : ""}
                      </span>
                    </div>
                    <div className="flex justify-end">
                      <Button 
                        variant="ghost" 
                        size="sm"
                        onClick={() => handleViewTranscript(episode)}
                        disabled={!episode.transcript}
                        title={episode.transcript ? "View transcript" : "Transcript not available"}
                      >
                        <Eye className="h-4 w-4" />
                      </Button>
                    </div>
                  </CardContent>
                </Card>
              </motion.div>
            ))
          )}
        </div>
      </motion.section>

      {/* Transcript Viewer Modal */}
      {selectedEpisode && (
        <TranscriptViewer 
          episode={selectedEpisode}
          isOpen={isTranscriptOpen}
          onClose={() => setIsTranscriptOpen(false)}
        />
      )}
    </div>
  );
}

================
File: client/src/pages/episodes.tsx
================
import { useState } from "react";
import { motion } from "framer-motion";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Card, CardContent } from "@/components/ui/card";
import { useEpisodes } from "@/hooks/use-episodes";
import EpisodeCard from "@/components/episodes/episode-card";
import { Search, Filter, Download, Grid, List, Plus } from "lucide-react";
import { Link } from "wouter";

export default function Episodes() {
  const [searchTerm, setSearchTerm] = useState("");
  const [statusFilter, setStatusFilter] = useState("all");
  const [methodFilter, setMethodFilter] = useState("all");
  const [viewMode, setViewMode] = useState<"grid" | "list">("grid");
  
  const { data: episodes, isLoading } = useEpisodes();

  const filteredEpisodes = episodes?.filter(episode => {
    const matchesSearch = episode.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         episode.channel?.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         episode.description?.toLowerCase().includes(searchTerm.toLowerCase());
    
    const matchesStatus = statusFilter === "all" || episode.status === statusFilter;
    const matchesMethod = methodFilter === "all" || episode.extractionMethod === methodFilter;
    
    return matchesSearch && matchesStatus && matchesMethod;
  }) || [];

  return (
    <div className="space-y-6">
      {/* Header */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="flex flex-col md:flex-row md:items-center justify-between gap-4"
      >
        <div>
          <h1 className="text-3xl font-bold">Episodes</h1>
          <p className="text-muted-foreground">
            Manage your extracted transcripts and processing queue
          </p>
        </div>
        <div className="flex items-center gap-3">
          <Button variant="outline" className="glassmorphism border-white/20">
            <Download className="mr-2 h-4 w-4" />
            Export
          </Button>
          <Link href="/add-episode">
            <Button className="bg-gradient-to-r from-primary to-purple-500">
              <Plus className="mr-2 h-4 w-4" />
              Add Episode
            </Button>
          </Link>
        </div>
      </motion.div>

      {/* Filters */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.1 }}
        className="flex flex-col md:flex-row gap-4"
      >
        <div className="flex-1 relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search episodes, titles, or content..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="pl-10 bg-background/50 border-white/20"
          />
        </div>
        
        <Select value={statusFilter} onValueChange={setStatusFilter}>
          <SelectTrigger className="w-40 bg-background/50 border-white/20">
            <SelectValue placeholder="Status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Status</SelectItem>
            <SelectItem value="completed">Completed</SelectItem>
            <SelectItem value="processing">Processing</SelectItem>
            <SelectItem value="pending">Pending</SelectItem>
            <SelectItem value="failed">Failed</SelectItem>
          </SelectContent>
        </Select>

        <Select value={methodFilter} onValueChange={setMethodFilter}>
          <SelectTrigger className="w-48 bg-background/50 border-white/20">
            <SelectValue placeholder="Method" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Methods</SelectItem>
            <SelectItem value="caption">Caption-Based</SelectItem>
            <SelectItem value="scraping">Web Scraping</SelectItem>
            <SelectItem value="audio">Audio-Based</SelectItem>
          </SelectContent>
        </Select>

        <div className="flex items-center gap-2">
          <Button
            variant={viewMode === "grid" ? "default" : "outline"}
            size="sm"
            onClick={() => setViewMode("grid")}
            className={viewMode === "grid" ? "" : "glassmorphism border-white/20"}
          >
            <Grid className="h-4 w-4" />
          </Button>
          <Button
            variant={viewMode === "list" ? "default" : "outline"}
            size="sm"
            onClick={() => setViewMode("list")}
            className={viewMode === "list" ? "" : "glassmorphism border-white/20"}
          >
            <List className="h-4 w-4" />
          </Button>
        </div>
      </motion.div>

      {/* Episodes */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.2 }}
      >
        {isLoading ? (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {Array.from({ length: 6 }).map((_, i) => (
              <Card key={i} className="glassmorphism border-white/10 animate-pulse">
                <div className="h-48 bg-muted rounded-t-lg"></div>
                <CardContent className="p-6">
                  <div className="h-4 bg-muted rounded mb-2"></div>
                  <div className="h-3 bg-muted rounded w-3/4 mb-4"></div>
                  <div className="flex justify-between">
                    <div className="h-3 bg-muted rounded w-1/4"></div>
                    <div className="h-3 bg-muted rounded w-1/4"></div>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
        ) : filteredEpisodes.length === 0 ? (
          <Card className="glassmorphism border-white/10">
            <CardContent className="p-12 text-center">
              <div className="text-muted-foreground">
                <Search className="h-12 w-12 mx-auto mb-4 opacity-50" />
                <h3 className="text-lg font-medium mb-2">
                  {searchTerm || statusFilter !== "all" || methodFilter !== "all" 
                    ? "No Episodes Found" 
                    : "No Episodes Yet"
                  }
                </h3>
                <p className="mb-4">
                  {searchTerm || statusFilter !== "all" || methodFilter !== "all"
                    ? "Try adjusting your search or filters."
                    : "Start by adding your first YouTube video to extract transcripts."
                  }
                </p>
                <Link href="/add-episode">
                  <Button>
                    <Plus className="mr-2 h-4 w-4" />
                    Add Episode
                  </Button>
                </Link>
              </div>
            </CardContent>
          </Card>
        ) : (
          <div className={viewMode === "grid" 
            ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
            : "space-y-4"
          }>
            {filteredEpisodes.map((episode, index) => (
              <motion.div
                key={episode.id}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: index * 0.05 }}
              >
                <EpisodeCard episode={episode} viewMode={viewMode} />
              </motion.div>
            ))}
          </div>
        )}
      </motion.div>

      {/* Load More */}
      {filteredEpisodes.length > 0 && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.3 }}
          className="text-center"
        >
          <Button variant="outline" className="glassmorphism border-white/20">
            Load More Episodes
          </Button>
        </motion.div>
      )}
    </div>
  );
}

================
File: client/src/pages/not-found.tsx
================
import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle } from "lucide-react";

export default function NotFound() {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md mx-4">
        <CardContent className="pt-6">
          <div className="flex mb-4 gap-2">
            <AlertCircle className="h-8 w-8 text-red-500" />
            <h1 className="text-2xl font-bold text-gray-900">404 Page Not Found</h1>
          </div>

          <p className="mt-4 text-sm text-gray-600">
            Did you forget to add the page to the router?
          </p>
        </CardContent>
      </Card>
    </div>
  );
}

================
File: client/src/pages/search.tsx
================
import { useState } from "react";
import { motion } from "framer-motion";
import { Card, CardContent } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useSearch } from "@/hooks/use-search";
import SearchResults from "@/components/search/search-results";
import { Search, Filter, History } from "lucide-react";

export default function SearchPage() {
  const [query, setQuery] = useState("");
  const [timeFilter, setTimeFilter] = useState("all");
  const [methodFilter, setMethodFilter] = useState("all");
  const [channelFilter, setChannelFilter] = useState("all");
  
  const { data: searchResults, isLoading, mutate: performSearch } = useSearch();

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    if (query.trim()) {
      performSearch({
        query: query.trim(),
        filters: {
          timeRange: timeFilter,
          method: methodFilter,
          channel: channelFilter
        }
      });
    }
  };

  return (
    <div className="max-w-4xl mx-auto space-y-8">
      {/* Header */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="text-center space-y-4"
      >
        <h1 className="text-3xl font-bold">Smart Search</h1>
        <p className="text-muted-foreground">
          Search across all transcripts with intelligent highlighting and filters
        </p>
      </motion.div>

      {/* Search Form */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.1 }}
      >
        <Card className="glassmorphism border-white/10">
          <CardContent className="p-6">
            <form onSubmit={handleSearch} className="space-y-6">
              {/* Main Search */}
              <div className="relative">
                <Search className="absolute left-4 top-1/2 transform -translate-y-1/2 h-5 w-5 text-muted-foreground" />
                <Input
                  type="text"
                  placeholder="Search transcripts, topics, speakers..."
                  value={query}
                  onChange={(e) => setQuery(e.target.value)}
                  className="pl-12 h-12 text-lg bg-background/50 border-white/20"
                />
                <Button
                  type="submit"
                  disabled={isLoading}
                  className="absolute right-2 top-2 bg-gradient-to-r from-primary to-purple-500"
                >
                  {isLoading ? "Searching..." : "Search"}
                </Button>
              </div>

              {/* Filters */}
              <div className="flex flex-wrap gap-4">
                <Select value={timeFilter} onValueChange={setTimeFilter}>
                  <SelectTrigger className="w-40 bg-background/50 border-white/20">
                    <SelectValue placeholder="Time Range" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">All Time</SelectItem>
                    <SelectItem value="week">Last Week</SelectItem>
                    <SelectItem value="month">Last Month</SelectItem>
                    <SelectItem value="year">Last Year</SelectItem>
                  </SelectContent>
                </Select>

                <Select value={methodFilter} onValueChange={setMethodFilter}>
                  <SelectTrigger className="w-48 bg-background/50 border-white/20">
                    <SelectValue placeholder="Extraction Method" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">All Methods</SelectItem>
                    <SelectItem value="caption">Caption-Based</SelectItem>
                    <SelectItem value="scraping">Web Scraping</SelectItem>
                    <SelectItem value="audio">Audio-Based</SelectItem>
                  </SelectContent>
                </Select>

                <Select value={channelFilter} onValueChange={setChannelFilter}>
                  <SelectTrigger className="w-48 bg-background/50 border-white/20">
                    <SelectValue placeholder="Channel" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">All Channels</SelectItem>
                    <SelectItem value="techtalk">TechTalk Podcast</SelectItem>
                    <SelectItem value="business">Business Insights</SelectItem>
                    <SelectItem value="edutech">EduTech University</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </form>
          </CardContent>
        </Card>
      </motion.div>

      {/* Search Results */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.2 }}
      >
        {searchResults ? (
          <SearchResults results={searchResults} query={query} />
        ) : (
          <Card className="glassmorphism border-white/10">
            <CardContent className="p-12 text-center">
              <div className="text-muted-foreground">
                <Search className="h-12 w-12 mx-auto mb-4 opacity-50" />
                <h3 className="text-lg font-medium mb-2">Start Your Search</h3>
                <p className="mb-6">
                  Enter keywords, phrases, or topics to search across all your transcripts.
                </p>
                
                {/* Search Suggestions */}
                <div className="space-y-2">
                  <p className="text-sm font-medium">Try searching for:</p>
                  <div className="flex flex-wrap gap-2 justify-center">
                    {["artificial intelligence", "web development", "best practices", "tutorial"].map((suggestion) => (
                      <Button
                        key={suggestion}
                        variant="outline"
                        size="sm"
                        onClick={() => setQuery(suggestion)}
                        className="glassmorphism border-white/20 text-xs"
                      >
                        {suggestion}
                      </Button>
                    ))}
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        )}
      </motion.div>

      {/* Recent Searches */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.3 }}
      >
        <Card className="glassmorphism border-white/10">
          <CardContent className="p-6">
            <h3 className="text-lg font-semibold mb-4 flex items-center">
              <History className="mr-2 h-5 w-5" />
              Recent Searches
            </h3>
            <div className="space-y-2">
              {["artificial intelligence", "react hooks", "api design"].map((recentQuery, index) => (
                <div
                  key={index}
                  className="flex items-center justify-between p-2 rounded-lg hover:bg-white/5 cursor-pointer transition-colors"
                  onClick={() => setQuery(recentQuery)}
                >
                  <span className="text-sm">{recentQuery}</span>
                  <span className="text-xs text-muted-foreground">3 results</span>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      </motion.div>
    </div>
  );
}

================
File: client/src/test-highlight.ts
================
// Test script for the highlightText function
import { highlightText, type KeywordHighlight } from "./lib/keyword-analyzer";

// Sample text
const text = "This is some sample text about decaf coffee and other topics.";

// Sample keywords
const keywords: KeywordHighlight[] = [
  {
    keyword: "decaf coffee",
    category: "concept",
    confidence: 0.85,
    positions: [
      {
        start: 29,
        end: 41
      }
    ]
  }
];

// Run test
const highlighted = highlightText(text, keywords);
console.log("Original text:", text);
console.log("Highlighted text:", highlighted);

// Check if it's working properly
const expectedPattern = 'title="concept (85% confidence)">decaf coffee</span>';
console.log("Contains expected pattern:", highlighted.includes(expectedPattern));

// Display the actual HTML that would be rendered
console.log("\nActual HTML (inspect for proper attribute rendering):");
console.log(highlighted);

// Export to show in browser
export const testOutput = {
  original: text,
  highlighted: highlighted
};

================
File: client/src/types/index.ts
================
export type ExtractionMethod = "caption" | "scraping" | "audio";

export interface SearchFilters {
  timeRange?: string;
  method?: string;
  channel?: string;
}

export interface SearchRequestPayload {
  query: string;
  filters?: SearchFilters;
}

export interface ProcessingProgress {
  episodeId: number;
  progress: number;
  estimatedTime: string;
  currentStep: string;
}

export interface TranscriptSegment {
  timestamp: string;
  text: string;
  speaker?: string;
}

export interface HighlightMatch {
  segment: string;
  timestamp: string;
  matchScore: number;
}

================
File: client/test-highlight.html
================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Keyword Highlight Test</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
    }
    .keyword-highlight {
      padding: 2px 4px;
      border-radius: 4px;
      font-weight: 500;
      cursor: help;
      transition: all 0.2s ease;
    }
    .keyword-highlight:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .bg-purple-200 {
      background-color: #e9d5ff;
    }
    .text-purple-900 {
      color: #581c87;
    }
    .transcript {
      white-space: pre-wrap;
      line-height: 1.6;
      background-color: #f9fafb;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    }
  </style>
</head>
<body>
  <h1>Keyword Highlighting Test</h1>
  
  <div class="transcript" id="transcript"></div>
  
  <script>
    // Sample highlighted text
    const sample = 'This is a test with <span class="keyword-highlight bg-purple-200 text-purple-900" title="concept (85% confidence)">decaf coffee</span> as a highlighted keyword.';
    
    // Display in transcript div
    document.getElementById('transcript').innerHTML = sample;
    
    // Also log to console to verify
    console.log(sample);
  </script>
</body>
</html>

================
File: components.json
================
{
    "$schema": "https://ui.shadcn.com/schema.json",
    "style": "new-york",
    "rsc": false,
    "tsx": true,
    "tailwind": {
      "config": "tailwind.config.ts",
      "css": "client/src/index.css",
      "baseColor": "neutral",
      "cssVariables": true,
      "prefix": ""
    },
    "aliases": {
      "components": "@/components",
      "utils": "@/lib/utils",
      "ui": "@/components/ui",
      "lib": "@/lib",
      "hooks": "@/hooks"
    }
}

================
File: drizzle.config.ts
================
import { defineConfig } from "drizzle-kit";
import dotenv from "dotenv";

dotenv.config();

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});

================
File: migrations/0000_harsh_doomsday.sql
================
CREATE TABLE "episodes" (
	"id" serial PRIMARY KEY NOT NULL,
	"video_id" text NOT NULL,
	"title" text NOT NULL,
	"description" text,
	"channel" text,
	"duration" text,
	"thumbnail_url" text,
	"youtube_url" text NOT NULL,
	"status" text DEFAULT 'pending' NOT NULL,
	"extraction_method" text NOT NULL,
	"transcript" text,
	"summary" text,
	"topics" jsonb DEFAULT '[]'::jsonb,
	"word_count" integer,
	"progress" integer DEFAULT 0,
	"current_step" text DEFAULT 'Preparing to process...',
	"processing_started" timestamp,
	"processing_completed" timestamp,
	"error_message" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"user_id" integer NOT NULL,
	"generate_summary" boolean DEFAULT false,
	"extract_topics" boolean DEFAULT false,
	CONSTRAINT "episodes_video_id_unique" UNIQUE("video_id")
);
--> statement-breakpoint
CREATE TABLE "processing_queue" (
	"id" serial PRIMARY KEY NOT NULL,
	"episode_id" integer NOT NULL,
	"priority" integer DEFAULT 0,
	"attempts" integer DEFAULT 0,
	"max_attempts" integer DEFAULT 3,
	"status" text DEFAULT 'queued' NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"started_at" timestamp,
	"completed_at" timestamp
);
--> statement-breakpoint
CREATE TABLE "search_queries" (
	"id" serial PRIMARY KEY NOT NULL,
	"query" text NOT NULL,
	"user_id" integer,
	"result_count" integer DEFAULT 0,
	"created_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "users" (
	"id" serial PRIMARY KEY NOT NULL,
	"username" text NOT NULL,
	"email" text NOT NULL,
	"password" text NOT NULL,
	"role" text DEFAULT 'user' NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "users_username_unique" UNIQUE("username"),
	CONSTRAINT "users_email_unique" UNIQUE("email")
);
--> statement-breakpoint
ALTER TABLE "episodes" ADD CONSTRAINT "episodes_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "processing_queue" ADD CONSTRAINT "processing_queue_episode_id_episodes_id_fk" FOREIGN KEY ("episode_id") REFERENCES "public"."episodes"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "search_queries" ADD CONSTRAINT "search_queries_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE no action ON UPDATE no action;

================
File: migrations/0001_lazy_rockslide.sql
================
CREATE TABLE "admins" (
	"id" serial PRIMARY KEY NOT NULL,
	"username" text NOT NULL,
	"password" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "admins_username_unique" UNIQUE("username")
);

================
File: migrations/0002_admin_users.sql
================
CREATE TABLE "admin" (
  "id" serial PRIMARY KEY NOT NULL,
  "username" text NOT NULL,
  "password" text NOT NULL,
  "created_at" timestamp DEFAULT now() NOT NULL,
  CONSTRAINT "admin_username_unique" UNIQUE("username")
);

-- Insert the hardcoded admin user
INSERT INTO "admin" ("username", "password") VALUES ('admin', 'abc3abcabcabc');

================
File: migrations/meta/_journal.json
================
{
  "version": "7",
  "dialect": "postgresql",
  "entries": [
    {
      "idx": 0,
      "version": "7",
      "when": 1748436540810,
      "tag": "0000_harsh_doomsday",
      "breakpoints": true
    },
    {
      "idx": 1,
      "version": "7",
      "when": 1748466984509,
      "tag": "0001_lazy_rockslide",
      "breakpoints": true
    }
  ]
}

================
File: migrations/meta/0000_snapshot.json
================
{
  "id": "82920d73-69ad-491f-bf00-93beb6bd4725",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.episodes": {
      "name": "episodes",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "video_id": {
          "name": "video_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "channel": {
          "name": "channel",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "duration": {
          "name": "duration",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "thumbnail_url": {
          "name": "thumbnail_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "youtube_url": {
          "name": "youtube_url",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "status": {
          "name": "status",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "default": "'pending'"
        },
        "extraction_method": {
          "name": "extraction_method",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "transcript": {
          "name": "transcript",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "summary": {
          "name": "summary",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "topics": {
          "name": "topics",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false,
          "default": "'[]'::jsonb"
        },
        "word_count": {
          "name": "word_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "progress": {
          "name": "progress",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "default": 0
        },
        "current_step": {
          "name": "current_step",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "default": "'Preparing to process...'"
        },
        "processing_started": {
          "name": "processing_started",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "processing_completed": {
          "name": "processing_completed",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "error_message": {
          "name": "error_message",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "generate_summary": {
          "name": "generate_summary",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "extract_topics": {
          "name": "extract_topics",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "episodes_user_id_users_id_fk": {
          "name": "episodes_user_id_users_id_fk",
          "tableFrom": "episodes",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "episodes_video_id_unique": {
          "name": "episodes_video_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "video_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.processing_queue": {
      "name": "processing_queue",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "episode_id": {
          "name": "episode_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "priority": {
          "name": "priority",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "default": 0
        },
        "attempts": {
          "name": "attempts",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "default": 0
        },
        "max_attempts": {
          "name": "max_attempts",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "default": 3
        },
        "status": {
          "name": "status",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "default": "'queued'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "started_at": {
          "name": "started_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "completed_at": {
          "name": "completed_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "processing_queue_episode_id_episodes_id_fk": {
          "name": "processing_queue_episode_id_episodes_id_fk",
          "tableFrom": "processing_queue",
          "tableTo": "episodes",
          "columnsFrom": [
            "episode_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.search_queries": {
      "name": "search_queries",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "query": {
          "name": "query",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "result_count": {
          "name": "result_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "default": 0
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "search_queries_user_id_users_id_fk": {
          "name": "search_queries_user_id_users_id_fk",
          "tableFrom": "search_queries",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "username": {
          "name": "username",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "password": {
          "name": "password",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "default": "'user'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "users_username_unique": {
          "name": "users_username_unique",
          "nullsNotDistinct": false,
          "columns": [
            "username"
          ]
        },
        "users_email_unique": {
          "name": "users_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}

================
File: migrations/meta/0001_snapshot.json
================
{
  "id": "ca1dad1b-4bdb-46aa-b95b-199b47b08f9c",
  "prevId": "82920d73-69ad-491f-bf00-93beb6bd4725",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.admins": {
      "name": "admins",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "username": {
          "name": "username",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "password": {
          "name": "password",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "admins_username_unique": {
          "name": "admins_username_unique",
          "nullsNotDistinct": false,
          "columns": [
            "username"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.episodes": {
      "name": "episodes",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "video_id": {
          "name": "video_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "title": {
          "name": "title",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "channel": {
          "name": "channel",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "duration": {
          "name": "duration",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "thumbnail_url": {
          "name": "thumbnail_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "youtube_url": {
          "name": "youtube_url",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "status": {
          "name": "status",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "default": "'pending'"
        },
        "extraction_method": {
          "name": "extraction_method",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "transcript": {
          "name": "transcript",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "summary": {
          "name": "summary",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "topics": {
          "name": "topics",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": false,
          "default": "'[]'::jsonb"
        },
        "word_count": {
          "name": "word_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "progress": {
          "name": "progress",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "default": 0
        },
        "current_step": {
          "name": "current_step",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "default": "'Preparing to process...'"
        },
        "processing_started": {
          "name": "processing_started",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "processing_completed": {
          "name": "processing_completed",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "error_message": {
          "name": "error_message",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "generate_summary": {
          "name": "generate_summary",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "extract_topics": {
          "name": "extract_topics",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "episodes_user_id_users_id_fk": {
          "name": "episodes_user_id_users_id_fk",
          "tableFrom": "episodes",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "episodes_video_id_unique": {
          "name": "episodes_video_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "video_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.processing_queue": {
      "name": "processing_queue",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "episode_id": {
          "name": "episode_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "priority": {
          "name": "priority",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "default": 0
        },
        "attempts": {
          "name": "attempts",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "default": 0
        },
        "max_attempts": {
          "name": "max_attempts",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "default": 3
        },
        "status": {
          "name": "status",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "default": "'queued'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "started_at": {
          "name": "started_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        },
        "completed_at": {
          "name": "completed_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "processing_queue_episode_id_episodes_id_fk": {
          "name": "processing_queue_episode_id_episodes_id_fk",
          "tableFrom": "processing_queue",
          "tableTo": "episodes",
          "columnsFrom": [
            "episode_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.search_queries": {
      "name": "search_queries",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "query": {
          "name": "query",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "result_count": {
          "name": "result_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "default": 0
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "search_queries_user_id_users_id_fk": {
          "name": "search_queries_user_id_users_id_fk",
          "tableFrom": "search_queries",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "username": {
          "name": "username",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "password": {
          "name": "password",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "default": "'user'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "users_username_unique": {
          "name": "users_username_unique",
          "nullsNotDistinct": false,
          "columns": [
            "username"
          ]
        },
        "users_email_unique": {
          "name": "users_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}

================
File: package.json
================
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "cross-env NODE_ENV=development tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "cross-env NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@tanstack/react-query": "^5.60.5",
    "axios": "^1.9.0",
    "bcrypt": "^6.0.0",
    "cheerio": "^1.0.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "date-fns": "^3.6.0",
    "dotenv": "^16.5.0",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "framer-motion": "^11.13.1",
    "input-otp": "^1.4.2",
    "jsonwebtoken": "^9.0.2",
    "lucide-react": "^0.453.0",
    "memorystore": "^1.6.7",
    "next-themes": "^0.4.6",
    "openai": "^4.103.0",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "postgres": "^3.4.3",
    "puppeteer": "^24.9.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.55.0",
    "react-icons": "^5.4.0",
    "react-resizable-panels": "^2.1.7",
    "react-router-dom": "^7.6.1",
    "recharts": "^2.15.2",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.2.5",
    "vaul": "^1.1.2",
    "wouter": "^3.7.1",
    "ws": "^8.18.0",
    "zod": "^3.24.2",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.2.5",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@tailwindcss/vite": "^4.1.3",
    "@types/bcrypt": "^5.0.2",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.1",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "cross-env": "^7.0.3",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.14"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}

================
File: postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: pyproject.toml
================
[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "requests>=2.32.3",
    "youtube-transcript-api>=1.0.3",
]

================
File: README.md
================
# Podster YouTube Caption Extraction

This project includes multiple methods for extracting YouTube video transcripts:

## TypeScript-Based Caption Extraction (No Python Required)

The application now uses a pure TypeScript/JavaScript-based solution for extracting YouTube captions, eliminating the need for Python dependencies. The extraction system works in three progressive levels:

1. **Basic Scraper**: First attempts to extract captions using simple HTTP requests and regex.
2. **Advanced Scraper**: Uses multiple specialized extraction techniques for harder cases.
3. **Puppeteer Fallback**: As a last resort, uses browser automation to extract captions.

## How to Use

The extraction is automatically selected when processing videos. If you need to use it directly:

```typescript
import { extractTranscript } from './server/routes';

// Using the TypeScript-based scraping methods:
const transcript = await extractTranscript('videoId', 'scraping');
```

## Troubleshooting

If you encounter issues with caption extraction:

1. Check that the video has captions available on YouTube
2. Try a different extraction method
3. Look at the console logs for detailed error information

## Credits

This implementation combines several approaches to provide reliable caption extraction without external dependencies.

================
File: server/caption_scraper.py
================
import re
import requests
import json
from urllib.parse import unquote
from typing import Optional, Dict

class CaptionScraper:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        })

    def extract_captions_from_page(self, video_id: str) -> Optional[Dict]:
        """
        Extract captions directly from YouTube using multiple strategies
        """
        try:
            # Strategy 1: Try direct timedtext API
            caption_text = self._try_direct_timedtext_api(video_id)
            
            if not caption_text:
                # Strategy 2: Try transcript page scraping
                caption_text = self._try_transcript_page_scraping(video_id)
            
            if not caption_text or len(caption_text.strip()) < 50:
                return None
            
            # Get basic metadata
            title, upload_date, channel = self._get_basic_metadata(video_id)
            
            return {
                'transcript': caption_text,
                'title': title or f'Video {video_id}',
                'date': upload_date or '2024-01-01',
                'channel': channel or 'Unknown Channel',
                'video_id': video_id,
                'extraction_method': 'web_scraping'
            }
            
        except Exception as e:
            print(f"Error scraping captions for {video_id}: {e}")
            return None

    def _try_direct_timedtext_api(self, video_id: str) -> Optional[str]:
        """Try using youtube-transcript-api with authentication"""
        try:
            from youtube_transcript_api import YouTubeTranscriptApi
            
            # Try without authentication first
            transcript_list = YouTubeTranscriptApi.get_transcript(video_id, languages=['en', 'en-US'])
            
            if transcript_list:
                # Combine all text segments
                full_text = ' '.join([item['text'] for item in transcript_list])
                return self._clean_text(full_text)
                
        except ImportError:
            print("youtube-transcript-api not available")
        except Exception as e:
            if "IP" in str(e) or "blocked" in str(e).lower():
                print(f"YouTube is blocking requests from this server. Trying web scraping: {e}")
                return None
            else:
                print(f"YouTube Transcript API failed: {e}")
            
        return None

    def _try_transcript_page_scraping(self, video_id: str) -> Optional[str]:
        """Try scraping the main video page for embedded captions"""
        try:
            url = f"https://www.youtube.com/watch?v={video_id}"
            response = self.session.get(url, timeout=15)
            
            if response.status_code != 200:
                return None
            
            html_content = response.text
            return self._extract_caption_data(html_content)
            
        except Exception as e:
            print(f"Page scraping failed: {e}")
            return None

    def _get_basic_metadata(self, video_id: str) -> tuple:
        """Get basic video metadata"""
        try:
            url = f"https://www.youtube.com/watch?v={video_id}"
            response = self.session.get(url, timeout=10)
            
            if response.status_code == 200:
                html = response.text
                title = self._extract_title(html)
                date = self._extract_upload_date(html)
                channel = self._extract_channel(html)
                return title, date, channel
        except:
            pass
        
        return None, None, None

    def _extract_title(self, html: str) -> Optional[str]:
        """Extract video title from HTML"""
        patterns = [
            r'"title"\s*:\s*"([^"]+)"',
            r'<title>([^<]+)</title>',
            r'property="og:title"\s+content="([^"]+)"'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, html)
            if match:
                title = match.group(1)
                if ' - YouTube' in title:
                    title = title.replace(' - YouTube', '')
                return self._clean_text(title)
        return None

    def _extract_upload_date(self, html: str) -> Optional[str]:
        """Extract upload date from HTML"""
        patterns = [
            r'"uploadDate"\s*:\s*"([^"]+)"',
            r'"datePublished"\s*:\s*"([^"]+)"'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, html)
            if match:
                date_str = match.group(1)
                try:
                    from datetime import datetime
                    # Parse ISO format date
                    date_obj = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
                    return date_obj.strftime('%Y-%m-%d')
                except:
                    continue
        return None

    def _extract_channel(self, html: str) -> Optional[str]:
        """Extract channel name from HTML"""
        patterns = [
            r'"author"\s*:\s*"([^"]+)"',
            r'"ownerChannelName"\s*:\s*"([^"]+)"',
            r'property="og:video:tag"\s+content="([^"]+)"'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, html)
            if match:
                return self._clean_text(match.group(1))
        return None

    def _extract_caption_data(self, html: str) -> Optional[str]:
        """Extract caption/subtitle data from HTML"""
        try:
            # Look for the player config that contains caption track URLs
            player_config_pattern = r'ytInitialPlayerResponse\s*=\s*({.+?});'
            match = re.search(player_config_pattern, html)
            
            if match:
                try:
                    config_json = match.group(1)
                    player_data = json.loads(config_json)
                    
                    # Navigate to captions data
                    captions = player_data.get('captions', {})
                    caption_tracks = captions.get('playerCaptionsTracklistRenderer', {}).get('captionTracks', [])
                    
                    # Find English captions (prefer manual over auto-generated)
                    english_track = None
                    for track in caption_tracks:
                        if track.get('languageCode', '').startswith('en'):
                            if track.get('kind') != 'asr':  # Manual captions
                                english_track = track
                                break
                            elif english_track is None:  # Auto-generated as fallback
                                english_track = track
                    
                    if english_track and 'baseUrl' in english_track:
                        caption_url = english_track['baseUrl']
                        caption_text = self._download_caption_file(caption_url)
                        if caption_text and len(caption_text.strip()) > 100:
                            return caption_text
                
                except json.JSONDecodeError:
                    print("Failed to parse player config JSON")
            
            return None
            
        except Exception as e:
            print(f"Error extracting caption data: {e}")
            return None

    def _download_caption_file(self, url: str) -> Optional[str]:
        """Download and parse caption file from URL"""
        try:
            # Decode URL if needed
            if '\\u' in url:
                url = url.encode().decode('unicode_escape')
            
            response = self.session.get(url, timeout=10)
            if response.status_code == 200:
                content = response.text
                
                # Parse different caption formats
                if '<text' in content:  # XML format
                    return self._parse_xml_captions(content)
                elif '"text"' in content:  # JSON format
                    return self._parse_json_captions(content)
                else:  # Plain text
                    return self._clean_text(content)
            
        except Exception as e:
            print(f"Error downloading caption file: {e}")
        
        return None

    def _parse_xml_captions(self, xml_content: str) -> str:
        """Parse XML caption format (YouTube's timedtext format)"""
        # Extract ALL text elements using the most comprehensive approach
        text_matches = re.findall(r'<text[^>]*>([^<]+)</text>', xml_content, re.DOTALL)
        
        print(f"Found {len(text_matches)} text elements in XML")
        
        if text_matches:
            print(f"Raw text matches found: {len(text_matches)} elements")
            
            # Join all text with absolutely minimal processing to capture everything
            raw_transcript = ' '.join(text_matches)
            print(f"Raw joined transcript: {len(raw_transcript)} characters")
            
            # Only normalize whitespace, keep all content
            full_transcript = raw_transcript.replace('\xa0', ' ').replace('\n', ' ')
            full_transcript = re.sub(r'\s+', ' ', full_transcript).strip()
            
            print(f"Final processed transcript: {len(full_transcript)} characters from {len(text_matches)} text elements")
            
            # Ensure we're getting the complete content
            if len(full_transcript) < 38000:
                print(f"WARNING: Transcript may be incomplete - only {len(full_transcript)} chars (expected ~38K+)")
            
            return full_transcript
        
        # If no text elements found, try extracting all content between tags
        print("No text elements found, trying fallback extraction")
        simple_text = re.sub(r'<[^>]+>', ' ', xml_content)
        cleaned_fallback = self._clean_text(simple_text)
        print(f"Fallback extraction: {len(cleaned_fallback)} characters")
        return cleaned_fallback

    def _parse_json_captions(self, json_content: str) -> str:
        """Parse JSON caption format"""
        try:
            data = json.loads(json_content)
            
            # Handle YouTube's JSON3 format
            if 'events' in data:
                text_parts = []
                for event in data['events']:
                    if 'segs' in event:
                        for seg in event['segs']:
                            if 'utf8' in seg:
                                text_parts.append(seg['utf8'])
                    # Also check for direct text in events
                    elif 'utf8' in event:
                        text_parts.append(event['utf8'])
                
                if text_parts:
                    full_transcript = ' '.join([self._clean_text(text) for text in text_parts if text])
                    print(f"Extracted {len(full_transcript)} characters from JSON captions")
                    return full_transcript
            
            # Handle other JSON formats that might have text arrays
            if 'body' in data and isinstance(data['body'], list):
                text_parts = []
                for item in data['body']:
                    if isinstance(item, dict) and 'utf8' in item:
                        text_parts.append(item['utf8'])
                    elif isinstance(item, str):
                        text_parts.append(item)
                
                if text_parts:
                    full_transcript = ' '.join([self._clean_text(text) for text in text_parts if text])
                    print(f"Extracted {len(full_transcript)} characters from JSON body")
                    return full_transcript
            
            return None
            
        except json.JSONDecodeError as e:
            print(f"JSON decode error: {e}")
            return None

    def _clean_text(self, text: str) -> str:
        """Clean and normalize text while preserving maximum content"""
        if not text:
            return ""
        
        # Decode HTML entities more comprehensively
        text = text.replace('&amp;', '&').replace('&lt;', '<').replace('&gt;', '>')
        text = text.replace('&quot;', '"').replace('&#39;', "'").replace('&apos;', "'")
        text = text.replace('&nbsp;', ' ')
        
        # Handle special unicode characters that YouTube uses
        text = text.replace('\xa0', ' ')  # Non-breaking space
        text = text.replace('\n', ' ')   # Convert newlines to spaces
        
        # Normalize whitespace but preserve content
        text = re.sub(r'\s+', ' ', text)
        
        # Only remove very obvious caption artifacts, keep everything else
        text = re.sub(r'\[Music\]', '', text, flags=re.IGNORECASE)
        text = re.sub(r'\[Applause\]', '', text, flags=re.IGNORECASE)
        
        return text.strip()

if __name__ == "__main__":
    scraper = CaptionScraper()
    result = scraper.extract_captions_from_page("dQw4w9WgXcQ")
    if result:
        print(f"Title: {result['title']}")
        print(f"Transcript: {result['transcript'][:200]}...")
    else:
        print("Failed to extract captions")

================
File: server/complete_caption_scraper.py
================
import re
import requests
import json
import html
import sys
import time
import random
from typing import Optional, Dict, Tuple

def extract_complete_transcript(video_id: str) -> Optional[str]:
    """Extract the complete YouTube transcript with maximum content preservation"""
    
    session = requests.Session()
    session.headers.update({
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
        'Referer': 'https://www.google.com/',
        'sec-ch-ua': '"Chromium";v="122", "Not(A:Brand";v="24", "Google Chrome";v="122"',
        'sec-ch-ua-mobile': '?0',
        'sec-ch-ua-platform': '"Windows"',
    })
    
    try:
        print(f"Starting transcript extraction for video ID: {video_id}")
        
        # Get the video page
        url = f"https://www.youtube.com/watch?v={video_id}"
        print(f"Fetching main video page: {url}")
        
        # Add retry mechanism
        max_retries = 3
        for attempt in range(max_retries):
            try:
                response = session.get(url, timeout=15)
                break
            except requests.exceptions.RequestException as e:
                if attempt < max_retries - 1:
                    wait_time = 2 * (attempt + 1) + random.uniform(0, 1)
                    print(f"Request failed, retrying in {wait_time:.1f}s: {e}")
                    time.sleep(wait_time)
                else:
                    raise
        
        print(f"Video page response status: {response.status_code}")
        
        if response.status_code != 200:
            print(f"Failed to fetch video page: HTTP {response.status_code}")
            return None
        
        html_content = response.text
        html_length = len(html_content)
        print(f"Received HTML content: {html_length} characters")
        
        if html_length < 5000:
            print("Warning: HTML content is suspiciously short, likely not complete")
            with open(f"debug_html_{video_id}.txt", "w", encoding="utf-8") as f:
                f.write(html_content)
            print(f"Saved debug HTML to debug_html_{video_id}.txt")
        
        # Extract player configuration
        player_config_pattern = r'ytInitialPlayerResponse\s*=\s*({.+?});'
        match = re.search(player_config_pattern, html_content)
        
        if not match:
            print("Failed to extract player configuration from HTML")
            
            # Try alternative pattern
            alt_pattern = r'"captions":({.+?}),"videoDetails"'
            alt_match = re.search(alt_pattern, html_content)
            
            if alt_match:
                print("Found captions data with alternative pattern")
                captions_data = json.loads(alt_match.group(1))
                # Process as needed
            else:
                print("Could not find caption data with any pattern")
                return None
        
        config_json = match.group(1)
        
        try:
            player_data = json.loads(config_json)
        except json.JSONDecodeError as e:
            print(f"Failed to parse player JSON: {e}")
            return None
        
        # Navigate to captions
        captions = player_data.get('captions', {})
        if not captions:
            print("No captions data found in player config")
            return None
            
        caption_tracks = captions.get('playerCaptionsTracklistRenderer', {}).get('captionTracks', [])
        
        if not caption_tracks:
            print("No caption tracks found in player config")
            return None
            
        print(f"Found {len(caption_tracks)} caption tracks")
        
        # Find English captions (or any available captions if English not found)
        english_track = None
        available_tracks = []
        
        for idx, track in enumerate(caption_tracks):
            lang = track.get('languageCode', '')
            name = track.get('name', {}).get('simpleText', '')
            kind = track.get('kind', '')
            base_url = track.get('baseUrl', '')
            
            track_info = f"Track {idx}: lang={lang}, name={name}, kind={kind}, has_url={'Yes' if base_url else 'No'}"
            available_tracks.append(track_info)
            print(track_info)
            
            if lang.startswith('en'):
                if not english_track or kind != 'asr':  # Prefer manual over auto-generated
                    english_track = track
        
        # If no English track, use the first available track
        if not english_track and caption_tracks:
            english_track = caption_tracks[0]
            print(f"No English track found, using {english_track.get('languageCode', 'unknown')} track instead")
        
        if not english_track or 'baseUrl' not in english_track:
            print(f"No suitable caption track found. Available tracks: {len(available_tracks)}")
            for track in available_tracks:
                print(f"  {track}")
            return None
        
        # Download caption file
        caption_url = english_track['baseUrl']
        print(f"Using caption URL: {caption_url[:100]}...")
        
        try:
            caption_response = session.get(caption_url, timeout=10)
        except requests.exceptions.RequestException as e:
            print(f"Failed to fetch caption data: {e}")
            return None
        
        if caption_response.status_code != 200:
            print(f"Caption request failed: HTTP {caption_response.status_code}")
            return None
        
        caption_content = caption_response.text
        print(f"Received caption content: {len(caption_content)} characters")
        
        # Extract ALL text elements
        text_matches = re.findall(r'<text[^>]*>([^<]+)</text>', caption_content, re.DOTALL)
        
        if not text_matches:
            print("No caption text matches found in response")
            
            # Try alternative caption format parsing
            text_matches = extract_captions_from_alternative_format(caption_content)
            if not text_matches:
                return None
        
        print(f"Extracted {len(text_matches)} caption segments")
        
        # Join with minimal processing - preserve maximum content
        complete_transcript = ' '.join(text_matches)
        
        # Decode HTML entities first
        complete_transcript = html.unescape(complete_transcript)
        
        # Only essential normalization
        complete_transcript = complete_transcript.replace('\xa0', ' ')  # Non-breaking spaces
        complete_transcript = complete_transcript.replace('\n', ' ')   # Newlines to spaces
        complete_transcript = re.sub(r'\s+', ' ', complete_transcript)  # Multiple spaces to single
        complete_transcript = complete_transcript.strip()
        
        transcript_length = len(complete_transcript)
        print(f"Complete transcript extracted: {transcript_length} characters from {len(text_matches)} elements")
        
        if transcript_length < 50:
            print(f"Warning: Extracted transcript is too short ({transcript_length} chars)")
            return None
        
        return complete_transcript
        
    except Exception as e:
        import traceback
        trace = traceback.format_exc()
        print(f"Error extracting complete transcript: {e}")
        print(f"Traceback: {trace}")
        return None

def extract_captions_from_alternative_format(content: str) -> list:
    """Try to extract captions from alternative formats"""
    
    # Try JSON format
    if content.strip().startswith('{'):
        try:
            data = json.loads(content)
            if 'events' in data:
                texts = []
                for event in data['events']:
                    if 'segs' in event.get('tStartMs', {}):
                        for seg in event['segs']:
                            if 'utf8' in seg:
                                texts.append(seg['utf8'])
                return texts
        except json.JSONDecodeError:
            pass
    
    # Try different XML formats
    xml_patterns = [
        r'<transcript>(.+?)</transcript>',
        r'<timedtext>(.+?)</timedtext>'
    ]
    
    for pattern in xml_patterns:
        match = re.search(pattern, content, re.DOTALL)
        if match:
            text_parts = re.findall(r'<text[^>]*>([^<]+)</text>', match.group(1), re.DOTALL)
            if text_parts:
                return text_parts
    
    return []

if __name__ == "__main__":
    if len(sys.argv) > 1:
        video_id = sys.argv[1]
    else:
        video_id = "59aRc_KCu3s"  # Default test video
        
    result = extract_complete_transcript(video_id)
    if result:
        print(f"Success: {len(result)} characters")
        print(f"Preview: {result[:100]}...")
    else:
        print("Failed to extract transcript")
        sys.exit(1)

================
File: server/db.ts
================
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import dotenv from 'dotenv';
import * as schema from '@shared/schema';

// Load environment variables
dotenv.config();

// Ensure the database URL is available
if (!process.env.DATABASE_URL) {
  throw new Error('DATABASE_URL environment variable is not set');
}

// Create the connection
const client = postgres(process.env.DATABASE_URL);

// Create the Drizzle instance with schema
export const db = drizzle(client, { schema });

================
File: server/index.ts
================
import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";
import session from "express-session";

const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: false }));

// Set up session middleware with a simple cookie-based session
app.use(session({
  secret: 'podster-admin-secret',
  resave: false,
  saveUninitialized: false,
  cookie: { 
    secure: process.env.NODE_ENV === 'production',
    maxAge: 24 * 60 * 60 * 1000 // 24 hours
  }
}));

// Declare session properties for TypeScript
declare module 'express-session' {
  interface SessionData {
    isAdmin: boolean;
  }
}

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "â€¦";
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  const server = await registerRoutes(app);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    res.status(status).json({ message });
    throw err;
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  // ALWAYS serve the app on port 5000
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  const port = 5000;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true,
  }, () => {
    log(`serving on port ${port}`);
  });
})();

================
File: server/keyword-analyzer.ts
================
import { OpenAI } from 'openai';

// Simple in-memory cache for keyword analysis results
const analysisCache = new Map<string, AnalysisResult>();

export interface KeywordHighlight {
  keyword: string;
  category: 'important' | 'technical' | 'name' | 'concept' | 'action';
  confidence: number;
  positions: Array<{
    start: number;
    end: number;
  }>;
}

export interface AnalysisResult {
  keywords: KeywordHighlight[];
  categories: {
    important: string[];
    technical: string[];
    name: string[];
    concept: string[];
    action: string[];
  };
}

export class KeywordAnalyzer {
  private openai: OpenAI;
  private readonly timeout = 30000; // 30 second timeout
  private readonly maxChunkSize = 1500; // Reduced chunk size for faster processing
  
  constructor(apiKey?: string) {
    this.openai = new OpenAI({ 
      apiKey: apiKey || process.env.OPENAI_API_KEY 
    });
  }
  
  async analyzeText(transcript: string): Promise<AnalysisResult> {
    try {
      // Generate a cache key (use a hash of the transcript or first 100 chars)
      const cacheKey = transcript.substring(0, 100);
      
      // Check cache first
      if (analysisCache.has(cacheKey)) {
        console.log("Using cached keyword analysis");
        return analysisCache.get(cacheKey)!;
      }
      
      console.log(`Starting keyword analysis of ${transcript.length} characters`);
      
      // Limit transcript size if extremely large
      const trimmedTranscript = transcript.length > 10000 
        ? transcript.substring(0, 10000) + "..." 
        : transcript;
      
      // Split transcript into manageable chunks
      const chunks = this.splitIntoChunks(trimmedTranscript, this.maxChunkSize);
      console.log(`Split into ${chunks.length} chunks`);

      const allKeywords: KeywordHighlight[] = [];
      
      // Process only the first few chunks for very long texts
      const maxChunks = Math.min(chunks.length, 3);
      
      for (let i = 0; i < maxChunks; i++) {
        console.log(`Processing chunk ${i+1}/${maxChunks}`);
        try {
          // Add timeout handling
          const chunkKeywords = await Promise.race([
            this.analyzeChunk(chunks[i]),
            new Promise<KeywordHighlight[]>((_, reject) => 
              setTimeout(() => reject(new Error("Keyword analysis timeout")), this.timeout)
            )
          ]);
          allKeywords.push(...chunkKeywords);
        } catch (error) {
          console.error(`Error analyzing chunk ${i+1}:`, error);
          // Continue with other chunks if one fails
        }
      }

      // If we have no keywords but there are chunks, use a fallback approach
      if (allKeywords.length === 0 && chunks.length > 0) {
        console.log("Using fallback keyword extraction approach");
        allKeywords.push(...this.extractKeywordsFallback(trimmedTranscript));
      }

      // Merge duplicate keywords and find their positions
      const mergedKeywords = this.mergeAndFindPositions(allKeywords, trimmedTranscript);
      
      // Categorize keywords
      const categories = this.categorizeKeywords(mergedKeywords);

      const result = {
        keywords: mergedKeywords,
        categories
      };
      
      // Cache the result
      analysisCache.set(cacheKey, result);
      
      return result;
    } catch (error) {
      console.error("Error analyzing keywords:", error);
      // Return a basic result instead of throwing
      return {
        keywords: [],
        categories: {
          important: [],
          technical: [],
          name: [],
          concept: [],
          action: []
        }
      };
    }
  }
  
  private splitIntoChunks(text: string, maxSize: number): string[] {
    const chunks: string[] = [];
    const sentences = text.split(/[.!?]+/);
    let currentChunk = '';
    
    for (const sentence of sentences) {
      if (currentChunk.length + sentence.length > maxSize && currentChunk.length > 0) {
        chunks.push(currentChunk.trim());
        currentChunk = sentence;
      } else {
        currentChunk += (currentChunk ? '. ' : '') + sentence;
      }
    }
    
    if (currentChunk.trim()) {
      chunks.push(currentChunk.trim());
    }
    
    return chunks;
  }
  
  private async analyzeChunk(text: string): Promise<KeywordHighlight[]> {
    console.log(`Analyzing chunk of ${text.length} characters`);
    const startTime = Date.now();
    
    try {
      const response = await this.openai.chat.completions.create({
        model: "gpt-3.5-turbo", // Using a faster model
        messages: [
          {
            role: "system",
            content: `Extract the most important keywords from the text. Categorize each as: important, technical, name, concept, or action. Provide a confidence score (0-1).

Return JSON format:
{
  "keywords": [
    {
      "keyword": "exact phrase",
      "category": "important|technical|name|concept|action",
      "confidence": 0.95
    }
  ]
}`
          },
          {
            role: "user",
            content: text
          }
        ],
        response_format: { type: "json_object" },
        temperature: 0.3,
        max_tokens: 500 // Reduced for faster response
      }, {
        timeout: this.timeout // Set timeout as an option parameter instead
      });

      const processingTime = Date.now() - startTime;
      console.log(`OpenAI processing time: ${processingTime}ms`);

      const result = JSON.parse(response.choices[0].message.content || '{"keywords":[]}');
      
      return result.keywords.map((kw: any) => ({
        keyword: kw.keyword,
        category: kw.category as 'important' | 'technical' | 'name' | 'concept' | 'action',
        confidence: kw.confidence,
        positions: []
      }));
    } catch (error) {
      console.error(`OpenAI API error after ${Date.now() - startTime}ms:`, error);
      throw error;
    }
  }
  
  // Simple fallback method that doesn't use AI
  private extractKeywordsFallback(text: string): KeywordHighlight[] {
    console.log("Using fallback keyword extraction");
    
    // Split into words and count frequencies
    const words = text.toLowerCase().match(/\b\w+\b/g) || [];
    const wordCounts = new Map<string, number>();
    
    for (const word of words) {
      if (word.length < 3) continue; // Skip short words
      wordCounts.set(word, (wordCounts.get(word) || 0) + 1);
    }
    
    // Convert to array and sort by frequency
    const sortedWords = Array.from(wordCounts.entries())
      .filter(([word, count]) => count > 1 && word.length > 3) // Only words that appear multiple times
      .sort((a, b) => b[1] - a[1])
      .slice(0, 20); // Top 20 words
    
    // Convert to keywords
    return sortedWords.map(([word, count]) => {
      // Assign a category based on simple rules
      let category: 'important' | 'technical' | 'name' | 'concept' | 'action' = 'important';
      
      // Simple heuristics for categorization
      if (/^[A-Z]/.test(word)) {
        category = 'name';
      } else if (/ing$/.test(word)) {
        category = 'action';
      } else if (/tion$|ment$|ity$|ism$/.test(word)) {
        category = 'concept';
      } else if (/ology$|ical$|tech|data|code/.test(word)) {
        category = 'technical';
      }
      
      return {
        keyword: word,
        category,
        confidence: Math.min(0.7, count / 50), // Scale confidence by frequency
        positions: []
      };
    });
  }
  
  private mergeAndFindPositions(keywords: KeywordHighlight[], fullText: string): KeywordHighlight[] {
    const keywordMap = new Map<string, KeywordHighlight>();
    
    // Merge duplicate keywords
    for (const keyword of keywords) {
      const key = keyword.keyword.toLowerCase();
      if (keywordMap.has(key)) {
        const existing = keywordMap.get(key)!;
        existing.confidence = Math.max(existing.confidence, keyword.confidence);
      } else {
        keywordMap.set(key, { ...keyword, positions: [] });
      }
    }
    
    // Find all positions of each keyword in the full text
    const result: KeywordHighlight[] = [];
    
    for (const keyword of Array.from(keywordMap.values())) {
      const positions = this.findAllPositions(fullText, keyword.keyword);
      if (positions.length > 0) {
        result.push({
          ...keyword,
          positions
        });
      }
    }
    
    return result.sort((a, b) => b.confidence - a.confidence);
  }
  
  private findAllPositions(text: string, keyword: string): Array<{start: number, end: number}> {
    const positions: Array<{start: number, end: number}> = [];
    const lowerText = text.toLowerCase();
    const lowerKeyword = keyword.toLowerCase();
    
    let startIndex = 0;
    while (true) {
      const index = lowerText.indexOf(lowerKeyword, startIndex);
      if (index === -1) break;
      
      // Check if this is a whole word match
      const prevChar = index > 0 ? lowerText[index - 1] : ' ';
      const nextChar = index + lowerKeyword.length < lowerText.length 
        ? lowerText[index + lowerKeyword.length] 
        : ' ';
      
      // Strict word boundary check - only non-alphanumeric characters are boundaries
      const isPrevBoundary = /[^a-z0-9]/.test(prevChar);
      const isNextBoundary = /[^a-z0-9]/.test(nextChar);
      
      if (isPrevBoundary && isNextBoundary) {
        // Ensure we're using the exact length from the original text
        const exactKeyword = text.substring(index, index + keyword.length);
        positions.push({
          start: index,
          end: index + exactKeyword.length
        });
      }
      
      // Move past this occurrence to find the next one
      startIndex = index + 1;
    }
    
    return positions;
  }
  
  private categorizeKeywords(keywords: KeywordHighlight[]): AnalysisResult['categories'] {
    const categories: AnalysisResult['categories'] = {
      important: [],
      technical: [],
      name: [],
      concept: [],
      action: []
    };
    
    for (const keyword of keywords) {
      switch (keyword.category) {
        case 'important':
          categories.important.push(keyword.keyword);
          break;
        case 'technical':
          categories.technical.push(keyword.keyword);
          break;
        case 'name':
          categories.name.push(keyword.keyword);
          break;
        case 'concept':
          categories.concept.push(keyword.keyword);
          break;
        case 'action':
          categories.action.push(keyword.keyword);
          break;
      }
    }
    
    return categories;
  }
}

================
File: server/migrate.ts
================
import { db } from './db';
import { users, episodes, searchQueries, processingQueue } from '@shared/schema';
import { drizzle } from 'drizzle-orm/postgres-js';
import { migrate } from 'drizzle-orm/postgres-js/migrator';
import postgres from 'postgres';
import dotenv from 'dotenv';
import { eq } from 'drizzle-orm';
import fs from 'fs';
import path from 'path';

dotenv.config();

// For migration, we need a separate connection
const migrationClient = postgres(process.env.DATABASE_URL!, { max: 1 });

async function main() {
  try {
    console.log('Starting database migration...');
    
    // Ensure migrations directory exists
    const migrationsDir = './migrations';
    const metaDir = path.join(migrationsDir, 'meta');
    
    if (!fs.existsSync(migrationsDir)) {
      fs.mkdirSync(migrationsDir, { recursive: true });
      console.log('Created migrations directory');
    }
    
    if (!fs.existsSync(metaDir)) {
      fs.mkdirSync(metaDir, { recursive: true });
      console.log('Created migrations meta directory');
    }
    
    // Create an empty journal file if it doesn't exist
    const journalPath = path.join(metaDir, '_journal.json');
    if (!fs.existsSync(journalPath)) {
      fs.writeFileSync(journalPath, JSON.stringify({ entries: [] }));
      console.log('Created empty journal file');
    }
    
    // Perform migration
    await migrate(drizzle(migrationClient), { migrationsFolder: migrationsDir });
    
    console.log('Migration completed successfully');
    
    // Seed initial admin user if needed
    const adminExists = await db.select().from(users).where(eq(users.username, 'admin'));
    
    if (adminExists.length === 0) {
      console.log('Creating default admin user...');
      await db.insert(users).values({
        username: "admin",
        email: "admin@transcriptai.com",
        password: "$2b$10$defaulthashedpassword", // In real app, this would be properly hashed
        role: "admin"
      });
      console.log('Default admin user created');
    }
    
    console.log('Database setup complete');
  } catch (error) {
    console.error('Migration failed:', error);
    process.exit(1);
  } finally {
    await migrationClient.end();
    process.exit(0);
  }
}

main();

================
File: server/puppeteer_caption_scraper.js
================
import puppeteer from 'puppeteer';

/**
 * Extract YouTube captions using browser automation
 * This is a fallback method when other extraction methods fail
 * 
 * @param {string} videoId - YouTube video ID
 * @returns {Promise<string>} - The extracted transcript or null if failed
 */
export async function extractCaptionsWithPuppeteer(videoId) {
  console.log(`Starting Puppeteer extraction for video: ${videoId}`);
  let browser = null;
  
  try {
    // Launch browser in headless mode
    browser = await puppeteer.launch({
      headless: 'new',
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--disable-gpu',
        '--window-size=1280,720',
      ]
    });
    
    const page = await browser.newPage();
    
    // Set user agent to mimic real browser
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36');
    
    // Set extra HTTP headers
    await page.setExtraHTTPHeaders({
      'Accept-Language': 'en-US,en;q=0.9',
    });
    
    // Enable request interception to monitor network
    await page.setRequestInterception(true);
    
    let captionsData = null;
    
    // Listen for network requests to capture captions
    page.on('request', request => {
      request.continue();
    });
    
    page.on('response', async response => {
      const url = response.url();
      
      // Capture timedtext responses
      if (url.includes('timedtext') && url.includes('lang=en')) {
        try {
          const text = await response.text();
          console.log(`Captured captions data: ${text.length} bytes`);
          captionsData = text;
        } catch (e) {
          console.error(`Failed to read captions response: ${e.message}`);
        }
      }
    });
    
    // Navigate to video page
    console.log(`Navigating to YouTube video: ${videoId}`);
    await page.goto(`https://www.youtube.com/watch?v=${videoId}`, {
      waitUntil: 'networkidle2',
      timeout: 30000
    });
    
    console.log('Page loaded, looking for captions button');
    
    // Wait for the video player to load
    await page.waitForSelector('.ytp-chrome-bottom', { timeout: 15000 });
    
    // Try to enable captions by clicking the CC button
    try {
      // Find and click the CC button if it exists
      const ccButton = await page.$('.ytp-subtitles-button');
      if (ccButton) {
        console.log('Found CC button, clicking...');
        await ccButton.click();
        // Wait a bit to capture captions
        await page.waitForTimeout(2000);
      } else {
        console.log('CC button not found');
      }
    } catch (e) {
      console.log(`Failed to click CC button: ${e.message}`);
    }
    
    if (!captionsData) {
      console.log('No captions data captured via network, trying alternate method');
      
      // Try to extract from player data in page
      try {
        captionsData = await page.evaluate(() => {
          // Try to find the ytInitialPlayerResponse
          const scriptText = Array.from(document.querySelectorAll('script'))
            .map(script => script.textContent)
            .find(text => text && text.includes('captionTracks'));
          
          if (!scriptText) return null;
          
          // Extract caption tracks
          const match = scriptText.match(/ytInitialPlayerResponse\s*=\s*({.+?});/);
          if (!match) return null;
          
          try {
            const playerData = JSON.parse(match[1]);
            const captions = playerData?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
            
            if (!captions || !captions.length) return null;
            
            // Find English captions
            const englishTrack = captions.find(track => 
              track.languageCode && track.languageCode.startsWith('en')
            );
            
            if (!englishTrack || !englishTrack.baseUrl) return null;
            
            return englishTrack.baseUrl;
          } catch (e) {
            console.error('Error parsing player data:', e);
            return null;
          }
        });
        
        if (captionsData) {
          console.log('Found caption URL in page data, fetching captions');
          // Make a separate request to get the caption data
          const captionPage = await browser.newPage();
          const response = await captionPage.goto(captionsData, { 
            waitUntil: 'networkidle0',
            timeout: 10000
          });
          captionsData = await response.text();
          await captionPage.close();
        }
      } catch (e) {
        console.error(`Error extracting captions from page: ${e.message}`);
      }
    }
    
    // If we still don't have captions, try one last method
    if (!captionsData) {
      console.log('Still no captions, trying transcript page');
      try {
        // Go to transcript page
        await page.goto(`https://www.youtube.com/watch?v=${videoId}&hl=en`, {
          waitUntil: 'networkidle2',
          timeout: 15000
        });
        
        // Try to open transcript panel
        const moreActions = await page.$('button[aria-label="More actions"]');
        if (moreActions) {
          await moreActions.click();
          
          // Wait for menu to appear
          await page.waitForTimeout(1000);
          
          // Look for "Show transcript" option and click it
          const menuItems = await page.$$('tp-yt-paper-item');
          for (const item of menuItems) {
            const text = await page.evaluate(el => el.textContent, item);
            if (text && text.includes('transcript')) {
              await item.click();
              
              // Wait for transcript panel to appear
              await page.waitForTimeout(2000);
              
              // Extract transcript text
              const transcriptSegments = await page.$$eval(
                'yt-formatted-string.ytd-transcript-segment-renderer', 
                segments => segments.map(s => s.textContent.trim())
              );
              
              if (transcriptSegments && transcriptSegments.length > 0) {
                captionsData = transcriptSegments.join(' ');
                console.log(`Extracted ${transcriptSegments.length} transcript segments`);
              }
              
              break;
            }
          }
        }
      } catch (e) {
        console.error(`Error with transcript page: ${e.message}`);
      }
    }
    
    if (!captionsData) {
      console.log('Failed to extract captions with all methods');
      return null;
    }
    
    // Parse the captions data
    let transcriptText = '';
    
    if (typeof captionsData === 'string') {
      if (captionsData.includes('<text')) {
        // XML format
        const textMatches = captionsData.match(/<text[^>]*>([^<]+)<\/text>/g);
        if (textMatches) {
          transcriptText = textMatches.map(match => {
            const textContent = match.replace(/<[^>]+>/g, '');
            return decodeHTMLEntities(textContent);
          }).join(' ');
        }
      } else if (captionsData.startsWith('{')) {
        // JSON format (try parsing)
        try {
          const data = JSON.parse(captionsData);
          if (data.events) {
            transcriptText = data.events
              .filter(event => event.segs)
              .flatMap(event => event.segs)
              .filter(seg => seg.utf8)
              .map(seg => seg.utf8)
              .join(' ');
          }
        } catch (e) {
          console.error(`Failed to parse JSON captions: ${e.message}`);
        }
      } else {
        // Plain text or other format
        transcriptText = captionsData.replace(/\n/g, ' ').trim();
      }
    }
    
    // Clean up transcript
    transcriptText = transcriptText
      .replace(/\s+/g, ' ')
      .trim();
    
    console.log(`Final transcript length: ${transcriptText.length} characters`);
    
    return transcriptText.length > 50 ? transcriptText : null;
  } catch (error) {
    console.error(`Puppeteer extraction error: ${error.message}`);
    return null;
  } finally {
    // Always close the browser
    if (browser) {
      await browser.close();
    }
  }
}

// Helper function to decode HTML entities
function decodeHTMLEntities(text) {
  const entities = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&nbsp;': ' '
  };
  
  return text.replace(/&amp;|&lt;|&gt;|&quot;|&#39;|&nbsp;/g, match => entities[match]);
}

// Test the function directly if run as script
if (import.meta.url === `file://${process.argv[1]}`) {
  const videoId = process.argv[2] || 'cbfbS18mcUY';  // Default to the video ID from error logs
  
  (async () => {
    try {
      console.log(`Testing Puppeteer extraction with video ID: ${videoId}`);
      const transcript = await extractCaptionsWithPuppeteer(videoId);
      if (transcript) {
        console.log(`Success! Extracted ${transcript.length} characters`);
        console.log(`Preview: ${transcript.substring(0, 150)}...`);
      } else {
        console.log('Failed to extract transcript');
        process.exit(1);
      }
    } catch (e) {
      console.error(`Error during extraction: ${e.message}`);
      process.exit(1);
    }
  })();
}

================
File: server/routes.ts
================
import type { Express } from "express";
import { createServer, type Server } from "http";
import { spawn } from "child_process";
import { storage } from "./storage";
import { insertEpisodeSchema, insertUserSchema, insertSearchQuerySchema } from "@shared/schema";
import { z } from "zod";
import dotenv from "dotenv";
import path from "path";
import { TsCaptionScraper } from "./ts-caption-scraper";
import { TsAdvancedScraper } from "./ts-advanced-scraper";
import { KeywordAnalyzer } from "./keyword-analyzer";

dotenv.config();

// Initialize the caption scrapers
const captionScraper = new TsCaptionScraper();
const advancedScraper = new TsAdvancedScraper();
const keywordAnalyzer = new KeywordAnalyzer();

// Mock YouTube processing functions
const extractVideoInfo = async (url: string) => {
  const videoId = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/)?.[1];
  if (!videoId) throw new Error("Invalid YouTube URL");
  
  try {
    // Use YouTube oEmbed API for real video data
    const response = await fetch(`https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch video information: ${response.status}`);
    }
    
    const data = await response.json();
    
    return {
      videoId,
      title: data.title,
      description: null,
      channel: data.author_name,
      duration: null,
      thumbnailUrl: data.thumbnail_url
    };
  } catch (error: any) {
    console.error('Error fetching real video info:', error);
    throw new Error(`Cannot extract video information: ${error.message}`);
  }
};

const extractTranscript = async (videoId: string, method: string) => {
  try {
    console.log(`Extracting real transcript for video ${videoId} using ${method} method`);
    
    if (method === "youtube") {
      // Try YouTube API method first if selected
      // ... existing code ...
    }
    
    if (method === "scraping") {
      console.log("Using web scraping method for transcript extraction");
      
      // Try each extraction method in sequence, from simplest to most complex
      
      // 1. First try the basic TypeScript scraper
      try {
        console.log("Using basic TypeScript caption scraper");
        const result = await captionScraper.extractCaptions(videoId);
        
        if (result && result.transcript && result.transcript.length > 100) {
          console.log(`Successfully extracted ${result.transcript.length} characters with basic TypeScript scraper`);
          return result.transcript;
        } else {
          console.log("Basic TypeScript scraper failed or returned insufficient data, trying advanced methods");
        }
      } catch (error) {
        const scrapingError = error as Error;
        console.error(`Basic TypeScript scraper error: ${scrapingError.message}`);
        console.log("Trying advanced extraction methods");
      }
      
      // 2. Try the advanced TypeScript scraper with multiple extraction techniques
      try {
        console.log("Using advanced TypeScript caption scraper");
        const advancedResult = await advancedScraper.extractCaptions(videoId);
        
        if (advancedResult && advancedResult.transcript && advancedResult.transcript.length > 100) {
          console.log(`Successfully extracted ${advancedResult.transcript.length} characters with advanced TypeScript scraper`);
          return advancedResult.transcript;
        } else {
          console.log("Advanced TypeScript scraper failed or returned insufficient data, trying Puppeteer fallback");
        }
      } catch (error) {
        const advancedError = error as Error;
        console.error(`Advanced TypeScript scraper error: ${advancedError.message}`);
        console.log("Falling back to Puppeteer method");
      }
      
      // 3. As a last resort, try Puppeteer browser automation
      try {
        console.log("Attempting to extract transcript with Puppeteer");
        // Dynamic import of the Puppeteer module
        const puppeteerModule = await import('./puppeteer_caption_scraper.js');
        const puppeteerTranscript = await puppeteerModule.extractCaptionsWithPuppeteer(videoId);
        
        if (puppeteerTranscript && puppeteerTranscript.length > 100) {
          console.log(`Successfully extracted transcript with Puppeteer: ${puppeteerTranscript.length} chars`);
          return puppeteerTranscript;
        } else {
          throw new Error("Puppeteer extraction failed or returned insufficient data");
        }
      } catch (error) {
        const puppeteerError = error as Error;
        console.error(`Puppeteer extraction error: ${puppeteerError.message}`);
        throw new Error(`All web scraping methods failed: ${puppeteerError.message}`);
      }
    }
    
    if (method === "audio") {
      throw new Error("Audio extraction requires additional setup. Please try Caption-Based or Web Scraping methods first.");
    }
    
    throw new Error(`Unsupported extraction method: ${method}`);
    
  } catch (error: any) {
    console.error(`Transcript extraction failed: ${error.message}`);
    throw new Error(`Cannot extract real transcript: ${error.message}`);
  }
};

const generateSummary = async (transcript: string) => {
  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: 'You are an expert at creating concise, informative summaries of video transcripts. Create a 2-3 sentence summary that captures the main points and key insights.'
          },
          {
            role: 'user',
            content: `Please summarize this video transcript:\n\n${transcript}`
          }
        ],
        max_tokens: 150,
        temperature: 0.3,
      }),
    });

    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.status}`);
    }

    const data = await response.json();
    return data.choices[0]?.message?.content || "Summary could not be generated.";
  } catch (error) {
    console.error('Error generating summary:', error);
    return "AI summary generation temporarily unavailable.";
  }
};

const extractTopics = async (transcript: string) => {
  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: 'You are an expert at identifying key topics and themes from video transcripts. Extract 3-6 main topics as single words or short phrases. Return only the topics separated by commas.'
          },
          {
            role: 'user',
            content: `Extract the main topics from this video transcript:\n\n${transcript}`
          }
        ],
        max_tokens: 100,
        temperature: 0.2,
      }),
    });

    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.status}`);
    }

    const data = await response.json();
    const topicsString = data.choices[0]?.message?.content || "";
    return topicsString.split(',').map((topic: string) => topic.trim()).filter((topic: string) => topic.length > 0);
  } catch (error) {
    console.error('Error extracting topics:', error);
    return ["AI topic extraction temporarily unavailable"];
  }
};

// Function to process episodes automatically with progress tracking
const processEpisode = async (episodeId: number, options: { generateSummary?: boolean; extractTopics?: boolean }) => {
  try {
    const episode = await storage.getEpisode(episodeId);
    if (!episode) {
      console.error(`Episode ${episodeId} not found`);
      return;
    }

    console.log(`Starting processing for episode ${episodeId} with method: ${episode.extractionMethod}`);
    
    // Step 1: Initialize processing (10%)
    await storage.updateEpisode(episodeId, { 
      status: "processing",
      progress: 10,
      currentStep: "Initializing extraction",
      processingStarted: new Date()
    });
    await new Promise(resolve => setTimeout(resolve, 1500));

    // Step 2: Extract transcript (60%)
    await storage.updateEpisode(episodeId, { 
      progress: 30,
      currentStep: "Extracting transcript"
    });
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const transcript = await extractTranscript(episode.videoId, episode.extractionMethod);
    const wordCount = transcript.split(/\s+/).length;
    
    await storage.updateEpisode(episodeId, { 
      progress: 60,
      currentStep: "Transcript extracted successfully"
    });
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    let summary = null;
    let topics: string[] = [];
    
    // Step 3: Generate AI content if requested
    if (options.generateSummary) {
      await storage.updateEpisode(episodeId, { 
        progress: 70,
        currentStep: "Generating AI summary"
      });
      console.log(`Generating AI summary for episode ${episodeId}`);
      summary = await generateSummary(transcript);
      await new Promise(resolve => setTimeout(resolve, 200));
    }
    
    if (options.extractTopics) {
      await storage.updateEpisode(episodeId, { 
        progress: 85,
        currentStep: "Extracting key topics"
      });
      console.log(`Extracting AI topics for episode ${episodeId}`);
      topics = await extractTopics(transcript);
      await new Promise(resolve => setTimeout(resolve, 200));
    }
    
    // Step 4: Finalize (100%)
    await storage.updateEpisode(episodeId, { 
      progress: 95,
      currentStep: "Finalizing processing"
    });
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // Complete processing
    await storage.updateEpisode(episodeId, {
      status: "completed",
      transcript,
      summary,
      topics,
      wordCount,
      progress: 100,
      currentStep: "Processing completed",
      processingCompleted: new Date()
    });

    console.log(`Processing completed for episode ${episodeId}`);
  } catch (error: any) {
    console.error(`Processing failed for episode ${episodeId}:`, error);
    await storage.updateEpisode(episodeId, {
      status: "failed",
      errorMessage: error.message,
      progress: 0,
      currentStep: "Processing failed",
      processingCompleted: new Date()
    });
  }
};

export async function registerRoutes(app: Express): Promise<Server> {
  
  // Admin Authentication
  app.post("/api/admin/login", async (req, res) => {
    try {
      const { username, password } = req.body;
      
      if (!username || !password) {
        return res.status(400).json({ message: "Username and password are required" });
      }
      
      const isValid = await storage.verifyAdminCredentials({ username, password });
      
      if (isValid) {
        // Set admin session cookie
        req.session.isAdmin = true;
        return res.status(200).json({ success: true });
      } else {
        return res.status(401).json({ message: "Invalid credentials" });
      }
    } catch (error: any) {
      console.error("Admin login error:", error);
      res.status(500).json({ message: error.message });
    }
  });
  
  app.post("/api/admin/logout", (req, res) => {
    // Clear admin session
    req.session.isAdmin = false;
    res.status(200).json({ success: true });
  });
  
  app.get("/api/admin/check-auth", (req, res) => {
    if (req.session.isAdmin) {
      return res.status(200).json({ isAuthenticated: true });
    } else {
      return res.status(401).json({ isAuthenticated: false });
    }
  });
  
  // Middleware to check admin authentication
  const requireAdminAuth = (req: any, res: any, next: any) => {
    if (req.session.isAdmin) {
      next();
    } else {
      res.status(401).json({ message: "Unauthorized" });
    }
  };

  // Protected admin routes
  app.get("/api/admin/users", requireAdminAuth, async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json(users);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.post("/api/admin/users", requireAdminAuth, async (req, res) => {
    try {
      const validatedData = insertUserSchema.parse(req.body);
      const user = await storage.createUser(validatedData);
      res.status(201).json(user);
    } catch (error: any) {
      res.status(400).json({ message: error.message });
    }
  });

  app.delete("/api/admin/users/:id", requireAdminAuth, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteUser(id);
      
      if (success) {
        res.json({ message: "User deleted successfully" });
      } else {
        res.status(404).json({ message: "User not found" });
      }
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Episode management endpoints
  app.post("/api/episodes", async (req, res) => {
    try {
      const validatedData = insertEpisodeSchema.parse(req.body);
      
      // Extract video info from YouTube URL
      const videoInfo = await extractVideoInfo(validatedData.youtubeUrl);
      
      // Check if episode already exists
      const existingEpisode = await storage.getEpisodeByVideoId(videoInfo.videoId);
      if (existingEpisode) {
        return res.status(409).json({ 
          message: "Episode already exists",
          episode: existingEpisode 
        });
      }
      
      // Create episode with video info
      const episodeData = {
        youtubeUrl: validatedData.youtubeUrl,
        extractionMethod: validatedData.extractionMethod,
        generateSummary: validatedData.generateSummary,
        extractTopics: validatedData.extractTopics,
        userId: validatedData.userId || 1
      };
      
      const episode = await storage.createEpisode(episodeData);
      
      // Update with extracted video info
      const updatedEpisode = await storage.updateEpisode(episode.id, videoInfo);
      
      // Add to processing queue
      await storage.addToQueue(episode.id);
      
      // Start processing immediately
      setTimeout(async () => {
        try {
          await processEpisode(episode.id, {
            generateSummary: validatedData.generateSummary,
            extractTopics: validatedData.extractTopics
          });
        } catch (error) {
          console.error('Error starting episode processing:', error);
        }
      }, 1000); // Small delay to allow response to be sent
      
      res.status(201).json(updatedEpisode || episode);
    } catch (error: any) {
      res.status(400).json({ message: error.message });
    }
  });

  app.post("/api/batch-process", async (req, res) => {
    try {
      const { urls, extractionMethod } = req.body;
      const results: Array<{success: boolean; episode?: any; message?: string; url?: string}> = [];
      
      for (const url of urls) {
        try {
          const videoInfo = await extractVideoInfo(url);
          const existingEpisode = await storage.getEpisodeByVideoId(videoInfo.videoId);
          
          if (!existingEpisode) {
            const episode = await storage.createEpisode({
              youtubeUrl: url,
              extractionMethod,
              ...videoInfo,
              userId: 1
            });
            await storage.addToQueue(episode.id);
            results.push({ success: true, episode });
          } else {
            results.push({ success: false, message: "Episode already exists", url });
          }
        } catch (error: any) {
          results.push({ success: false, message: error.message, url });
        }
      }
      
      res.json({ results });
    } catch (error: any) {
      res.status(400).json({ message: error.message });
    }
  });

  app.get("/api/episodes/video/:videoId", async (req, res) => {
    try {
      const episode = await storage.getEpisodeByVideoId(req.params.videoId);
      if (!episode) {
        return res.status(404).json({ message: "Episode not found" });
      }
      res.json(episode);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/episodes/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const episode = await storage.getEpisode(id);
      
      if (!episode) {
        return res.status(404).json({ message: "Episode not found" });
      }
      
      res.json(episode);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.get("/api/episodes", async (req, res) => {
    try {
      const episodes = await storage.getAllEpisodes();
      res.json(episodes);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.delete("/api/episodes/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      // Check if episode exists first
      const episode = await storage.getEpisode(id);
      if (!episode) {
        return res.status(404).json({ message: "Episode not found" });
      }
      
      const success = await storage.deleteEpisode(id);
      if (!success) {
        return res.status(500).json({ message: "Failed to delete episode" });
      }
      
      res.json({ message: "Episode deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting episode:", error);
      res.status(500).json({ 
        message: "Error deleting episode", 
        error: error.message || "Unknown error"
      });
    }
  });

  // Processing endpoint
  app.post("/api/process/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const episode = await storage.getEpisode(id);
      
      if (!episode) {
        return res.status(404).json({ message: "Episode not found" });
      }
      
      // Update status to processing
      await storage.updateEpisode(id, { 
        status: "processing",
        processingStarted: new Date(),
        progress: 10, // Start with 10% progress
        currentStep: "Starting transcript extraction..."
      });
      
      // Process the episode asynchronously
      setTimeout(async () => {
        try {
          // Update progress to show activity
          await storage.updateEpisode(id, {
            progress: 30,
            currentStep: "Extracting transcript..."
          });
          
          // Wait a moment to simulate processing
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          const transcript = await extractTranscript(episode.videoId, episode.extractionMethod);
          const wordCount = transcript.split(/\s+/).length;
          
          // Update progress
          await storage.updateEpisode(id, {
            progress: 60,
            currentStep: "Processing extracted content..."
          });
          
          let summary = null;
          let topics: string[] = [];
          
          // Generate summary and topics if requested
          if (req.body.generateSummary) {
            summary = await generateSummary(transcript);
          }
          if (req.body.extractTopics) {
            topics = await extractTopics(transcript);
          }
          
          // Update progress
          await storage.updateEpisode(id, {
            progress: 90,
            currentStep: "Finalizing..."
          });
          
          // Wait a moment before final update
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // Final update with completed status
          await storage.updateEpisode(id, {
            status: "completed",
            transcript,
            summary,
            topics,
            wordCount,
            progress: 100,
            currentStep: "Completed successfully",
            processingCompleted: new Date()
          });
          
          console.log(`Episode ${id} processed successfully`);
        } catch (error: any) {
          console.error(`Error processing episode ${id}:`, error);
          await storage.updateEpisode(id, {
            status: "failed",
            errorMessage: error.message,
            progress: 100,
            currentStep: "Processing failed: " + error.message,
            processingCompleted: new Date()
          });
        }
      }, 1000); // Reduced from 3000 to 1000 for faster feedback
      
      res.json({ message: "Processing started", status: "processing" });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Keyword analysis endpoint
  app.post("/api/analyze-keywords", async (req, res) => {
    try {
      const { transcript } = req.body;
      
      if (!transcript) {
        return res.status(400).json({ error: "Transcript is required" });
      }

      // Use the KeywordAnalyzer service
      const analysisResult = await keywordAnalyzer.analyzeText(transcript);
      
      res.json(analysisResult);
    } catch (error: any) {
      console.error("Error analyzing keywords:", error);
      res.status(500).json({ error: error.message || "Failed to analyze keywords" });
    }
  });

  // Search endpoints
  app.post("/api/search", async (req, res) => {
    try {
      const { query, userId } = req.body;
      
      if (!query) {
        return res.status(400).json({ message: "Search query is required" });
      }
      
      const results = await storage.searchTranscripts(query, userId);
      
      // Save search query
      await storage.createSearchQuery({
        query,
        userId: userId || null,
        resultCount: results.length
      });
      
      res.json({ results, totalResults: results.length });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Transcript management
  app.put("/api/episodes/:id/transcript", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { transcript } = req.body;
      
      const episode = await storage.updateEpisode(id, {
        transcript,
        wordCount: transcript.split(/\s+/).length
      });
      
      if (!episode) {
        return res.status(404).json({ message: "Episode not found" });
      }
      
      res.json(episode);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Enrichment endpoint
  app.post("/api/enrich", async (req, res) => {
    try {
      const { episodeId, generateSummary: genSummary, extractTopics: extTopics } = req.body;
      const episode = await storage.getEpisode(episodeId);
      
      if (!episode || !episode.transcript) {
        return res.status(404).json({ message: "Episode or transcript not found" });
      }
      
      const updates: any = {};
      
      if (genSummary) {
        updates.summary = await generateSummary(episode.transcript);
      }
      
      if (extTopics) {
        updates.topics = await extractTopics(episode.transcript);
      }
      
      const updatedEpisode = await storage.updateEpisode(episodeId, updates);
      res.json(updatedEpisode);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Analytics endpoints
  app.get("/api/stats", async (req, res) => {
    try {
      console.log("Stats API endpoint called");
      const stats = await storage.getSystemStats();
      console.log("Stats returned from storage:", JSON.stringify(stats, null, 2));
      res.json(stats);
    } catch (error: any) {
      console.error("Error fetching stats:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // Export endpoints
  app.get("/api/export/:format", async (req, res) => {
    try {
      const { format } = req.params;
      const episodes = await storage.getAllEpisodes();
      
      if (format === "json") {
        res.setHeader("Content-Disposition", "attachment; filename=episodes.json");
        res.setHeader("Content-Type", "application/json");
        res.json(episodes);
      } else if (format === "csv") {
        res.setHeader("Content-Disposition", "attachment; filename=episodes.csv");
        res.setHeader("Content-Type", "text/csv");
        
        const csvHeaders = "ID,Title,Channel,Duration,Status,Method,Word Count,Created At\n";
        const csvRows = episodes.map(ep => 
          `${ep.id},"${ep.title}","${ep.channel}","${ep.duration}","${ep.status}","${ep.extractionMethod}",${ep.wordCount || 0},"${ep.createdAt}"`
        ).join("\n");
        
        res.send(csvHeaders + csvRows);
      } else {
        res.status(400).json({ message: "Unsupported export format" });
      }
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // User management endpoints
  app.post("/api/auth/login", async (req, res) => {
    try {
      const { username, password } = req.body;
      const user = await storage.getUserByUsername(username);
      
      if (!user) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      
      // In real app, verify password hash
      if (password === "admin123") { // Simple check for demo
        const { password: _, ...userWithoutPassword } = user;
        res.json({ 
          user: userWithoutPassword,
          token: "mock-jwt-token" // In real app, generate actual JWT
        });
      } else {
        res.status(401).json({ message: "Invalid credentials" });
      }
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  app.post("/api/admin/change_password", async (req, res) => {
    try {
      const { userId, currentPassword, newPassword } = req.body;
      const user = await storage.getUser(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // In real app, verify current password and hash new password
      await storage.updateUser(userId, { password: newPassword });
      res.json({ message: "Password updated successfully" });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // Queue management
  app.get("/api/queue", async (req, res) => {
    try {
      const queueItems = await storage.getQueueItems();
      res.json(queueItems);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  // WebSocket for real-time updates would be implemented here
  // For now, we'll use polling endpoints

  app.get("/api/processing-status/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const episode = await storage.getEpisode(id);
      
      if (!episode) {
        return res.status(404).json({ message: "Episode not found" });
      }
      
      // Use the actual progress and step data from the episode
      let progress = episode.progress || 0;
      let estimatedTime = "";
      let currentStep = episode.currentStep || "Preparing to process...";
      
      if (episode.status === "processing") {
        const startTime = episode.processingStarted?.getTime() || Date.now();
        const elapsed = Date.now() - startTime;
        const estimatedTotal = episode.extractionMethod === "audio" ? 300000 : 60000; // 5min for audio, 1min for others
        
        const remaining = Math.max(0, estimatedTotal - elapsed);
        const remainingMinutes = Math.floor(remaining / 60000);
        const remainingSeconds = Math.floor((remaining % 60000) / 1000);
        estimatedTime = `${remainingMinutes}:${remainingSeconds.toString().padStart(2, '0')}`;
      } else if (episode.status === "completed") {
        progress = 100;
        estimatedTime = "0:00";
        currentStep = "Processing completed";
      } else if (episode.status === "failed") {
        currentStep = "Processing failed";
      }
      
      res.json({
        ...episode,
        progress,
        estimatedTime,
        currentStep
      });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}

================
File: server/storage.ts
================
import { 
  users, episodes, searchQueries, processingQueue,
  type User, type InsertUser, type Episode, type InsertEpisode,
  type SearchQuery, type InsertSearchQuery, type ProcessingQueueItem,
  type SystemStats, type SearchResult, admin
} from "@shared/schema";
import { db } from './db';
import { eq, desc, sql, and, or, like, isNull } from 'drizzle-orm';
import { SQL } from 'drizzle-orm/sql';
import type { AdminLogin } from "@shared/schema";

export interface IStorage {
  // User management
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, updates: Partial<User>): Promise<User | undefined>;
  deleteUser(id: number): Promise<boolean>;
  getAllUsers(): Promise<User[]>;

  // Episode management
  getEpisode(id: number): Promise<Episode | undefined>;
  getEpisodeByVideoId(videoId: string): Promise<Episode | undefined>;
  createEpisode(episode: InsertEpisode): Promise<Episode>;
  updateEpisode(id: number, updates: Partial<Episode>): Promise<Episode | undefined>;
  deleteEpisode(id: number): Promise<boolean>;
  getAllEpisodes(userId?: number): Promise<Episode[]>;
  getEpisodesByStatus(status: string): Promise<Episode[]>;

  // Search functionality
  searchTranscripts(query: string, userId?: number): Promise<SearchResult[]>;
  createSearchQuery(searchQuery: InsertSearchQuery): Promise<SearchQuery>;
  getRecentSearches(userId: number, limit?: number): Promise<SearchQuery[]>;

  // Processing queue
  addToQueue(episodeId: number, priority?: number): Promise<ProcessingQueueItem>;
  getQueueItems(): Promise<ProcessingQueueItem[]>;
  updateQueueItem(id: number, updates: Partial<ProcessingQueueItem>): Promise<ProcessingQueueItem | undefined>;
  removeFromQueue(id: number): Promise<boolean>;

  // Analytics
  getSystemStats(): Promise<SystemStats>;
  getUserStats(userId: number): Promise<any>;

  // Admin Authentication
  verifyAdminCredentials(credentials: AdminLogin): Promise<boolean>;
}

export interface AdminCredentials {
  username: string;
  password: string;
}

export class MemStorage implements IStorage {
  private users: Map<number, User>;
  private episodes: Map<number, Episode>;
  private searchQueries: Map<number, SearchQuery>;
  private processingQueue: Map<number, ProcessingQueueItem>;
  private currentUserId: number;
  private currentEpisodeId: number;
  private currentSearchId: number;
  private currentQueueId: number;

  constructor() {
    this.users = new Map();
    this.episodes = new Map();
    this.searchQueries = new Map();
    this.processingQueue = new Map();
    this.currentUserId = 1;
    this.currentEpisodeId = 1;
    this.currentSearchId = 1;
    this.currentQueueId = 1;

    // Create default admin user
    this.createUser({
      username: "admin",
      email: "admin@transcriptai.com",
      password: "$2b$10$defaulthashedpassword", // In real app, this would be properly hashed
      role: "admin"
    });
  }
  
  // User management
  async getUser(id: number): Promise<User | undefined> {
    return this.users.get(id);
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(user => user.username === username);
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(user => user.email === email);
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const id = this.currentUserId++;
    const user: User = {
      ...insertUser,
      id,
      role: insertUser.role || "user",
      createdAt: new Date()
    };
    this.users.set(id, user);
    return user;
  }

  async updateUser(id: number, updates: Partial<User>): Promise<User | undefined> {
    const user = this.users.get(id);
    if (!user) return undefined;
    
    const updatedUser = { ...user, ...updates };
    this.users.set(id, updatedUser);
    return updatedUser;
  }

  async deleteUser(id: number): Promise<boolean> {
    return this.users.delete(id);
  }

  async getAllUsers(): Promise<User[]> {
    return Array.from(this.users.values());
  }

  // Episode management
  async getEpisode(id: number): Promise<Episode | undefined> {
    return this.episodes.get(id);
  }

  async getEpisodeByVideoId(videoId: string): Promise<Episode | undefined> {
    return Array.from(this.episodes.values()).find(episode => episode.videoId === videoId);
  }

  async createEpisode(insertEpisode: InsertEpisode): Promise<Episode> {
    const id = this.currentEpisodeId++;
    const newEpisode: Episode = {
      ...insertEpisode,
      id,
      status: "pending",
      createdAt: new Date(),
      processingStarted: null,
      processingCompleted: null,
      transcript: null,
      summary: null,
      topics: [],
      wordCount: null,
      errorMessage: null,
      // These will be populated by the video info extraction
      videoId: "",
      title: "",
      description: null,
      channel: null,
      duration: null,
      thumbnailUrl: null,
      progress: null,
      currentStep: null,
      extractTopics: false,
      generateSummary: false, 
    };
    this.episodes.set(id, newEpisode);
    return newEpisode;
  }

  async updateEpisode(id: number, updates: Partial<Episode>): Promise<Episode | undefined> {
    const episode = this.episodes.get(id);
    if (!episode) return undefined;
    
    const updatedEpisode = { ...episode, ...updates };
    this.episodes.set(id, updatedEpisode);
    return updatedEpisode;
  }

  async deleteEpisode(id: number): Promise<boolean> {
    try {
      // First, delete any processing queue items that reference this episode
      const queueItemsToDelete = Array.from(this.processingQueue.values())
        .filter(item => item.episodeId === id);
      
      for (const item of queueItemsToDelete) {
        this.processingQueue.delete(item.id);
      }
      
      // Then delete the episode itself
      return this.episodes.delete(id);
    } catch (error) {
      console.error("Error deleting episode:", error);
      return false;
    }
  }

  async getAllEpisodes(userId?: number): Promise<Episode[]> {
    const allEpisodes = Array.from(this.episodes.values());
    if (userId) {
      return allEpisodes.filter(episode => episode.userId === userId);
    }
    return allEpisodes.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
  }

  async getEpisodesByStatus(status: string): Promise<Episode[]> {
    return Array.from(this.episodes.values()).filter(episode => episode.status === status);
  }

  // Search functionality
  async searchTranscripts(query: string, userId?: number): Promise<SearchResult[]> {
    // This is a legacy method that forwards to the PostgresStorage implementation
    // The actual implementation is in the PostgresStorage class
    const postgresStorage = new PostgresStorage();
    return postgresStorage.searchTranscripts(query, userId);
  }

  async createSearchQuery(insertSearchQuery: InsertSearchQuery): Promise<SearchQuery> {
    const id = this.currentSearchId++;
    const searchQuery: SearchQuery = {
      ...insertSearchQuery,
      id,
      userId: insertSearchQuery.userId || null,
      resultCount: insertSearchQuery.resultCount || 0,
      createdAt: new Date()
    };
    this.searchQueries.set(id, searchQuery);
    return searchQuery;
  }

  async getRecentSearches(userId: number, limit = 10): Promise<SearchQuery[]> {
    return Array.from(this.searchQueries.values())
      .filter(query => query.userId === userId)
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
      .slice(0, limit);
  }

  // Processing queue
  async addToQueue(episodeId: number, priority = 0): Promise<ProcessingQueueItem> {
    const id = this.currentQueueId++;
    const queueItem: ProcessingQueueItem = {
      id,
      episodeId,
      priority,
      attempts: 0,
      maxAttempts: 3,
      status: "queued",
      createdAt: new Date(),
      startedAt: null,
      completedAt: null
    };
    this.processingQueue.set(id, queueItem);
    return queueItem;
  }

  async getQueueItems(): Promise<ProcessingQueueItem[]> {
    return Array.from(this.processingQueue.values())
      .sort((a, b) => (b.priority || 0) - (a.priority || 0) || a.createdAt.getTime() - b.createdAt.getTime());
  }

  async updateQueueItem(id: number, updates: Partial<ProcessingQueueItem>): Promise<ProcessingQueueItem | undefined> {
    const item = this.processingQueue.get(id);
    if (!item) return undefined;
    
    const updatedItem = { ...item, ...updates };
    this.processingQueue.set(id, updatedItem);
    return updatedItem;
  }

  async removeFromQueue(id: number): Promise<boolean> {
    return this.processingQueue.delete(id);
  }

  // Analytics
  async getSystemStats(): Promise<SystemStats> {
    try {
      // Get all episodes
      const allEpisodes = Array.from(this.episodes.values());
      const completedEpisodes = allEpisodes.filter(ep => ep.status === "completed");
      const failedEpisodes = allEpisodes.filter(ep => ep.status === "failed");
      const queueLength = Array.from(this.processingQueue.values()).filter(item => item.status === "queued").length;
      
      // Calculate success rate
      const totalProcessed = completedEpisodes.length + failedEpisodes.length;
      const successRate = totalProcessed === 0 ? 100 : Math.round((completedEpisodes.length / totalProcessed) * 100);
      
      const methodDistribution = {
        caption: allEpisodes.filter(ep => ep.extractionMethod === "caption").length,
        scraping: allEpisodes.filter(ep => ep.extractionMethod === "scraping").length,
        audio: allEpisodes.filter(ep => ep.extractionMethod === "audio").length
      };
      
      // Calculate average processing time
      let averageProcessingTime = "0min";
      if (completedEpisodes.length > 0) {
        const processingTimes = completedEpisodes
          .filter(ep => ep.processingStarted && ep.processingCompleted)
          .map(ep => {
            if (!ep.processingStarted || !ep.processingCompleted) return 0;
            return (new Date(ep.processingCompleted).getTime() - new Date(ep.processingStarted).getTime()) / 60000;
          })
          .filter(time => time > 0);
        
        if (processingTimes.length > 0) {
          const avgTime = processingTimes.reduce((sum, time) => sum + time, 0) / processingTimes.length;
          averageProcessingTime = `${avgTime.toFixed(1)}min`;
        }
      }
      
      // Calculate total word count
      let totalWordCount = 0;
      for (const episode of allEpisodes) {
        if (episode.wordCount) {
          totalWordCount += episode.wordCount;
        } else if (episode.transcript) {
          // If wordCount not set but transcript exists, calculate it
          const wordCount = episode.transcript.split(/\s+/).length;
          totalWordCount += wordCount;
          
          // Update episode with the calculated word count
          await this.updateEpisode(episode.id, { wordCount });
        }
      }
      
      // Format total word count with comma separators
      const formattedWordCount = totalWordCount.toLocaleString();
      
      // Calculate daily processed episodes
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const dailyProcessed = allEpisodes.filter(ep => 
        ep.createdAt >= today && ep.status === "completed"
      ).length;
      
      // Simple trend calculation
      const episodesTrend = 5; // Placeholder value
      const wordCountTrend = 10; // Placeholder value
      
      // Generate history data
      const historySize = 20;
      const episodesHistory: number[] = [];
      const processingTimeHistory: number[] = [];
      const wordCountHistory: number[] = [];
      
      for (let i = 0; i < historySize; i++) {
        const ratio = (i + 1) / historySize;
        episodesHistory.push(Math.round(allEpisodes.length * ratio));
        processingTimeHistory.push(i + 1);
        wordCountHistory.push(Math.round(totalWordCount * ratio));
      }
      
      return {
        totalEpisodes: allEpisodes.length,
        processingQueue: queueLength,
        successRate,
        averageProcessingTime,
        totalWordCount: formattedWordCount,
        dailyProcessed,
        methodDistribution,
        trends: {
          totalEpisodes: episodesTrend,
          successRate: 0,
          processingTime: 0,
          wordCount: wordCountTrend
        },
        history: {
          totalEpisodes: episodesHistory,
          processingTime: processingTimeHistory,
          wordCount: wordCountHistory
        },
        lastUpdated: new Date().toISOString()
      };
    } catch (error) {
      console.error("Error getting system stats:", error);
      // Return default values if there's an error
      return {
        totalEpisodes: 0,
        processingQueue: 0,
        successRate: 100,
        averageProcessingTime: "0min",
        totalWordCount: "0",
        dailyProcessed: 0,
        methodDistribution: { caption: 0, scraping: 0, audio: 0 },
        trends: {
          totalEpisodes: 0,
          successRate: 0,
          processingTime: 0,
          wordCount: 0
        },
        history: {
          totalEpisodes: [],
          processingTime: [],
          wordCount: []
        },
        lastUpdated: new Date().toISOString()
      };
    }
  }
  
  // Helper methods for MemStorage
  private calculateTrend(data: any[], dateField: string, daysToCompare: number): number {
    if (data.length === 0) return 0;
    
    const now = new Date();
    const periodStart = new Date();
    periodStart.setDate(periodStart.getDate() - daysToCompare);
    
    const previousStart = new Date(periodStart);
    previousStart.setDate(previousStart.getDate() - daysToCompare);
    
    const currentPeriod = data.filter(item => 
      item[dateField] && new Date(item[dateField]) >= periodStart && new Date(item[dateField]) <= now
    ).length;
    
    const previousPeriod = data.filter(item => 
      item[dateField] && new Date(item[dateField]) >= previousStart && new Date(item[dateField]) < periodStart
    ).length;
    
    if (previousPeriod === 0) return currentPeriod > 0 ? 100 : 0;
    
    const percentChange = Math.round(((currentPeriod - previousPeriod) / previousPeriod) * 100);
    return percentChange;
  }
  
  private calculateWordCountTrend(data: any[], daysToCompare: number): number {
    if (data.length === 0) return 0;
    
    const now = new Date();
    const periodStart = new Date();
    periodStart.setDate(periodStart.getDate() - daysToCompare);
    
    const previousStart = new Date(periodStart);
    previousStart.setDate(previousStart.getDate() - daysToCompare);
    
    const currentPeriod = data.filter(item => 
      item.createdAt && new Date(item.createdAt) >= periodStart && new Date(item.createdAt) <= now
    ).reduce((sum, item) => sum + (item.wordCount || 0), 0);
    
    const previousPeriod = data.filter(item => 
      item.createdAt && new Date(item.createdAt) >= previousStart && new Date(item.createdAt) < periodStart
    ).reduce((sum, item) => sum + (item.wordCount || 0), 0);
    
    if (previousPeriod === 0) return currentPeriod > 0 ? 100 : 0;
    
    const percentChange = Math.round(((currentPeriod - previousPeriod) / previousPeriod) * 100);
    return percentChange;
  }
  
  private calculateHistoryPoints(data: any[], field: string, points: number): number[] {
    // Sort data by created date
    const sortedData = [...data].sort((a, b) => {
      const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
      const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
      return dateA - dateB;
    });
    
    // Create evenly spaced points for the chart
    const result: number[] = [];
    if (sortedData.length === 0) {
      return Array(points).fill(0);
    }
    
    // Generate cumulative counts at different points in time
    const interval = sortedData.length / points;
    for (let i = 0; i < points; i++) {
      const index = Math.min(Math.floor(i * interval), sortedData.length - 1);
      if (field === 'id') {
        // For episode count, use cumulative count at this point
        result.push(index + 1);
      } else {
        // For other metrics, count items up to this point
        const count = sortedData.slice(0, index + 1).length;
        result.push(count);
      }
    }
    
    return result;
  }
  
  private calculateWordCountHistory(data: any[], points: number): number[] {
    // Sort data by created date
    const sortedData = [...data].sort((a, b) => {
      const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
      const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
      return dateA - dateB;
    });
    
    // Create evenly spaced points for the chart
    const result: number[] = [];
    if (sortedData.length === 0) {
      return Array(points).fill(0);
    }
    
    // Generate cumulative word counts at different points in time
    const interval = sortedData.length / points;
    let cumulativeWordCount = 0;
    
    for (let i = 0; i < points; i++) {
      const index = Math.min(Math.floor(i * interval), sortedData.length - 1);
      // Add up all word counts up to this point
      cumulativeWordCount = sortedData.slice(0, index + 1)
        .reduce((sum, item) => sum + (item.wordCount || 0), 0);
      result.push(cumulativeWordCount);
    }
    
    return result;
  }

  async getUserStats(userId: number): Promise<any> {
    const userEpisodes = Array.from(this.episodes.values()).filter(ep => ep.userId === userId);
    const userSearches = Array.from(this.searchQueries.values()).filter(sq => sq.userId === userId);
    
    return {
      totalEpisodes: userEpisodes.length,
      completedEpisodes: userEpisodes.filter(ep => ep.status === "completed").length,
      totalSearches: userSearches.length,
      recentActivity: userEpisodes.slice(0, 5)
    };
  }

  // Admin Authentication
  async verifyAdminCredentials(credentials: AdminLogin): Promise<boolean> {
    try {
      const result = await db.select().from(admin).where(
        and(
          eq(admin.username, credentials.username),
          eq(admin.password, credentials.password)
        )
      );
      
      return result.length > 0;
    } catch (error) {
      console.error("Error verifying admin credentials:", error);
      return false;
    }
  }
}

export class PostgresStorage implements IStorage {
  // User management
  async getUser(id: number): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.id, id));
    return result[0];
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.username, username));
    return result[0];
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.email, email));
    return result[0];
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const result = await db.insert(users).values({
      ...insertUser,
      role: insertUser.role || "user"
    }).returning();
    return result[0];
  }

  async updateUser(id: number, updates: Partial<User>): Promise<User | undefined> {
    const result = await db.update(users)
      .set(updates)
      .where(eq(users.id, id))
      .returning();
    return result[0];
  }

  async deleteUser(id: number): Promise<boolean> {
    const result = await db.delete(users).where(eq(users.id, id));
    return result.length > 0;
  }

  async getAllUsers(): Promise<User[]> {
    return await db.select().from(users);
  }

  // Episode management
  async getEpisode(id: number): Promise<Episode | undefined> {
    const result = await db.select().from(episodes).where(eq(episodes.id, id));
    return result[0];
  }

  async getEpisodeByVideoId(videoId: string): Promise<Episode | undefined> {
    const result = await db.select().from(episodes).where(eq(episodes.videoId, videoId));
    return result[0];
  }

  async createEpisode(insertEpisode: InsertEpisode): Promise<Episode> {
    // Generate a temporary unique videoId based on timestamp
    const tempVideoId = `temp_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
    
    const result = await db.insert(episodes).values({
      ...insertEpisode,
      status: "pending",
      videoId: tempVideoId, // Use temporary videoId to satisfy unique constraint
      title: insertEpisode.youtubeUrl.split('v=')[1] || "Untitled", // Extract video ID as title
      generateSummary: insertEpisode.generateSummary || false,
      extractTopics: insertEpisode.extractTopics || false
    }).returning();
    return result[0];
  }

  async updateEpisode(id: number, updates: Partial<Episode>): Promise<Episode | undefined> {
    const result = await db.update(episodes)
      .set(updates)
      .where(eq(episodes.id, id))
      .returning();
    return result[0];
  }

  async deleteEpisode(id: number): Promise<boolean> {
    try {
      // Use a transaction to ensure both operations succeed or fail together
      const result = await db.transaction(async (tx) => {
        // First, delete any processing queue items that reference this episode
        await tx.delete(processingQueue).where(eq(processingQueue.episodeId, id));
        
        // Then delete the episode itself
        const deleteResult = await tx.delete(episodes).where(eq(episodes.id, id));
        return deleteResult.length > 0;
      });
      
      return result;
    } catch (error) {
      console.error("Error deleting episode:", error);
      return false;
    }
  }

  async getAllEpisodes(userId?: number): Promise<Episode[]> {
    if (userId) {
      return await db.select()
        .from(episodes)
        .where(eq(episodes.userId, userId))
        .orderBy(desc(episodes.createdAt));
    }
    return await db.select()
      .from(episodes)
      .orderBy(desc(episodes.createdAt));
  }

  async getEpisodesByStatus(status: string): Promise<Episode[]> {
    return await db.select()
      .from(episodes)
      .where(eq(episodes.status, status));
  }

  // Search functionality
  async searchTranscripts(query: string, userId?: number): Promise<SearchResult[]> {
    // Basic text search using LIKE - in production would use proper full-text search
    const queryLower = `%${query.toLowerCase()}%`;
    
    // Create SQL condition for transcript IS NOT NULL
    const transcriptNotNull = sql`${episodes.transcript} IS NOT NULL`;
    
    // Create SQL condition for text search
    const textMatch = or(
      like(sql`LOWER(${episodes.transcript})`, queryLower),
      like(sql`LOWER(${episodes.title})`, queryLower)
    );
    
    // Create base condition combining transcript not null and text match
    let condition = and(transcriptNotNull, textMatch);
    
    // Add user filter if specified
    if (userId !== undefined) {
      condition = and(condition, eq(episodes.userId, userId));
    }
    
    // Execute the query with the condition
    const matchingEpisodes = await db.select()
      .from(episodes)
      .where(condition);
    
    // Process results - Simple highlighting
    const results: SearchResult[] = [];
    const queryStr = query.toLowerCase();
    
    for (const episode of matchingEpisodes) {
      if (!episode.transcript) continue;
      
      const highlights: Array<{segment: string; timestamp: string; matchScore: number}> = [];
      const sentences = episode.transcript.split(/[.!?]+/);
      
      for (let i = 0; i < sentences.length; i++) {
        if (sentences[i].toLowerCase().includes(queryStr)) {
          highlights.push({
            segment: sentences[i].trim(),
            timestamp: `${Math.floor(i * 30 / 60)}:${(i * 30 % 60).toString().padStart(2, '0')}`,
            matchScore: 0.8
          });
        }
      }
      
      if (highlights.length > 0) {
        results.push({
          episode,
          highlights: highlights.slice(0, 3), // Limit to 3 highlights
          totalMatches: highlights.length
        });
      }
    }
    
    return results.sort((a, b) => b.totalMatches - a.totalMatches);
  }

  async createSearchQuery(insertSearchQuery: InsertSearchQuery): Promise<SearchQuery> {
    const result = await db.insert(searchQueries).values({
      ...insertSearchQuery,
      resultCount: insertSearchQuery.resultCount || 0,
    }).returning();
    return result[0];
  }

  async getRecentSearches(userId: number, limit = 10): Promise<SearchQuery[]> {
    return await db.select()
      .from(searchQueries)
      .where(eq(searchQueries.userId, userId))
      .orderBy(desc(searchQueries.createdAt))
      .limit(limit);
  }

  // Processing queue
  async addToQueue(episodeId: number, priority = 0): Promise<ProcessingQueueItem> {
    const result = await db.insert(processingQueue).values({
      episodeId,
      priority,
      attempts: 0,
      maxAttempts: 3,
      status: "queued"
    }).returning();
    return result[0];
  }

  async getQueueItems(): Promise<ProcessingQueueItem[]> {
    return await db.select()
      .from(processingQueue)
      .orderBy(desc(processingQueue.priority), processingQueue.createdAt);
  }

  async updateQueueItem(id: number, updates: Partial<ProcessingQueueItem>): Promise<ProcessingQueueItem | undefined> {
    const result = await db.update(processingQueue)
      .set(updates)
      .where(eq(processingQueue.id, id))
      .returning();
    return result[0];
  }

  async removeFromQueue(id: number): Promise<boolean> {
    const result = await db.delete(processingQueue).where(eq(processingQueue.id, id));
    return result.length > 0;
  }

  // Analytics
  async getSystemStats(): Promise<SystemStats> {
    try {
      console.time('getSystemStats');
      
      // Get total episodes count
      const totalEpisodesResult = await db.select({ count: sql<number>`COUNT(*)` }).from(episodes);
      const totalEpisodes = Number(totalEpisodesResult[0]?.count || 0);
      
      // Get processing queue count
      const queueCountResult = await db.select({ count: sql<number>`COUNT(*)` })
        .from(processingQueue)
        .where(eq(processingQueue.status, "queued"));
      const queueLength = Number(queueCountResult[0]?.count || 0);
      
      // Get counts by status
      const completedCountResult = await db.select({ count: sql<number>`COUNT(*)` })
        .from(episodes)
        .where(eq(episodes.status, "completed"));
      const completedCount = Number(completedCountResult[0]?.count || 0);
      
      const failedCountResult = await db.select({ count: sql<number>`COUNT(*)` })
        .from(episodes)
        .where(eq(episodes.status, "failed"));
      const failedCount = Number(failedCountResult[0]?.count || 0);
      
      // Calculate success rate
      const totalProcessed = completedCount + failedCount;
      const successRate = totalProcessed === 0 ? 100 : Math.round((completedCount / totalProcessed) * 100);
      
      // Get method distribution
      const captionCountResult = await db.select({ count: sql<number>`COUNT(*)` })
        .from(episodes)
        .where(eq(episodes.extractionMethod, "caption"));
      const scrapingCountResult = await db.select({ count: sql<number>`COUNT(*)` })
        .from(episodes)
        .where(eq(episodes.extractionMethod, "scraping"));
      const audioCountResult = await db.select({ count: sql<number>`COUNT(*)` })
        .from(episodes)
        .where(eq(episodes.extractionMethod, "audio"));
      
      const methodDistribution = {
        caption: Number(captionCountResult[0]?.count || 0),
        scraping: Number(scrapingCountResult[0]?.count || 0),
        audio: Number(audioCountResult[0]?.count || 0)
      };
      
      // Calculate average processing time
      const processingTimesResult = await db.select({
        startTime: episodes.processingStarted,
        endTime: episodes.processingCompleted
      })
      .from(episodes)
      .where(
        and(
          eq(episodes.status, "completed"),
          sql`${episodes.processingStarted} IS NOT NULL`,
          sql`${episodes.processingCompleted} IS NOT NULL`
        )
      );
      
      let averageProcessingTime = "0min";
      if (processingTimesResult.length > 0) {
        const processingTimes = processingTimesResult
          .map(result => {
            if (!result.startTime || !result.endTime) return 0;
            return (new Date(result.endTime).getTime() - new Date(result.startTime).getTime()) / 60000;
          })
          .filter(time => time > 0);
        
        if (processingTimes.length > 0) {
          const avgTime = processingTimes.reduce((sum, time) => sum + time, 0) / processingTimes.length;
          averageProcessingTime = `${avgTime.toFixed(1)}min`;
        }
      }
      
      // Calculate total word count with a single SQL query
      const wordCountResult = await db.select({
        totalWords: sql<number>`COALESCE(SUM(${episodes.wordCount}), 0)`
      })
      .from(episodes)
      .where(sql`${episodes.wordCount} IS NOT NULL`);
      
      let totalWordCount = Number(wordCountResult[0]?.totalWords || 0);
      
      // Find episodes with transcripts but no word count
      const missingWordCountEpisodes = await db.select({
        id: episodes.id,
        transcript: episodes.transcript
      })
      .from(episodes)
      .where(
        and(
          sql`${episodes.transcript} IS NOT NULL`,
          sql`${episodes.wordCount} IS NULL`
        )
      );
      
      // Update word counts for episodes missing them
      for (const episode of missingWordCountEpisodes) {
        if (!episode.transcript) continue;
        
        const wordCount = episode.transcript.split(/\s+/).length;
        totalWordCount += wordCount;
        
        // Update the episode with the calculated word count
        await db.update(episodes)
          .set({ wordCount })
          .where(eq(episodes.id, episode.id));
      }
      
      // Format total word count with comma separators
      const formattedWordCount = totalWordCount.toLocaleString();
      
      // Get daily processed episodes count
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const todayStr = today.toISOString();
      
      const dailyProcessedResult = await db.select({ count: sql<number>`COUNT(*)` })
        .from(episodes)
        .where(
          and(
            eq(episodes.status, "completed"),
            sql`${episodes.createdAt} >= ${todayStr}`
          )
        );
      const dailyProcessed = Number(dailyProcessedResult[0]?.count || 0);
      
      // Simple trend calculation
      const episodesTrend = 5; // Placeholder value
      const wordCountTrend = 10; // Placeholder value
      
      console.timeEnd('getSystemStats');
      
      // Create mock history data
      const mockHistory = this.createMockHistoryData(totalEpisodes, totalWordCount);
      
      return {
        totalEpisodes,
        processingQueue: queueLength,
        successRate,
        averageProcessingTime,
        totalWordCount: formattedWordCount,
        dailyProcessed,
        methodDistribution,
        trends: {
          totalEpisodes: episodesTrend,
          successRate: 0,
          processingTime: 0,
          wordCount: wordCountTrend
        },
        history: mockHistory,
        lastUpdated: new Date().toISOString()
      };
    } catch (error) {
      console.error("Error getting system stats:", error);
      return this.getDefaultStats();
    }
  }
  
  // Helper method to create mock history data
  private createMockHistoryData(totalEpisodes: number, totalWordCount: number): SystemStats['history'] {
    const historySize = 20;
    const episodesHistory: number[] = [];
    const processingTimeHistory: number[] = [];
    const wordCountHistory: number[] = [];
    
    for (let i = 0; i < historySize; i++) {
      const ratio = (i + 1) / historySize;
      episodesHistory.push(Math.round(totalEpisodes * ratio));
      processingTimeHistory.push(i + 1);
      wordCountHistory.push(Math.round(totalWordCount * ratio));
    }
    
    return {
      totalEpisodes: episodesHistory,
      processingTime: processingTimeHistory,
      wordCount: wordCountHistory
    };
  }
  
  // Default stats when there's an error
  private getDefaultStats(): SystemStats {
    return {
      totalEpisodes: 0,
      processingQueue: 0,
      successRate: 100,
      averageProcessingTime: "0min",
      totalWordCount: "0",
      dailyProcessed: 0,
      methodDistribution: { caption: 0, scraping: 0, audio: 0 },
      trends: {
        totalEpisodes: 0,
        successRate: 0,
        processingTime: 0,
        wordCount: 0
      },
      history: {
        totalEpisodes: [],
        processingTime: [],
        wordCount: []
      },
      lastUpdated: new Date().toISOString()
    };
  }

  async getUserStats(userId: number): Promise<any> {
    // Get total user episodes
    const totalEpisodesResult = await db.select({ value: sql<number>`count(*)` })
      .from(episodes)
      .where(eq(episodes.userId, userId));
    const totalEpisodes = totalEpisodesResult[0]?.value || 0;
    
    // Get completed user episodes
    const completedEpisodesResult = await db.select({ value: sql<number>`count(*)` })
      .from(episodes)
      .where(
        and(
          eq(episodes.userId, userId),
          eq(episodes.status, "completed")
        )
      );
    const completedEpisodes = completedEpisodesResult[0]?.value || 0;
    
    // Get total user searches
    const totalSearchesResult = await db.select({ value: sql<number>`count(*)` })
      .from(searchQueries)
      .where(eq(searchQueries.userId, userId));
    const totalSearches = totalSearchesResult[0]?.value || 0;
    
    // Get recent activity
    const recentActivity = await db.select()
      .from(episodes)
      .where(eq(episodes.userId, userId))
      .orderBy(desc(episodes.createdAt))
      .limit(5);
    
    return {
      totalEpisodes,
      completedEpisodes,
      totalSearches,
      recentActivity
    };
  }

  // Admin Authentication
  async verifyAdminCredentials(credentials: AdminLogin): Promise<boolean> {
    try {
      const result = await db.select().from(admin).where(
        and(
          eq(admin.username, credentials.username),
          eq(admin.password, credentials.password)
        )
      );
      
      return result.length > 0;
    } catch (error) {
      console.error("Error verifying admin credentials:", error);
      return false;
    }
  }
}

export const storage = new PostgresStorage();

================
File: server/test-storage.ts
================
import { storage } from './storage';
import { db } from './db';
import { searchQueries } from '@shared/schema';
import { eq } from 'drizzle-orm';
import dotenv from 'dotenv';

dotenv.config();

async function testStorage() {
  try {
    console.log('Testing PostgresStorage implementation...');
    
    // Generate unique identifiers using timestamp
    const timestamp = Date.now();
    const username = `testuser_${timestamp}`;
    const email = `test${timestamp}@example.com`;
    const videoId = `testid_${timestamp}`;
    
    // Create a test user
    const testUser = await storage.createUser({
      username,
      email,
      password: "hashedpassword123",
      role: "user"
    });
    
    console.log('Created test user:', testUser);
    
    // Get the user back
    const retrievedUser = await storage.getUserByUsername(username);
    console.log('Retrieved user:', retrievedUser);
    
    // Create a test episode
    const testEpisode = await storage.createEpisode({
      youtubeUrl: `https://www.youtube.com/watch?v=${videoId}`,
      extractionMethod: "caption",
      userId: testUser.id
    });
    
    console.log('Created test episode:', testEpisode);
    
    // Update the episode with more data
    const updatedEpisode = await storage.updateEpisode(testEpisode.id, {
      title: "Test Episode Title",
      status: "completed",
      transcript: "This is a test transcript for our episode.",
      processingCompleted: new Date()
    });
    
    console.log('Updated episode:', updatedEpisode);
    
    // Get all episodes for the user
    const episodes = await storage.getAllEpisodes(testUser.id);
    console.log('User episodes:', episodes);
    
    // Search for transcripts
    const searchResults = await storage.searchTranscripts("test", testUser.id);
    console.log('Search results:', searchResults);
    
    // Create a search query record
    const searchQuery = await storage.createSearchQuery({
      query: "test",
      userId: testUser.id,
      resultCount: searchResults.length
    });
    
    console.log('Saved search query:', searchQuery);
    
    // Get recent searches
    const recentSearches = await storage.getRecentSearches(testUser.id);
    console.log('Recent searches:', recentSearches);
    
    // Get system stats
    const stats = await storage.getSystemStats();
    console.log('System stats:', stats);
    
    // Get user stats
    const userStats = await storage.getUserStats(testUser.id);
    console.log('User stats:', userStats);
    
    console.log('PostgresStorage test completed successfully!');
    
    // Clean up - Delete test data (in the correct order for foreign key constraints)
    // First delete search queries
    await db.delete(searchQueries).where(eq(searchQueries.userId, testUser.id));
    // Then delete episodes
    await storage.deleteEpisode(testEpisode.id);
    // Finally delete user
    await storage.deleteUser(testUser.id);
    
    console.log('Test data cleanup completed successfully');
    
  } catch (error) {
    console.error('Error testing PostgresStorage:', error);
  } finally {
    process.exit(0);
  }
}

testStorage();

================
File: server/ts-advanced-scraper.ts
================
import axios from 'axios';
import * as cheerio from 'cheerio';
import { CaptionResult } from './ts-caption-scraper';

/**
 * Advanced caption scraper with additional techniques for hard-to-extract videos
 */
export class TsAdvancedScraper {
  private readonly userAgent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36';
  
  /**
   * Extract captions using multiple advanced techniques
   */
  async extractCaptions(videoId: string): Promise<CaptionResult | null> {
    try {
      console.log(`Starting advanced caption extraction for video: ${videoId}`);
      
      // Try multiple extraction techniques in sequence
      const transcript = await this.tryMultipleExtractionMethods(videoId);
      
      if (!transcript || transcript.length < 50) {
        console.log('All advanced extraction methods failed');
        return null;
      }
      
      // Get metadata
      const metadata = await this.getEnhancedMetadata(videoId);
      
      return {
        transcript,
        title: metadata.title || `Video ${videoId}`,
        date: metadata.date || new Date().toISOString().split('T')[0],
        channel: metadata.channel || 'Unknown Channel',
        videoId,
        extractionMethod: 'advanced_scraping'
      };
    } catch (error) {
      console.error(`Advanced scraper error: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  /**
   * Try multiple extraction methods in sequence
   */
  private async tryMultipleExtractionMethods(videoId: string): Promise<string | null> {
    // Method 1: Try timedtext API directly
    try {
      console.log('Trying timedtext API extraction...');
      const timedTextResult = await this.extractFromTimedTextApi(videoId);
      if (timedTextResult && timedTextResult.length > 100) {
        console.log(`Successfully extracted ${timedTextResult.length} chars using timedtext API`);
        return timedTextResult;
      }
    } catch (error) {
      console.log(`Timedtext API extraction failed: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Method 2: Try embedded captions from watch page
    try {
      console.log('Trying embedded captions extraction...');
      const embeddedResult = await this.extractEmbeddedCaptions(videoId);
      if (embeddedResult && embeddedResult.length > 100) {
        console.log(`Successfully extracted ${embeddedResult.length} chars from embedded captions`);
        return embeddedResult;
      }
    } catch (error) {
      console.log(`Embedded captions extraction failed: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    // Method 3: Try transcript page directly
    try {
      console.log('Trying transcript page extraction...');
      const transcriptPageResult = await this.extractFromTranscriptPage(videoId);
      if (transcriptPageResult && transcriptPageResult.length > 100) {
        console.log(`Successfully extracted ${transcriptPageResult.length} chars from transcript page`);
        return transcriptPageResult;
      }
    } catch (error) {
      console.log(`Transcript page extraction failed: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    console.log('All extraction methods failed');
    return null;
  }
  
  /**
   * Extract captions directly from YouTube's timedtext API
   */
  private async extractFromTimedTextApi(videoId: string): Promise<string | null> {
    try {
      // First get video page to extract data needed for API call
      const url = `https://www.youtube.com/watch?v=${videoId}`;
      const response = await axios.get(url, {
        headers: {
          'User-Agent': this.userAgent,
          'Accept-Language': 'en-US,en;q=0.9'
        },
        timeout: 10000
      });
      
      const html = response.data;
      
      // Look for direct caption URLs in the page
      const captionUrlMatches = html.match(/"captionTracks":\s*\[\s*\{\s*"baseUrl":\s*"([^"]+)"/);
      if (!captionUrlMatches) {
        console.log('No caption URLs found in page source');
        return null;
      }
      
      // Extract and clean the caption URL
      let captionUrl = captionUrlMatches[1];
      captionUrl = captionUrl.replace(/\\u0026/g, '&');
      
      console.log(`Found caption URL: ${captionUrl.substring(0, 100)}...`);
      
      // Fetch the captions
      const captionResponse = await axios.get(captionUrl, {
        headers: { 'User-Agent': this.userAgent },
        timeout: 10000
      });
      
      if (captionResponse.status !== 200) {
        console.log(`Caption request failed with status ${captionResponse.status}`);
        return null;
      }
      
      // Parse the XML response
      const captionXml = captionResponse.data;
      return this.parseXmlCaptions(captionXml);
    } catch (error) {
      console.error(`Error in timedtext extraction: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  /**
   * Extract captions embedded in the watch page
   */
  private async extractEmbeddedCaptions(videoId: string): Promise<string | null> {
    try {
      const url = `https://www.youtube.com/watch?v=${videoId}`;
      const response = await axios.get(url, {
        headers: {
          'User-Agent': this.userAgent,
          'Accept-Language': 'en-US,en;q=0.9'
        },
        timeout: 10000
      });
      
      const html = response.data;
      
      // Look for captions data in the ytInitialPlayerResponse
      const dataMatch = html.match(/ytInitialPlayerResponse\s*=\s*({.+?});/);
      if (!dataMatch) {
        console.log('No player data found');
        return null;
      }
      
      const playerData = JSON.parse(dataMatch[1]);
      
      // Extract transcript data if present
      if (playerData.captions?.playerCaptionsTracklistRenderer?.captionTracks) {
        const tracks = playerData.captions.playerCaptionsTracklistRenderer.captionTracks;
        
        // Find English track
        let englishTrack = tracks.find((t: any) => 
          t.languageCode?.startsWith('en') && t.kind !== 'asr'
        );
        
        // Fallback to any English track
        if (!englishTrack) {
          englishTrack = tracks.find((t: any) => t.languageCode?.startsWith('en'));
        }
        
        // Fallback to any track
        if (!englishTrack && tracks.length > 0) {
          englishTrack = tracks[0];
        }
        
        if (englishTrack?.baseUrl) {
          console.log(`Found caption track URL: ${englishTrack.baseUrl.substring(0, 100)}...`);
          
          // Fetch caption data
          const captionResponse = await axios.get(englishTrack.baseUrl, {
            headers: { 'User-Agent': this.userAgent },
            timeout: 10000
          });
          
          return this.parseXmlCaptions(captionResponse.data);
        }
      }
      
      console.log('No caption tracks found in player data');
      return null;
    } catch (error) {
      console.error(`Error in embedded captions extraction: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  /**
   * Extract captions from the transcript page
   */
  private async extractFromTranscriptPage(videoId: string): Promise<string | null> {
    try {
      // This is a special endpoint that returns the transcript page
      const url = `https://www.youtube.com/api/timedtext?lang=en&v=${videoId}`;
      
      const response = await axios.get(url, {
        headers: {
          'User-Agent': this.userAgent,
          'Accept-Language': 'en-US,en;q=0.9'
        },
        timeout: 10000
      });
      
      if (response.status !== 200) {
        console.log(`Transcript page request failed: ${response.status}`);
        return null;
      }
      
      const content = response.data;
      
      // If we got XML content directly
      if (typeof content === 'string' && content.includes('<text')) {
        return this.parseXmlCaptions(content);
      }
      
      // If we got JSON
      if (typeof content === 'object') {
        return this.parseJsonCaptions(content);
      }
      
      console.log('Unrecognized transcript format');
      return null;
    } catch (error) {
      console.error(`Error in transcript page extraction: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  /**
   * Parse XML format captions
   */
  private parseXmlCaptions(xml: string): string | null {
    try {
      // Extract all text elements
      const textMatches = xml.match(/<text[^>]*>([^<]+)<\/text>/g);
      
      if (!textMatches || textMatches.length === 0) {
        return null;
      }
      
      // Extract text content from tags
      const textContents = textMatches.map(match => {
        // Remove XML tags
        let text = match.replace(/<[^>]+>/g, '');
        
        // Decode HTML entities
        text = this.decodeHtmlEntities(text);
        
        return text;
      });
      
      // Join all text segments
      let transcript = textContents.join(' ');
      
      // Clean up whitespace
      transcript = transcript.replace(/\s+/g, ' ').trim();
      
      return transcript;
    } catch (error) {
      console.error(`Error parsing XML captions: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  /**
   * Parse JSON format captions (newer YouTube format)
   */
  private async parseJsonCaptions(json: any): Promise<string | null> {
    try {
      let textSegments: string[] = [];
      
      // Handle different JSON caption formats
      if (json.events) {
        // Format 1: events array with segs
        for (const event of json.events) {
          if (event.segs) {
            for (const seg of event.segs) {
              if (seg.utf8) {
                textSegments.push(seg.utf8);
              }
            }
          }
        }
      } else if (json.captions?.playerCaptionsTracklistRenderer?.captionTracks) {
        // Format 2: caption tracks array
        // We need to fetch the actual captions from the URL
        const tracks = json.captions.playerCaptionsTracklistRenderer.captionTracks;
        
        for (const track of tracks) {
          if (track.languageCode?.startsWith('en') && track.baseUrl) {
            // Fetch this caption track
            return await this.fetchAndParseTrack(track.baseUrl);
          }
        }
      }
      
      if (textSegments.length > 0) {
        return textSegments.join(' ').replace(/\s+/g, ' ').trim();
      }
      
      return null;
    } catch (error) {
      console.error(`Error parsing JSON captions: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  /**
   * Fetch and parse a caption track from URL
   */
  private async fetchAndParseTrack(url: string): Promise<string | null> {
    try {
      const response = await axios.get(url, {
        headers: { 'User-Agent': this.userAgent },
        timeout: 10000
      });
      
      if (response.status !== 200) {
        return null;
      }
      
      // Parse the content based on format
      const content = response.data;
      
      if (typeof content === 'string' && content.includes('<text')) {
        // XML format
        return this.parseXmlCaptions(content);
      } else if (typeof content === 'object') {
        // JSON format
        return this.parseJsonCaptions(content);
      }
      
      return null;
    } catch (error) {
      console.error(`Error fetching caption track: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  /**
   * Get enhanced metadata for the video
   */
  private async getEnhancedMetadata(videoId: string): Promise<{ title: string | null; date: string | null; channel: string | null }> {
    try {
      // Try oEmbed API first
      try {
        const oembedUrl = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`;
        const response = await axios.get(oembedUrl, { timeout: 5000 });
        
        if (response.status === 200) {
          return {
            title: response.data.title || null,
            date: new Date().toISOString().split('T')[0],
            channel: response.data.author_name || null
          };
        }
      } catch (error) {
        console.log('oEmbed API failed, trying page metadata');
      }
      
      // Fallback to page metadata
      const url = `https://www.youtube.com/watch?v=${videoId}`;
      const response = await axios.get(url, {
        headers: { 'User-Agent': this.userAgent },
        timeout: 10000
      });
      
      const html = response.data;
      
      // Extract metadata using regex
      const titleMatch = html.match(/"title":"([^"]+)"/);
      const channelMatch = html.match(/"ownerChannelName":"([^"]+)"/);
      const dateMatch = html.match(/"publishDate":"([^"]+)"/);
      
      return {
        title: titleMatch ? this.decodeHtmlEntities(titleMatch[1]) : null,
        channel: channelMatch ? this.decodeHtmlEntities(channelMatch[1]) : null,
        date: dateMatch ? dateMatch[1] : new Date().toISOString().split('T')[0]
      };
    } catch (error) {
      console.error(`Error getting metadata: ${error instanceof Error ? error.message : String(error)}`);
      return { title: null, date: null, channel: null };
    }
  }
  
  /**
   * Decode HTML entities in text
   */
  private decodeHtmlEntities(text: string): string {
    const entities: Record<string, string> = {
      '&amp;': '&',
      '&lt;': '<',
      '&gt;': '>',
      '&quot;': '"',
      '&#39;': "'",
      '&nbsp;': ' ',
      '\\u0026': '&'
    };
    
    return text.replace(/&amp;|&lt;|&gt;|&quot;|&#39;|&nbsp;|\\u0026/g, match => entities[match]);
  }
}

================
File: server/ts-caption-scraper.ts
================
import axios from 'axios';
import * as cheerio from 'cheerio';

interface CaptionTrack {
  languageCode: string;
  name?: string;
  kind?: string;
  baseUrl?: string;
}

export interface CaptionResult {
  transcript: string;
  title: string;
  date: string;
  channel: string;
  videoId: string;
  extractionMethod: string;
}

export class TsCaptionScraper {
  private readonly userAgent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36';
  
  async extractCaptions(videoId: string): Promise<CaptionResult | null> {
    try {
      console.log(`Starting TS caption extraction for video: ${videoId}`);
      
      // Try direct caption extraction
      const captionText = await this.extractDirectCaptions(videoId);
      
      if (!captionText || captionText.length < 50) {
        console.log('Direct caption extraction failed, trying page scraping');
        return null;
      }
      
      // Get basic metadata
      const { title, date, channel } = await this.getBasicMetadata(videoId);
      
      return {
        transcript: captionText,
        title: title || `Video ${videoId}`,
        date: date || new Date().toISOString().split('T')[0],
        channel: channel || 'Unknown Channel',
        videoId,
        extractionMethod: 'web_scraping'
      };
    } catch (error) {
      console.error(`Error extracting captions: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  private async extractDirectCaptions(videoId: string): Promise<string | null> {
    try {
      // Get the video page to extract caption data
      const url = `https://www.youtube.com/watch?v=${videoId}`;
      console.log(`Fetching video page: ${url}`);
      
      const response = await axios.get(url, {
        headers: {
          'User-Agent': this.userAgent,
          'Accept-Language': 'en-US,en;q=0.9',
          'Referer': 'https://www.google.com/'
        },
        timeout: 15000
      });
      
      if (response.status !== 200) {
        console.error(`Failed to fetch video page: ${response.status}`);
        return null;
      }
      
      const html = response.data;
      
      // Extract player configuration
      const playerConfigMatch = html.match(/ytInitialPlayerResponse\s*=\s*({.+?});/);
      
      if (!playerConfigMatch) {
        console.error('Could not find player configuration');
        return null;
      }
      
      const playerConfig = JSON.parse(playerConfigMatch[1]);
      
      // Extract caption tracks
      const captions = playerConfig.captions;
      if (!captions) {
        console.error('No captions data found in player config');
        return null;
      }
      
      const captionTracks: CaptionTrack[] = captions.playerCaptionsTracklistRenderer?.captionTracks || [];
      
      if (captionTracks.length === 0) {
        console.error('No caption tracks found');
        return null;
      }
      
      console.log(`Found ${captionTracks.length} caption tracks`);
      
      // Find English caption track
      let englishTrack = captionTracks.find(track => 
        track.languageCode && track.languageCode.startsWith('en') && track.kind !== 'asr'
      );
      
      // Fall back to auto-generated if no manual English track
      if (!englishTrack) {
        englishTrack = captionTracks.find(track => 
          track.languageCode && track.languageCode.startsWith('en')
        );
      }
      
      // Fall back to any track if no English track
      if (!englishTrack && captionTracks.length > 0) {
        englishTrack = captionTracks[0];
      }
      
      if (!englishTrack || !englishTrack.baseUrl) {
        console.error('No suitable caption track found');
        return null;
      }
      
      // Download caption file
      console.log(`Downloading captions from: ${englishTrack.baseUrl}`);
      const captionResponse = await axios.get(englishTrack.baseUrl, {
        headers: { 'User-Agent': this.userAgent },
        timeout: 10000
      });
      
      if (captionResponse.status !== 200) {
        console.error(`Failed to download captions: ${captionResponse.status}`);
        return null;
      }
      
      const captionContent = captionResponse.data;
      
      // Parse caption content
      return this.parseXmlCaptions(captionContent);
    } catch (error) {
      console.error(`Error in direct caption extraction: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  private parseXmlCaptions(xml: string): string | null {
    try {
      // Extract text from XML captions
      const textMatches = xml.match(/<text[^>]*>([^<]+)<\/text>/g);
      
      if (!textMatches || textMatches.length === 0) {
        console.error('No text matches found in XML');
        return null;
      }
      
      console.log(`Found ${textMatches.length} text segments`);
      
      // Extract text content from each match
      const textContents = textMatches.map(match => {
        // Remove XML tags
        const text = match.replace(/<[^>]+>/g, '');
        // Decode HTML entities
        return this.decodeHtmlEntities(text);
      });
      
      // Join text segments
      let transcript = textContents.join(' ');
      
      // Clean up whitespace
      transcript = transcript.replace(/\s+/g, ' ').trim();
      
      return transcript;
    } catch (error) {
      console.error(`Error parsing captions: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  private decodeHtmlEntities(text: string): string {
    const entities: Record<string, string> = {
      '&amp;': '&',
      '&lt;': '<',
      '&gt;': '>',
      '&quot;': '"',
      '&#39;': "'",
      '&nbsp;': ' '
    };
    
    return text.replace(/&amp;|&lt;|&gt;|&quot;|&#39;|&nbsp;/g, match => entities[match]);
  }
  
  private async getBasicMetadata(videoId: string): Promise<{ title: string | null; date: string | null; channel: string | null }> {
    try {
      // Use YouTube oEmbed API to get basic metadata
      const oembedUrl = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`;
      
      const response = await axios.get(oembedUrl, {
        headers: { 'User-Agent': this.userAgent },
        timeout: 5000
      });
      
      if (response.status === 200) {
        const data = response.data;
        return {
          title: data.title || null,
          date: new Date().toISOString().split('T')[0], // oEmbed doesn't provide date
          channel: data.author_name || null
        };
      }
    } catch (error) {
      console.error(`Error getting metadata: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    return { title: null, date: null, channel: null };
  }
}

================
File: server/vite.ts
================
import express, { type Express } from "express";
import fs from "fs";
import path from "path";
import { createServer as createViteServer, createLogger } from "vite";
import { type Server } from "http";
import viteConfig from "../vite.config";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

export async function setupVite(app: Express, server: Server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions as any,
    appType: "custom",
  });

  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html",
      );

      // always reload the index.html file from disk incase it changes
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}

export function serveStatic(app: Express) {
  const distPath = path.resolve(import.meta.dirname, "public");

  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }

  app.use(express.static(distPath));

  // fall through to index.html if the file doesn't exist
  app.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}

================
File: server/youtube_handler.py
================
import re
import os
import tempfile
from datetime import datetime
from typing import Optional, Dict
from youtube_transcript_api import YouTubeTranscriptApi
import requests
import yt_dlp
import whisper
from pydub import AudioSegment
from googleapiclient.discovery import build

class YouTubeHandler:
    def __init__(self):
        """Initialize YouTube handler"""
        self.whisper_model = None  # Load model only when needed to save memory
        self.youtube_api = None
        self._init_youtube_api()
    
    def _init_youtube_api(self):
        """Initialize YouTube Data API with authentication"""
        try:
            api_key = os.getenv('YOUTUBE_API_KEY')
            if api_key:
                self.youtube_api = build('youtube', 'v3', developerKey=api_key)
                print("YouTube API initialized successfully with authentication")
            else:
                print("YouTube API key not found, using fallback methods")
        except Exception as e:
            print(f"Failed to initialize YouTube API: {e}")
    
    def extract_video_id(self, url: str) -> Optional[str]:
        """Extract video ID from various YouTube URL formats"""
        patterns = [
            r'(?:https?://)?(?:www\.)?youtube\.com/watch\?v=([a-zA-Z0-9_-]+)',
            r'(?:https?://)?(?:www\.)?youtu\.be/([a-zA-Z0-9_-]+)',
            r'(?:https?://)?(?:www\.)?youtube\.com/embed/([a-zA-Z0-9_-]+)',
            r'(?:https?://)?(?:www\.)?youtube\.com/v/([a-zA-Z0-9_-]+)'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                return match.group(1)
        return None

    def get_video_metadata(self, video_id: str) -> Dict:
        """Get real video metadata using YouTube oEmbed API"""
        try:
            url = f"https://www.youtube.com/watch?v={video_id}"
            response = requests.get(f"https://www.youtube.com/oembed?url={url}&format=json")
            
            if response.status_code == 200:
                data = response.json()
                return {
                    'title': data.get('title', f'Video {video_id}'),
                    'channel': data.get('author_name', 'Unknown Channel'),
                    'thumbnail_url': data.get('thumbnail_url', f'https://img.youtube.com/vi/{video_id}/maxresdefault.jpg'),
                    'video_id': video_id
                }
        except Exception as e:
            print(f"Error fetching metadata: {e}")
        
        return {
            'title': f'Video {video_id}',
            'channel': 'Unknown Channel',
            'thumbnail_url': f'https://img.youtube.com/vi/{video_id}/maxresdefault.jpg',
            'video_id': video_id
        }

    def extract_transcript(self, video_id: str) -> Optional[str]:
        """Extract transcript using youtube-transcript-api"""
        try:
            transcript_list = YouTubeTranscriptApi.get_transcript(
                video_id,
                languages=['en', 'en-US', 'en-GB']
            )
            
            # Combine transcript segments into full text
            full_transcript = ""
            for segment in transcript_list:
                full_transcript += segment['text'] + " "
            
            return full_transcript.strip()
            
        except Exception as e:
            raise Exception(f"Failed to extract transcript: {str(e)}")

if __name__ == "__main__":
    # Test the handler
    handler = YouTubeHandler()
    test_url = "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
    video_id = handler.extract_video_id(test_url)
    if video_id:
        metadata = handler.get_video_metadata(video_id)
        print(f"Title: {metadata['title']}")
        print(f"Channel: {metadata['channel']}")

================
File: shared/schema.ts
================
import { pgTable, text, serial, integer, boolean, timestamp, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  email: text("email").notNull().unique(),
  password: text("password").notNull(),
  role: text("role").notNull().default("user"), // "admin", "user"
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const admin = pgTable("admin", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const episodes = pgTable("episodes", {
  id: serial("id").primaryKey(),
  videoId: text("video_id").notNull().unique(),
  title: text("title").notNull(),
  description: text("description"),
  channel: text("channel"),
  duration: text("duration"),
  thumbnailUrl: text("thumbnail_url"),
  youtubeUrl: text("youtube_url").notNull(),
  status: text("status").notNull().default("pending"), // "pending", "processing", "completed", "failed"
  extractionMethod: text("extraction_method").notNull(), // "caption", "scraping", "audio"
  transcript: text("transcript"),
  summary: text("summary"),
  topics: jsonb("topics").default([]),
  wordCount: integer("word_count"),
  progress: integer("progress").default(0),
  currentStep: text("current_step").default("Preparing to process..."),
  processingStarted: timestamp("processing_started"),
  processingCompleted: timestamp("processing_completed"),
  errorMessage: text("error_message"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  generateSummary: boolean("generate_summary").default(false),
  extractTopics: boolean("extract_topics").default(false),
});

export const searchQueries = pgTable("search_queries", {
  id: serial("id").primaryKey(),
  query: text("query").notNull(),
  userId: integer("user_id").references(() => users.id),
  resultCount: integer("result_count").default(0),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const processingQueue = pgTable("processing_queue", {
  id: serial("id").primaryKey(),
  episodeId: integer("episode_id").references(() => episodes.id).notNull(),
  priority: integer("priority").default(0),
  attempts: integer("attempts").default(0),
  maxAttempts: integer("max_attempts").default(3),
  status: text("status").notNull().default("queued"), // "queued", "processing", "completed", "failed"
  createdAt: timestamp("created_at").defaultNow().notNull(),
  startedAt: timestamp("started_at"),
  completedAt: timestamp("completed_at"),
});

// Insert schemas
export const insertUserSchema = createInsertSchema(users).omit({
  id: true,
  createdAt: true,
});

export const insertEpisodeSchema = createInsertSchema(episodes).omit({
  id: true,
  createdAt: true,
  processingStarted: true,
  processingCompleted: true,
  title: true,
  description: true,
  channel: true,
  duration: true,
  thumbnailUrl: true,
  videoId: true,
  transcript: true,
  summary: true,
  topics: true,
  wordCount: true,
  errorMessage: true,
}).extend({
  youtubeUrl: z.string().url(),
  extractionMethod: z.enum(["caption", "scraping", "audio"]),
  generateSummary: z.boolean().optional(),
  extractTopics: z.boolean().optional(),
});

export const insertSearchQuerySchema = createInsertSchema(searchQueries).omit({
  id: true,
  createdAt: true,
});

export const adminLoginSchema = z.object({
  username: z.string(),
  password: z.string(),
});

// Types
export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;

export type Episode = typeof episodes.$inferSelect;
export type InsertEpisode = z.infer<typeof insertEpisodeSchema>;

export type SearchQuery = typeof searchQueries.$inferSelect;
export type InsertSearchQuery = z.infer<typeof insertSearchQuerySchema>;

export type ProcessingQueueItem = typeof processingQueue.$inferSelect;

export type Admin = typeof admin.$inferSelect;
export type AdminLogin = z.infer<typeof adminLoginSchema>;

// API Response types
export type EpisodeWithProgress = Episode & {
  progress?: number;
  estimatedTime?: string;
};

export type SearchResult = {
  episode: Episode;
  highlights: Array<{
    segment: string;
    timestamp: string;
    matchScore: number;
  }>;
  totalMatches: number;
};

export type SystemStats = {
  totalEpisodes: number;
  processingQueue: number;
  successRate: number;
  averageProcessingTime: string;
  totalWordCount: string;
  dailyProcessed: number;
  methodDistribution: {
    caption: number;
    scraping: number;
    audio: number;
  };
  trends?: {
    totalEpisodes?: number;
    successRate?: number;
    processingTime?: number;
    wordCount?: number;
  };
  history?: {
    totalEpisodes?: number[];
    processingTime?: number[];
    wordCount?: number[];
  };
  lastUpdated?: string;
};

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
        "pulse-slow": {
          "0%, 100%": {
            opacity: "0",
          },
          "50%": {
            opacity: "1",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "pulse-slow": "pulse-slow 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;

================
File: tsconfig.json
================
{
  "include": ["client/src/**/*", "shared/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    },
    "allowJs": true,
    "noImplicitAny": false
  }
}

================
File: uv.lock
================
version = 1
requires-python = ">=3.11"

[[package]]
name = "certifi"
version = "2025.4.26"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/e8/9e/c05b3920a3b7d20d3d3310465f50348e5b3694f4f88c6daf736eef3024c4/certifi-2025.4.26.tar.gz", hash = "sha256:0a816057ea3cdefcef70270d2c515e4506bbc954f417fa5ade2021213bb8f0c6", size = 160705 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/4a/7e/3db2bd1b1f9e95f7cddca6d6e75e2f2bd9f51b1246e546d88addca0106bd/certifi-2025.4.26-py3-none-any.whl", hash = "sha256:30350364dfe371162649852c63336a15c70c6510c2ad5015b21c2345311805f3", size = 159618 },
]

[[package]]
name = "charset-normalizer"
version = "3.4.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/e4/33/89c2ced2b67d1c2a61c19c6751aa8902d46ce3dacb23600a283619f5a12d/charset_normalizer-3.4.2.tar.gz", hash = "sha256:5baececa9ecba31eff645232d59845c07aa030f0c81ee70184a90d35099a0e63", size = 126367 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/05/85/4c40d00dcc6284a1c1ad5de5e0996b06f39d8232f1031cd23c2f5c07ee86/charset_normalizer-3.4.2-cp311-cp311-macosx_10_9_universal2.whl", hash = "sha256:be1e352acbe3c78727a16a455126d9ff83ea2dfdcbc83148d2982305a04714c2", size = 198794 },
    { url = "https://files.pythonhosted.org/packages/41/d9/7a6c0b9db952598e97e93cbdfcb91bacd89b9b88c7c983250a77c008703c/charset_normalizer-3.4.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:aa88ca0b1932e93f2d961bf3addbb2db902198dca337d88c89e1559e066e7645", size = 142846 },
    { url = "https://files.pythonhosted.org/packages/66/82/a37989cda2ace7e37f36c1a8ed16c58cf48965a79c2142713244bf945c89/charset_normalizer-3.4.2-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:d524ba3f1581b35c03cb42beebab4a13e6cdad7b36246bd22541fa585a56cccd", size = 153350 },
    { url = "https://files.pythonhosted.org/packages/df/68/a576b31b694d07b53807269d05ec3f6f1093e9545e8607121995ba7a8313/charset_normalizer-3.4.2-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:28a1005facc94196e1fb3e82a3d442a9d9110b8434fc1ded7a24a2983c9888d8", size = 145657 },
    { url = "https://files.pythonhosted.org/packages/92/9b/ad67f03d74554bed3aefd56fe836e1623a50780f7c998d00ca128924a499/charset_normalizer-3.4.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:fdb20a30fe1175ecabed17cbf7812f7b804b8a315a25f24678bcdf120a90077f", size = 147260 },
    { url = "https://files.pythonhosted.org/packages/a6/e6/8aebae25e328160b20e31a7e9929b1578bbdc7f42e66f46595a432f8539e/charset_normalizer-3.4.2-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:0f5d9ed7f254402c9e7d35d2f5972c9bbea9040e99cd2861bd77dc68263277c7", size = 149164 },
    { url = "https://files.pythonhosted.org/packages/8b/f2/b3c2f07dbcc248805f10e67a0262c93308cfa149a4cd3d1fe01f593e5fd2/charset_normalizer-3.4.2-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:efd387a49825780ff861998cd959767800d54f8308936b21025326de4b5a42b9", size = 144571 },
    { url = "https://files.pythonhosted.org/packages/60/5b/c3f3a94bc345bc211622ea59b4bed9ae63c00920e2e8f11824aa5708e8b7/charset_normalizer-3.4.2-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:f0aa37f3c979cf2546b73e8222bbfa3dc07a641585340179d768068e3455e544", size = 151952 },
    { url = "https://files.pythonhosted.org/packages/e2/4d/ff460c8b474122334c2fa394a3f99a04cf11c646da895f81402ae54f5c42/charset_normalizer-3.4.2-cp311-cp311-musllinux_1_2_ppc64le.whl", hash = "sha256:e70e990b2137b29dc5564715de1e12701815dacc1d056308e2b17e9095372a82", size = 155959 },
    { url = "https://files.pythonhosted.org/packages/a2/2b/b964c6a2fda88611a1fe3d4c400d39c66a42d6c169c924818c848f922415/charset_normalizer-3.4.2-cp311-cp311-musllinux_1_2_s390x.whl", hash = "sha256:0c8c57f84ccfc871a48a47321cfa49ae1df56cd1d965a09abe84066f6853b9c0", size = 153030 },
    { url = "https://files.pythonhosted.org/packages/59/2e/d3b9811db26a5ebf444bc0fa4f4be5aa6d76fc6e1c0fd537b16c14e849b6/charset_normalizer-3.4.2-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:6b66f92b17849b85cad91259efc341dce9c1af48e2173bf38a85c6329f1033e5", size = 148015 },
    { url = "https://files.pythonhosted.org/packages/90/07/c5fd7c11eafd561bb51220d600a788f1c8d77c5eef37ee49454cc5c35575/charset_normalizer-3.4.2-cp311-cp311-win32.whl", hash = "sha256:daac4765328a919a805fa5e2720f3e94767abd632ae410a9062dff5412bae65a", size = 98106 },
    { url = "https://files.pythonhosted.org/packages/a8/05/5e33dbef7e2f773d672b6d79f10ec633d4a71cd96db6673625838a4fd532/charset_normalizer-3.4.2-cp311-cp311-win_amd64.whl", hash = "sha256:e53efc7c7cee4c1e70661e2e112ca46a575f90ed9ae3fef200f2a25e954f4b28", size = 105402 },
    { url = "https://files.pythonhosted.org/packages/d7/a4/37f4d6035c89cac7930395a35cc0f1b872e652eaafb76a6075943754f095/charset_normalizer-3.4.2-cp312-cp312-macosx_10_13_universal2.whl", hash = "sha256:0c29de6a1a95f24b9a1aa7aefd27d2487263f00dfd55a77719b530788f75cff7", size = 199936 },
    { url = "https://files.pythonhosted.org/packages/ee/8a/1a5e33b73e0d9287274f899d967907cd0bf9c343e651755d9307e0dbf2b3/charset_normalizer-3.4.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:cddf7bd982eaa998934a91f69d182aec997c6c468898efe6679af88283b498d3", size = 143790 },
    { url = "https://files.pythonhosted.org/packages/66/52/59521f1d8e6ab1482164fa21409c5ef44da3e9f653c13ba71becdd98dec3/charset_normalizer-3.4.2-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:fcbe676a55d7445b22c10967bceaaf0ee69407fbe0ece4d032b6eb8d4565982a", size = 153924 },
    { url = "https://files.pythonhosted.org/packages/86/2d/fb55fdf41964ec782febbf33cb64be480a6b8f16ded2dbe8db27a405c09f/charset_normalizer-3.4.2-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:d41c4d287cfc69060fa91cae9683eacffad989f1a10811995fa309df656ec214", size = 146626 },
    { url = "https://files.pythonhosted.org/packages/8c/73/6ede2ec59bce19b3edf4209d70004253ec5f4e319f9a2e3f2f15601ed5f7/charset_normalizer-3.4.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:4e594135de17ab3866138f496755f302b72157d115086d100c3f19370839dd3a", size = 148567 },
    { url = "https://files.pythonhosted.org/packages/09/14/957d03c6dc343c04904530b6bef4e5efae5ec7d7990a7cbb868e4595ee30/charset_normalizer-3.4.2-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:cf713fe9a71ef6fd5adf7a79670135081cd4431c2943864757f0fa3a65b1fafd", size = 150957 },
    { url = "https://files.pythonhosted.org/packages/0d/c8/8174d0e5c10ccebdcb1b53cc959591c4c722a3ad92461a273e86b9f5a302/charset_normalizer-3.4.2-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:a370b3e078e418187da8c3674eddb9d983ec09445c99a3a263c2011993522981", size = 145408 },
    { url = "https://files.pythonhosted.org/packages/58/aa/8904b84bc8084ac19dc52feb4f5952c6df03ffb460a887b42615ee1382e8/charset_normalizer-3.4.2-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:a955b438e62efdf7e0b7b52a64dc5c3396e2634baa62471768a64bc2adb73d5c", size = 153399 },
    { url = "https://files.pythonhosted.org/packages/c2/26/89ee1f0e264d201cb65cf054aca6038c03b1a0c6b4ae998070392a3ce605/charset_normalizer-3.4.2-cp312-cp312-musllinux_1_2_ppc64le.whl", hash = "sha256:7222ffd5e4de8e57e03ce2cef95a4c43c98fcb72ad86909abdfc2c17d227fc1b", size = 156815 },
    { url = "https://files.pythonhosted.org/packages/fd/07/68e95b4b345bad3dbbd3a8681737b4338ff2c9df29856a6d6d23ac4c73cb/charset_normalizer-3.4.2-cp312-cp312-musllinux_1_2_s390x.whl", hash = "sha256:bee093bf902e1d8fc0ac143c88902c3dfc8941f7ea1d6a8dd2bcb786d33db03d", size = 154537 },
    { url = "https://files.pythonhosted.org/packages/77/1a/5eefc0ce04affb98af07bc05f3bac9094513c0e23b0562d64af46a06aae4/charset_normalizer-3.4.2-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:dedb8adb91d11846ee08bec4c8236c8549ac721c245678282dcb06b221aab59f", size = 149565 },
    { url = "https://files.pythonhosted.org/packages/37/a0/2410e5e6032a174c95e0806b1a6585eb21e12f445ebe239fac441995226a/charset_normalizer-3.4.2-cp312-cp312-win32.whl", hash = "sha256:db4c7bf0e07fc3b7d89ac2a5880a6a8062056801b83ff56d8464b70f65482b6c", size = 98357 },
    { url = "https://files.pythonhosted.org/packages/6c/4f/c02d5c493967af3eda9c771ad4d2bbc8df6f99ddbeb37ceea6e8716a32bc/charset_normalizer-3.4.2-cp312-cp312-win_amd64.whl", hash = "sha256:5a9979887252a82fefd3d3ed2a8e3b937a7a809f65dcb1e068b090e165bbe99e", size = 105776 },
    { url = "https://files.pythonhosted.org/packages/ea/12/a93df3366ed32db1d907d7593a94f1fe6293903e3e92967bebd6950ed12c/charset_normalizer-3.4.2-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:926ca93accd5d36ccdabd803392ddc3e03e6d4cd1cf17deff3b989ab8e9dbcf0", size = 199622 },
    { url = "https://files.pythonhosted.org/packages/04/93/bf204e6f344c39d9937d3c13c8cd5bbfc266472e51fc8c07cb7f64fcd2de/charset_normalizer-3.4.2-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:eba9904b0f38a143592d9fc0e19e2df0fa2e41c3c3745554761c5f6447eedabf", size = 143435 },
    { url = "https://files.pythonhosted.org/packages/22/2a/ea8a2095b0bafa6c5b5a55ffdc2f924455233ee7b91c69b7edfcc9e02284/charset_normalizer-3.4.2-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:3fddb7e2c84ac87ac3a947cb4e66d143ca5863ef48e4a5ecb83bd48619e4634e", size = 153653 },
    { url = "https://files.pythonhosted.org/packages/b6/57/1b090ff183d13cef485dfbe272e2fe57622a76694061353c59da52c9a659/charset_normalizer-3.4.2-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:98f862da73774290f251b9df8d11161b6cf25b599a66baf087c1ffe340e9bfd1", size = 146231 },
    { url = "https://files.pythonhosted.org/packages/e2/28/ffc026b26f441fc67bd21ab7f03b313ab3fe46714a14b516f931abe1a2d8/charset_normalizer-3.4.2-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:6c9379d65defcab82d07b2a9dfbfc2e95bc8fe0ebb1b176a3190230a3ef0e07c", size = 148243 },
    { url = "https://files.pythonhosted.org/packages/c0/0f/9abe9bd191629c33e69e47c6ef45ef99773320e9ad8e9cb08b8ab4a8d4cb/charset_normalizer-3.4.2-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:e635b87f01ebc977342e2697d05b56632f5f879a4f15955dfe8cef2448b51691", size = 150442 },
    { url = "https://files.pythonhosted.org/packages/67/7c/a123bbcedca91d5916c056407f89a7f5e8fdfce12ba825d7d6b9954a1a3c/charset_normalizer-3.4.2-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:1c95a1e2902a8b722868587c0e1184ad5c55631de5afc0eb96bc4b0d738092c0", size = 145147 },
    { url = "https://files.pythonhosted.org/packages/ec/fe/1ac556fa4899d967b83e9893788e86b6af4d83e4726511eaaad035e36595/charset_normalizer-3.4.2-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:ef8de666d6179b009dce7bcb2ad4c4a779f113f12caf8dc77f0162c29d20490b", size = 153057 },
    { url = "https://files.pythonhosted.org/packages/2b/ff/acfc0b0a70b19e3e54febdd5301a98b72fa07635e56f24f60502e954c461/charset_normalizer-3.4.2-cp313-cp313-musllinux_1_2_ppc64le.whl", hash = "sha256:32fc0341d72e0f73f80acb0a2c94216bd704f4f0bce10aedea38f30502b271ff", size = 156454 },
    { url = "https://files.pythonhosted.org/packages/92/08/95b458ce9c740d0645feb0e96cea1f5ec946ea9c580a94adfe0b617f3573/charset_normalizer-3.4.2-cp313-cp313-musllinux_1_2_s390x.whl", hash = "sha256:289200a18fa698949d2b39c671c2cc7a24d44096784e76614899a7ccf2574b7b", size = 154174 },
    { url = "https://files.pythonhosted.org/packages/78/be/8392efc43487ac051eee6c36d5fbd63032d78f7728cb37aebcc98191f1ff/charset_normalizer-3.4.2-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:4a476b06fbcf359ad25d34a057b7219281286ae2477cc5ff5e3f70a246971148", size = 149166 },
    { url = "https://files.pythonhosted.org/packages/44/96/392abd49b094d30b91d9fbda6a69519e95802250b777841cf3bda8fe136c/charset_normalizer-3.4.2-cp313-cp313-win32.whl", hash = "sha256:aaeeb6a479c7667fbe1099af9617c83aaca22182d6cf8c53966491a0f1b7ffb7", size = 98064 },
    { url = "https://files.pythonhosted.org/packages/e9/b0/0200da600134e001d91851ddc797809e2fe0ea72de90e09bec5a2fbdaccb/charset_normalizer-3.4.2-cp313-cp313-win_amd64.whl", hash = "sha256:aa6af9e7d59f9c12b33ae4e9450619cf2488e2bbe9b44030905877f0b2324980", size = 105641 },
    { url = "https://files.pythonhosted.org/packages/20/94/c5790835a017658cbfabd07f3bfb549140c3ac458cfc196323996b10095a/charset_normalizer-3.4.2-py3-none-any.whl", hash = "sha256:7f56930ab0abd1c45cd15be65cc741c28b1c9a34876ce8c17a2fa107810c0af0", size = 52626 },
]

[[package]]
name = "defusedxml"
version = "0.7.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/0f/d5/c66da9b79e5bdb124974bfe172b4daf3c984ebd9c2a06e2b8a4dc7331c72/defusedxml-0.7.1.tar.gz", hash = "sha256:1bb3032db185915b62d7c6209c5a8792be6a32ab2fedacc84e01b52c51aa3e69", size = 75520 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/07/6c/aa3f2f849e01cb6a001cd8554a88d4c77c5c1a31c95bdf1cf9301e6d9ef4/defusedxml-0.7.1-py2.py3-none-any.whl", hash = "sha256:a352e7e428770286cc899e2542b6cdaedb2b4953ff269a210103ec58f6198a61", size = 25604 },
]

[[package]]
name = "idna"
version = "3.10"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f1/70/7703c29685631f5a7590aa73f1f1d3fa9a380e654b86af429e0934a32f7d/idna-3.10.tar.gz", hash = "sha256:12f65c9b470abda6dc35cf8e63cc574b1c52b11df2c86030af0ac09b01b13ea9", size = 190490 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/76/c6/c88e154df9c4e1a2a66ccf0005a88dfb2650c1dffb6f5ce603dfbd452ce3/idna-3.10-py3-none-any.whl", hash = "sha256:946d195a0d259cbba61165e88e65941f16e9b36ea6ddb97f00452bae8b1287d3", size = 70442 },
]

[[package]]
name = "repl-nix-workspace"
version = "0.1.0"
source = { virtual = "." }
dependencies = [
    { name = "requests" },
    { name = "youtube-transcript-api" },
]

[package.metadata]
requires-dist = [
    { name = "requests", specifier = ">=2.32.3" },
    { name = "youtube-transcript-api", specifier = ">=1.0.3" },
]

[[package]]
name = "requests"
version = "2.32.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "certifi" },
    { name = "charset-normalizer" },
    { name = "idna" },
    { name = "urllib3" },
]
sdist = { url = "https://files.pythonhosted.org/packages/63/70/2bf7780ad2d390a8d301ad0b550f1581eadbd9a20f896afe06353c2a2913/requests-2.32.3.tar.gz", hash = "sha256:55365417734eb18255590a9ff9eb97e9e1da868d4ccd6402399eaf68af20a760", size = 131218 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/f9/9b/335f9764261e915ed497fcdeb11df5dfd6f7bf257d4a6a2a686d80da4d54/requests-2.32.3-py3-none-any.whl", hash = "sha256:70761cfe03c773ceb22aa2f671b4757976145175cdfca038c02654d061d6dcc6", size = 64928 },
]

[[package]]
name = "urllib3"
version = "2.4.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/8a/78/16493d9c386d8e60e442a35feac5e00f0913c0f4b7c217c11e8ec2ff53e0/urllib3-2.4.0.tar.gz", hash = "sha256:414bc6535b787febd7567804cc015fee39daab8ad86268f1310a9250697de466", size = 390672 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/6b/11/cc635220681e93a0183390e26485430ca2c7b5f9d33b15c74c2861cb8091/urllib3-2.4.0-py3-none-any.whl", hash = "sha256:4e16665048960a0900c702d4a66415956a584919c03361cac9f1df5c5dd7e813", size = 128680 },
]

[[package]]
name = "youtube-transcript-api"
version = "1.0.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "defusedxml" },
    { name = "requests" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b0/32/f60d87a99c05a53604c58f20f670c7ea6262b55e0bbeb836ffe4550b248b/youtube_transcript_api-1.0.3.tar.gz", hash = "sha256:902baf90e7840a42e1e148335e09fe5575dbff64c81414957aea7038e8a4db46", size = 2153252 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/f0/44/40c03bb0f8bddfb9d2beff2ed31641f52d96c287ba881d20e0c074784ac2/youtube_transcript_api-1.0.3-py3-none-any.whl", hash = "sha256:d1874e57de65cf14c9d7d09b2b37c814d6287fa0e770d4922c4cd32a5b3f6c47", size = 2169911 },
]

================
File: vite.config.ts
================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import dotenv from "dotenv";

dotenv.config();

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...(process.env.NODE_ENV !== "production" &&
    process.env.REPL_ID !== undefined
      ? [
          await import("@replit/vite-plugin-cartographer").then((m) =>
            m.cartographer(),
          ),
        ]
      : []),
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets"),
    },
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true,
  },
});
